---
title: C++中的四种cast
---
在 C++ 中，有四种主要的类型转换（cast）操作符，用于在不同类型之间进行转换，它们分别是：

***

### 1. `static_cast` \[#1-static\_cast]

**用途**：用于**编译时类型转换**，适用于基本类型之间的转换（如 `int` 转 `float`）、指针/引用向上转型（从子类转为父类）。

**特点**：

* 编译时检查类型安全。

* 无运行时类型检查。

* 不适用于不同类型的指针之间转换（如 `int*` 到 `char*`）。

**示例**：

```cpp
int a = 10;
double b = static_cast<double>(a);  // int -> double
```

***

### 2. `dynamic_cast` \[#2-dynamic\_cast]

**用途**：用于**运行时类型转换**，主要在有继承关系的类层次结构中进行**向下转型**（从父类转为子类）。

**特点**：

* 需要至少一个虚函数（即类要有虚函数表）。

* 使用指针时，转换失败返回 `nullptr`。

* 使用引用时，转换失败会抛出 `std::bad_cast` 异常。

**示例**：

```cpp
class Base { virtual void func() {} };
class Derived : public Base {};
Base* base = new Derived;
Derived* d = dynamic_cast<Derived*>(base);  // 成功
```

***

### 3. `const_cast` \[#3-const\_cast]

**用途**：用于**添加或移除 `const` / `volatile` 修饰符**。

**特点**：

* 不会改变对象本身的常量性，只是让编译器“忽略”它。

* 对真正的常量对象使用会导致未定义行为。

**示例**：

```cpp
const int a = 10;
int* p = const_cast<int*>(&a);  // 去除 const
```

***

### 4. `reinterpret_cast` \[#4-reinterpret\_cast]

**用途**：进行**底层位级别的类型转换**，比如不同类型的指针之间的转换，或指针与整数之间的转换。

**特点**：

* 非常危险，不会检查类型安全。

* 结果取决于平台和实现，可能不可移植。

**示例**：

```cpp
int* p = new int(10);
char* cp = reinterpret_cast<char*>(p);  // 指针类型强转
```

***

### 总结对比： \[#总结对比]

|类型|安全性|用途|检查类型|
|---|---|---|---|
|`static_cast`|较安全|常规类型转换|编译期|
|`dynamic_cast`|安全|类之间的上下转型|运行期|
|`const_cast`|有风险|增删 const/volatile|编译期|
|`reinterpret_cast`|非常危险|底层、无类型检查的转换|编译期|

## 类型转换异常 \[#类型转换异常]

| 情况         | 结果                          |
| ---------- | --------------------------- |
| 指针转换（无继承）  | 返回 `nullptr`                |
| 引用转换（无继承）  | 抛出 `std::bad_cast`          |
| 是否安全？      | 是，`dynamic_cast` 设计用于类型安全检查 |
| 是否依赖 RTTI？ | 是，必须启用                      |
