---
title: C++ 多线程中的互斥锁
---
# C++ 多线程中的互斥锁

互斥锁是C++多线程编程中解决数据竞争的关键机制，它能确保在任何时刻只有一个线程能访问受保护的共享资源。本报告将深入探讨C++中互斥锁的原理、实现方式及应用场景，帮助开发者构建安全高效的多线程程序。

## 互斥锁的基本概念与原理

互斥锁的核心思想是通过锁定机制确保共享资源的互斥访问。当一个线程需要访问共享资源时，它会先尝试获取互斥锁；如果锁已被其他线程占用，那么当前线程会被阻塞，直到锁被释放为止。这种机制保证了在任何时刻只有一个线程可以进入临界区执行操作，从而防止数据竞争和不一致性问题\[4]。

互斥锁的工作流程通常是：加锁-访问共享资源-解锁。在这个过程中，当一个线程获取锁后，其他尝试获取同一把锁的线程都会等待，直到持有锁的线程完成操作并释放锁\[1]。

### 为什么需要互斥锁

通过一个计算1-10000总和的例子可以清晰地理解互斥锁的必要性。假设我们创建两个线程，分别计算\[1,5000)和\[5000,10001)的和，并将结果存入共享变量：

```cpp
#include <iostream>
#include <thread>

void work1(int& sum) {
    for (int i = 1; i < 5000; i++) {
        sum += i;
    }
}

void work2(int& sum) {
    for (int i = 5000; i <= 10000; i++) {
        sum += i;
    }
}

int main() {
    int ans = 0;
    std::thread t1(work1, std::ref(ans));
    std::thread t2(work2, std::ref(ans));
    t1.join();
    t2.join();
    std::cout << "sum: " << ans << std::endl;
    return 0;
}

```

在没有互斥锁保护的情况下，当两个线程同时修改共享变量`ans`时，可能发生数据竞争：一个线程正在执行`sum += i`操作但尚未完成时，另一个线程也开始执行同样的操作，导致最终结果小于正确值[1](https://cloud.tencent.com/developer/article/1583894)。

这里的问题在于`sum += i`操作不是原子的，它涉及读取当前值、加上新值、写回结果三个步骤。如果线程在这个过程中被切换，就会导致计算结果被覆盖[1](https://cloud.tencent.com/developer/article/1583894)。互斥锁正是为了解决这种共享资源访问冲突而设计的。

## std::mutex 的使用

## 基本用法

C++标准库提供了`std::mutex`类作为互斥锁的基本实现。使用互斥锁的典型模式是：

1. 创建互斥锁对象

2. 在访问共享资源前加锁

3. 访问共享资源

4. 操作完成后解锁

基本示例代码：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mylock;  // 创建互斥锁对象
int sharedData = 0; // 共享资源

void increment() {
    mylock.lock();   // 加锁
    sharedData++;    // 访问共享资源
    mylock.unlock(); // 解锁
}

```

### 使用互斥锁解决上述问题

使用互斥锁改进之前的求和示例：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

void work1(int& sum, std::mutex& mylock) {
    for (int i = 1; i < 5000; i++) {
        mylock.lock();
        sum += i;
        mylock.unlock();
    }
}

void work2(int& sum, std::mutex& mylock) {
    for (int i = 5000; i <= 10000; i++) {
        mylock.lock();
        sum += i;
        mylock.unlock();
    }
}

int main() {
    std::mutex mylock;
    int ans = 0;
    std::thread t1(work1, std::ref(ans), std::ref(mylock));
    std::thread t2(work2, std::ref(ans), std::ref(mylock));
    t1.join();
    t2.join();
    std::cout << "sum: " << ans << std::endl;
    return 0;
}

```

在这个改进版本中，每次对共享变量的修改都受到互斥锁的保护，确保在任一时刻只有一个线程能修改`ans`，从而得到正确的结果[1](https://cloud.tencent.com/developer/article/1583894)。

## 智能锁封装

直接使用`mutex.lock()`和`mutex.unlock()`存在一个潜在问题：如果在加锁和解锁之间发生异常，解锁操作可能无法执行，导致死锁。C++标准库提供了两种智能锁封装来解决这个问题：`std::lock_guard`和`std::unique_lock`。

## std::lock\_guard

`std::lock_guard`是一个简单的RAII（资源获取即初始化）封装类，它在构造时自动获取锁，在析构时自动释放锁，确保锁的正确释放[3](https://blog.csdn.net/m0_52043808/article/details/135853620)。

```cpp
void work1(int& sum, std::mutex& mylock) {
    for (int i = 1; i < 5000; i++) {
        std::lock_guard<std::mutex> lock(mylock); // 构造时加锁
        sum += i;
    } // 作用域结束时自动解锁
}

```

这种方式优雅且安全，能有效防止忘记解锁导致的死锁问题\[1]。

### std::unique\_lock

`std::unique_lock`提供了比`std::lock_guard`更灵活的锁管理功能：

1. 延迟锁定：创建时可以不立即加锁
2. 手动控制：可以显式调用`lock()`和`unlock()`方法
3. 所有权转移：可以在不同作用域间转移锁的所有权
4. 尝试锁定：支持`try_lock()`操作

基本用法：

```cpp
std::unique_lock lock(mutex); // 创建并立即加锁
// 临界区代码
// 析构时自动解锁
```

延迟锁定：

```cpp
std::unique_lock lock(mutex, std::defer_lock); // 创建但不加锁
// 执行其他非临界区操作
lock.lock(); // 需要时手动加锁
// 临界区代码
lock.unlock(); // 手动解锁
// 继续执行其他操作
```

尝试锁定：

```cpp
std::unique_lock lock(mutex, std::defer_lock);
if (lock.try_lock()) {
    // 锁定成功，执行临界区代码
} else {
    // 锁定失败，执行替代逻辑
}
```

这种灵活性使`std::unique_lock`在需要更复杂锁控制的场景中非常有用\[2]。

## 互斥锁的高级应用

### 与条件变量的配合使用

`std::unique_lock`常与条件变量(`std::condition_variable`)一起使用，实现线程间的等待和通知机制：

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker() {
    std::unique_lock lock(mtx);
    while (!ready) {
        cv.wait(lock); // 释放锁并等待通知
    }
    // 条件满足，继续执行
}

void notifier() {
    {
        std::lock_guard lock(mtx);
        ready = true;
    }
    cv.notify_one(); // 通知等待的线程
}
```

条件变量的`wait()`函数在等待时会自动释放锁，接收到通知后再重新获取锁，这种机制需要`std::unique_lock`的灵活性支持\[2]。

### 递归互斥量

标准库还提供了递归互斥量(`std::recursive_mutex`)，它允许同一线程多次获取同一把锁而不会死锁：

```cpp
std::recursive_mutex rmtx;

void recursive_function(int depth) {
    std::lock_guard lock(rmtx);
    // 处理逻辑
    if (depth > 0) {
        recursive_function(depth - 1); // 递归调用，再次获取锁
    }
}
```

递归互斥量内部会跟踪锁定计数，只有当所有锁定都被解锁后，其他线程才能获取这把锁\[4]。

## 最佳实践与注意事项

### 锁的粒度

在使用互斥锁时，应当注意锁的粒度（锁保护的代码范围）：

* 粒度太小：可能无法有效保护共享资源
* 粒度太大：会限制并发性，降低性能

上面的求和例子中，将整个循环体内的加法操作都包含在锁内会大大降低并发性能。一个优化方案是对结果进行局部累加：

```cpp
void work1(int& sum, std::mutex& mylock) {
    int local_sum = 0;
    for (int i = 1; i  lock(mylock);
    sum += local_sum;
}
```

### 避免死锁

使用多个互斥锁时，不正确的加锁顺序可能导致死锁。一种常见的避免死锁的策略是确保所有线程以相同的顺序获取锁，或使用`std::lock`函数同时锁定多个互斥量：

```cpp
std::mutex m1, m2;

// 安全地锁定多个互斥量
std::lock(m1, m2);
std::lock_guard lock1(m1, std::adopt_lock);
std::lock_guard lock2(m2, std::adopt_lock);
```

## 结论

互斥锁是C++多线程编程中保护共享资源的基础机制。通过正确使用`std::mutex`、`std::lock_guard`和`std::unique_lock`，可以有效避免数据竞争，确保多线程程序的正确性。

在实际应用中，应当根据需求选择合适的锁类型和粒度：一般情况下，首选`std::lock_guard`的简洁安全；需要更灵活控制或配合条件变量使用时，选择`std::unique_lock`；在递归调用场景则可以使用`std::recursive_mutex`。

合理使用互斥锁，不仅能确保程序的正确性，还能在保证线程安全的同时尽可能地提高并发性能，是构建高质量多线程C++程序的基石。
