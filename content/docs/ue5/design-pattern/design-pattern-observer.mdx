---
title: 设计模式-观察者
---
1. **问题概述**：
   * 场景：你有一个需要更新敌人数量的UI控件，还有一个需要在所有敌人死亡后打开的门，这些对象（UI控件、门、关卡、敌人、玩家）需要互相通信。
   * 常见错误：许多初学者会在敌人的死亡函数中直接获取UI控件的引用并更新敌人数量。这样做会造成“耦合”，即两个独立对象之间产生了依赖关系。这样，当你想要修改UI控件时，也需要修改敌人类，反之亦然，这样会导致代码难以维护和扩展。

2. **观察者模式（Observer Pattern）**：
   * **概念**：观察者模式（也称为发布-订阅模式）允许在一个事件发生时（如敌人死亡），在游戏中广播一个信号（事件），其他对象可以订阅或监听这个信号，并根据需要做出响应。
   * **优点**：通过这种方式，一个对象可以广播一个信号，而不需要关心其他对象的反应。多个对象或Actor可以订阅这个事件并以不同的方式作出响应，从而实现对象之间的解耦，增强代码的可维护性和扩展性。

3. **实现步骤**：
   * 在敌人Blueprint中，添加一个事件调度器（Event Dispatcher），命名为`OnDeath`，在敌人死亡事件结束时调用它来广播敌人死亡的信号。
   * 在UI控件中，订阅（绑定）敌人的`OnDeath`事件，当接收到事件时，减少敌人数量并更新UI显示。
   * 在关卡Blueprint中，同样订阅敌人的`OnDeath`事件，并在所有敌人死亡后触发门的打开事件。

4. **代码优化和性能提升**：
   * 通过使用观察者模式，可以避免在每帧（Tick）中不断检查敌人数量的变化，从而节省资源，提升性能。

5. **总结与建议**：
   * 观察者模式使得游戏中的对象之间更独立，不会相互影响，从而更容易维护和更新。
   * 这种模式还减少了意外副作用的风险，因为发布者和订阅者彼此独立，减少了不必要的依赖关系。

### 结论： \[#结论]

通过使用观察者模式，开发者可以显著提高Unreal Engine游戏项目中对象通信的灵活性和可维护性，尤其是在需要多个对象响应同一事件的情况下。
