---
title: UE5 C++ 指南
---

<Callout type="warn">
    本文章翻译自 [MrRobinOfficial's Guide-UnrealEngine](https://github.com/MrRobinOfficial/Guide-UnrealEngine)，初版为机器翻译，目前正在人工校对中，持续更新......
</Callout>

**你对使用 C++在 Unreal Engine 中创建游戏感兴趣吗？**

*在这个仓库中，我们将指导你开始使用 Unreal Engine 和 C++的基础知识。我们将涵盖 C++编程的基础，例如数据类型和指针，并展示如何在 Unreal Engine 的游戏开发中使用这些概念。我们还将向你介绍 Unreal Engine 模块系统，这是将你的游戏代码组织成更小、更易于管理部分的重要方面。*

<Callout type="warn">
  如果你想在 Unreal Engine 中使用其他语言，比如 C#，那么强烈推荐你查看 [Oscar Olsson](https://github.com/UnrealSharp/UnrealSharp) 的这个仓库。
</Callout>

<Callout>
  这个仓库是和 ChatGPT 一起创建的，用于协助写作和构思每一句话。虽然它提供了有价值的信息，但可能并不完全准确。如果你发现任何错误或虚假陈述，请随时创建一个新问题来报告它们，以便进一步改进和澄清。你也可以发送一个新的 pull request 来对代码库进行正确的修改。**我们非常感谢你的贡献和反馈！**
</Callout>

<Callout>
  示例和文档旨在适用于 UE 5.0 版本及更高版本。部分代码可能在旧版本上无法工作！
</Callout>

<Callout type="warn">
  如果你想查看最新的更改，可以检出 dev 分支。但是要注意实验性更改和进行中文字样。
</Callout>

## 👑 快捷指南

![jbtronics - CheatSheet Poster](/static-img/CheatSheet_Poster-1.png)[jbtronics - 技巧海报](https://github.com/jbtronics/UE4-CheatSheet/blob/master/CheatSheet_Poster.pdf)

![Winslow - Unreal Engine 5 Blueprint CheatSheet Dark Theme](/static-img/unreal-engine-5-blueprint-cheat-sheet-dark-theme-1.png)[Winslow - Unreal Engine 5 蓝图技巧海报 暗色主题](https://uecasts.com/resources/unreal-engine-5-blueprint-cheat-sheet-dark-theme?utm_source=epicgames&utm_campaign=cheat_sheet_ue5&utm_content=blueprint_dark)

![Winslow - Unreal Engine 5 C++ CheatSheet Dark Theme](/static-img/unreal-engine-5-c-plus-plus-cheat-sheet-dark-theme-1.png)[Winslow - Unreal Engine 5 C++ 技巧海报 暗色主题](https://uecasts.com/resources/unreal-engine-5-c-plus-plus-cheat-sheet-dark-theme?utm_source=epicgames&utm_campaign=cheat_sheet_ue5&utm_content=c_plus_plus_dark)

![Winslow - Unreal Engine 5 Editor CheatSheet Dark Theme](/static-img/unreal-engine-5-editor-cheat-sheet-dark-theme-1.png)[Winslow - Unreal Engine 5 编辑器暗黑主题作弊表](https://uecasts.com/resources/unreal-engine-5-editor-hotkeys-cheat-sheet-dark-theme?utm_source=epicgames&utm_campaign=cheat_sheet_ue5&utm_content=hotkeys_dark)

![VictoriaLyons - ProfilingCheatSheet](/static-img/ProfilingCheatSheet-1.png)[VictoriaLyons - 性能分析作弊表](https://www.reddit.com/r/unrealengine/comments/gqi2xu/quick_performance_cheat_sheet/)

## 🎩 插件

这些年，我发现了一些很棒且实用的插件，用于扩展和提高我的生产力。

我推荐最多的插件有：Advanced Renamer、Game Input、Common Maps、Quick Actions、ActorLocker、FlatNodes、CrystalNodes、ALS 和 Audio Meters。

这是我到目前为止发现的插件完整列表：

### 市场插件

-   [成就系统](https://www.unrealengine.com/marketplace/en-US/product/achievement-system-blueprint-compatible) (轻松定义和管理任何 UE4 项目中的成就)。
-   [动画](https://www.unrealengine.com/marketplace/en-US/product/animate-curve-driven-animations) (使用矢量曲线为任何事物制作动画)。
-   [附件同步](https://www.unrealengine.com/marketplace/en-US/product/attachment-sync) (为任何武器添加附件功能)。
-   [音频计量精简版](https://www.unrealengine.com/marketplace/en-US/product/audio-metering-lite) (让您分析和计量子混音)。
-   [自动调整注释大小](https://www.unrealengine.com/marketplace/en-US/product/auto-size-comments) (使注释框自动调整大小以适应内部的节点)。
-   [蓝图化开发者设置](https://www.unrealengine.com/marketplace/en-US/product/blueprintable-developer-settings) (通过蓝图和编辑器访问和操作配置文件，就像 `UDeveloperSettings` 一样)。
-   [常用地图](https://www.unrealengine.com/marketplace/en-US/product/common-maps) (通过将您在项目中频繁使用的地图存储在列表中，让您能够快速切换)。
-   [自定义详细信息面板](https://www.unrealengine.com/marketplace/en-US/product/custom-details-sections) (通过将您的变量分组到自定义部分来组织详细信息面板)。
-   [DzX 径向菜单](https://www.unrealengine.com/marketplace/en-US/product/dzx-radial-menu-umg/questions) (径向菜单插件为饼图状的小部件设计提供了完全的自由)。
-   [增强输入序列](https://www.unrealengine.com/marketplace/en-US/product/enhanced-input-sequence) (允许您处理输入动作及其序列)。
-   [扩展调试库](https://www.unrealengine.com/marketplace/en-US/product/extended-debug-library) (扩展了一些原生调试功能，暴露了更多功能)。
-   [文件系统库](https://www.unrealengine.com/marketplace/en-US/product/file-system-library) (轻松地打开、保存、复制、移动和删除文件及目录)。
-   [游戏流程](https://www.unrealengine.com/marketplace/en-US/product/game-flow) (允许用户创建状态机并为各种原因进行配置)。
-   [渐变生成器](https://www.unrealengine.com/marketplace/en-US/product/gradient-generator) (帮助您创建复杂的渐变)。
-   [实时蓝图调试器](https://www.unrealengine.com/marketplace/en-US/product/live-blueprint-debugger) (将蓝图调试器的变量窗口直接集成到任何选定的、蓝图类实例的 Actor 的关卡编辑器详细信息面板中)。
-   [大纲视图快捷键](https://www.unrealengine.com/marketplace/en-US/product/outliner-shortcuts) (允许将快捷键绑定到一些基本的世界大纲视图功能)。
-   [项目声学](https://www.unrealengine.com/marketplace/en-US/product/project-acoustics-for-unreal-audio) (用于为您的 3D 环境添加精确声学的音频波声学引擎)。
-   [项目清理器](https://www.unrealengine.com/marketplace/en-US/product/projectcleaner) (删除项目中未使用的资源和空文件夹)。
-   [任务编辑器插件](https://www.unrealengine.com/marketplace/en-US/product/quest-editor-plugin) (管理和创建 NPC 的任务和对话，具有非常动态和可自定义的功能)。
-   [快速操作](https://www.unrealengine.com/marketplace/en-US/product/quick-actions) (快速在 Unreal 中找到任何内容)。
-   [蓝图中的正则表达式](https://www.unrealengine.com/marketplace/en-US/product/regex-in-blueprints) (为蓝图提供正则表达式功能)。
-   [重启虚幻编辑器](https://www.unrealengine.com/marketplace/en-US/product/restart-editor-01) (一键或通过快捷键重启 Unreal 编辑器的实用工具)。
-   [屏幕淡入淡出库](https://www.unrealengine.com/marketplace/en-US/product/screen-fade-library) (一个可以在蓝图和 C++ 中轻松实现屏幕淡入淡出的插件)。
-   [SweejTech 音频检查器](https://www.unrealengine.com/marketplace/en-US/product/sweejtech-audio-inspector) (让您在一个紧凑的编辑器选项卡窗口中看到游戏中所有活动声音的详细、有用的信息)。
-   [时钟](https://www.unrealengine.com/marketplace/en-US/product/time-clock) (轻松追踪您在项目中的工作时间，并通过闹钟管理您的时间)。
-   [通用相机](https://www.unrealengine.com/marketplace/en-US/product/universal-camera) (为您游戏提供的一款灵活的相机)。

### GitHub 插件

-   [ActorLocker](https://github.com/Gradess2019/ActorLocker) (在编辑关卡时锁定 Actor 的能力)。
-   [高级移动系统重构版](https://github.com/Sixze/ALS-Refactored) (C++ 版本)。
-   [Agora 静态网格缩略图渲染器](https://github.com/ryanjon2040/AgoraStaticMeshThumbnailRenderer) (在内容浏览器中提供有关静态网格的一些信息)。
-   [别名器](https://github.com/AyeTSG/Aliaser) (允许在内容浏览器中显示别名)。
-   [ALS-Refactored XT](https://github.com/Voidware-Prohibited/ALSXT) (通过扩展的角色状态、改进的脚印系统、滑铲、攀爬和跑墙功能来扩展 ALS Refactored)。
-   [异步加载屏幕](https://github.com/truong-bui/AsyncLoadingScreen) (添加自定义加载屏幕的能力)。
-   [音频分析工具](https://github.com/gtreshchev/AudioAnalysisTools) (提供多种用于分析音频数据的函数。与运行时音频导入器插件协同工作)。
-   [虚幻引擎 5.1 音频计量](https://michaelgarydean.itch.io/audio-metering-editor-utility-widget) (监控您的音频电平的能力)。
-   [批量重命名工具](https://github.com/FrozenStormInteractive/Unreal-Batch-Rename-Tool) (使用一套命名规则快速重命名多个资源)。
-   [BlueprintUE C++](https://github.com/blueprintue/blueprintue-cpp-plugin) (允许您将您的蓝图发送到与您的帐户关联的 [](https://blueprintUE.com))。
-   [BUI 作弊管理器](https://github.com/benui-dev/UE-BUICheatManager/) (作弊管理器，提供定义作弊快捷方式的方法)。
-   [循环依赖检测器](https://github.com/bstt/CircularDependenciesDetector/)。
-   [CrystalNodes](https://github.com/SkylakeOfficial/CrystalNodes) (美化虚幻编辑器图节点)。
-   [CsToCpp](https://github.com/CSharpForUnrealEngine5/CsToCpp) (C# 到 UE C++ 编译器)。
-   [自定义形状按钮](https://github.com/JanSeliv/CustomShapeButton) (允许在 UE5.3 中制作任何形状的按钮)。
-   [Elementus 库存系统](https://github.com/lucoiso/UEElementusInventory) (数据驱动的库存与物品系统)。
-   [ExtendedUnreal](https://github.com/BenVlodgi/UE-ExtendedUnreal) (向蓝图公开有用的函数)。
-   [平铺节点](https://github.com/brumenn/FlatNodes) (虚幻引擎图节点的一种极简风格)。
-   [流程图](https://github.com/MothCocoon/FlowGraph) (用于设计游戏流程的、与设计无关的节点系统)。
-   [函数选择器](https://github.com/JanSeliv/FunctionPicker) (允许在 UE5.3 的属性中直接从任何蓝图中选择一个函数)。
-   [快捷栏和库存系统](https://github.com/finalstack/InventorySystem) (易于使用的快捷栏和库存系统)。
-   [MD 元数据编辑器](https://github.com/DoubleDeez/MDMetaDataEditor) (编辑蓝图属性、函数以及函数和事件参数的元数据的能力)。
-   [整洁元数据](https://github.com/pramberg/NeatMetadata) (允许在蓝图中使用通常仅在 C++ 中可用的各种元数据)。
-   [对象池](https://github.com/dslabkowski/ObjectPool/) (通过从固定池中重用对象而不是单独分配和释放它们来提高性能和内存使用)。
-   [PB 角色移动](https://github.com/ProjectBorealis/PBCharacterMovement) (用于 UE 的 HL2 风格、经典 FPS 移动，使用 C++ 编写)。
-   [池管理器](https://github.com/JanSeliv/PoolManager) (帮助在 UE5.3 中重用对象)。
-   [刷新所有节点](https://github.com/nachomonkey/RefreshAllNodes) (刷新单个蓝图实例中所有节点的能力。当蓝图版本尚未更新为其 C++ 对应版本时很有帮助)。
-   [串行通信](https://github.com/videofeedback/Unreal_Engine_SerialCOM_Plugin) (串行通信端口库)。
-   [设置小部件构造器](https://github.com/JanSeliv/SettingsWidgetConstructor) (根据数据表自动生成游戏设置的 UI，用于 UE5.3)。
-   [子系统浏览器插件](https://github.com/aquanox/SubsystemBrowserPlugin/) (添加一个子系统浏览器面板，用于浏览正在运行的子系统并编辑其属性)。
-   [标签页恢复](https://github.com/Theliraan/TabRestore) (恢复关闭的标签页)。
-   [用于 UE4/UMG 的 UI 补间库](https://github.com/benui-dev/UE-BUITween)。
-   [虚幻蓝图 CSV 解析](https://github.com/IncantaGames/unreal-bp-csv-parsing)。
-   [UnrealImGui](https://github.com/benui-dev/UnrealImGui) (将 [Dear ImGui](https://github.com/ocornut/imgui) 框架集成到虚幻引擎中)。
-   [VoxelCore](https://github.com/VoxelPlugin/VoxelCore) (在 UE 中使用体素)。

### Epic Games 插件

-   [高级重命名器](https://dev.epicgames.com/documentation/en-us/unreal-engine) 由 Epic Games 制作。
-   [游戏输入](https://dev.epicgames.com/documentation/en-us/unreal-engine) 由 Epic Games 制作。
-   [混沌车辆](https://dev.epicgames.com/documentation/en-us/unreal-engine/vehicles-in-unreal-engine) 由 Epic Games 制作 (车辆系统)。
-   [通用 UI](https://dev.epicgames.com/documentation/en-us/unreal-engine/common-ui-plugin-for-advanced-user-interfaces-in-unreal-engine) 由 Epic Games 制作。
-   [增强输入](https://dev.epicgames.com/documentation/en-us/unreal-engine/enhanced-input-in-unreal-engine) 由 Epic Games 制作。
-   [太阳位置计算器](hhttps://dev.epicgames.com/documentation/en-us/unreal-engine/geographically-accurate-sun-positioning-tool-in-unreal-engine) 由 Epic Games 制作 (实时天空)。

### MrRobinOfficial 的插件

-   [通用时间](https://github.com/MrRobinOfficial/Unreal-CommonTime) (提供用于编辑 DateTime 和 Timespan 值的编辑器视图)。
-   [通用车辆](https://github.com/MrRobinOfficial/Unreal-CommonVehicle) (扩展混沌车辆系统)。
-   [Ini 解析器](https://github.com/MrRobinOfficial/Unreal-IniParser) (导入/导出 .ini 文件)。

我正在计划制作更多插件，您可以在 [Github](https://github.com/MrRobinOfficial) 上找到我。

## 📛 控制台命令

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

*   `stat fps` : 显示 FPS.
*   `stat unit` : 显示帧时间。
*   `stat game` : 显示各种游戏循环的耗时概况。
*   `dumpticks` : 显示当前场景中正在更新的角色列表。
*   `slomo` : 加快或减慢游戏时间。
*   `obj list` : 显示当前加载对象列表。
*   `obj list class=BP_PlayerCharacter_C` : 与 `obj list` 相同，但带有过滤功能。
*   `obj gc` : 收集所有带有 GC（垃圾收集器）的对象。
*   `au.Debug.AudioSoloSoundWave` : 需要一个声音波名称作为额外输入，并切换该声音波是否为独奏（唯一可听的声音）。

这里还有一个 Pongrit 制作的网站，展示了虚幻引擎的所有控制台命令。

## 📌 快捷键

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

要更改任何快捷键，您可以通过编辑器首选项访问键盘快捷键设置，然后在常规选项中选择键盘快捷键。

* * *

基本

*   Ctrl + C : 复制
*   Ctrl + X : 剪切
*   Ctrl + V : 粘贴
*   Del - 删除
*   Ctrl + Y : 撤销
*   Ctrl + Z : 重做
*   Ctrl + A : 全选
*   Esc : 清除选择
*   Up/Down/Left/Right Arrow Keys : 移动选择
*   Ctrl + Spacebar : 打开内容浏览器
*   Ctrl + B : 在内容浏览器中查找
*   Ctrl + Tab : 浏览标签页
*   Ctrl + O : 打开关卡
*   Ctrl + P : 资产选择器
*   Alt + P 或 Alt + S : 播放/模拟
*   P : 显示导航网格
*   Mouse Wheel Up/Down : 放大

* * *

大纲

*   Ctrl + G 或 Shift + G : 组合/取消组合
*   Right-Click 在组合上：固定/取消固定

* * *

蓝图编辑器

*   Ctrl + S : 保存蓝图
*   Ctrl + F : 在蓝图中查找
*   Ctrl + Shift + F : 在所有蓝图中查找

* * *

关卡编辑

*   Ctrl + S : 全部保存
*   End : 对齐到地面
*   Alt + End : 对齐枢轴到地面
*   Shift + End : 将约束边界吸附到地面
*   Ctrl + End : 将原点吸附到网格
*   Alt + Transform : 复制并变换

* * *

相机/变换

*   Alt + G : 透视图
*   Alt + H : 正视图
*   Alt + J : 俯视图
*   Alt + K : 侧视图
*   F : 聚焦
*   G : 查看
*   R : 缩放
*   W : 平移
*   E : 旋转
*   空格 : 切换移动/旋转/缩放

* * *

工具

*   Ctrl + Shift + 分号 : GPU 可视化

## ⌛ 开始学习 C++

<table><tbody><tr><td>本节内容与 ChatGPT 共同编写。</td></tr></tbody></table>

强烈建议参加一个原版 C++的短期课程。这里有一个来自 [video tutorial from Mosh](https://www.youtube.com/watch?v=ZzaPdXTrSb8) 的~1 小时长的视频教程链接。

你也可以观看 [GGameDev](https://youtube.com/playlist?list=PLaaDnVlfJwc4Lncf4XTYaTRG_osOk-T0N) 关于开始学习 Unreal Engine C++的播放列表。

C++是一种静态类型、编译型、通用的编程语言，它结合了高级和低级特性。它由 [Bjarne Stroustrup](https://en.wikipedia.org/wiki/Bjarne_Stroustrup) 于 1979 年在贝尔实验室开发，作为 [C language](https://en.wikipedia.org/wiki/C_(programming_language)) 的增强版，最初名为 C with Classes，后于 1983 年更名为 [C++](https://en.wikipedia.org/wiki/C%2B%2B)。

您可以在 [C++ Language Reference from Microsoft Learn](https://learn.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=msvc-170) 上阅读更多关于 C++语言参考的内容。

使用 C++与虚幻引擎结合，可以解锁引擎的全部功能集，使开发者能够利用高级图形渲染、物理模拟、网络和人工智能功能。C++提供了控制、定制和性能优化的级别，与可视化脚本相辅相成。

在虚幻引擎中使用 C++进行开发，可以通过多线程和内存管理等技术实现更好的调试、性能分析和优化。它还促进了与第三方库的集成，扩展了开发者可用的功能范围和灵活性。

你可以在[他们的文档](https://docs.unrealengine.com/5.2/en-US/unreal-engine-programming-and-scripting/)中了解更多信息。

要在虚幻引擎中有效使用 C++，掌握编程原理并理解虚幻引擎的架构和规范至关重要。利用虚幻引擎文档、社区论坛和其他开发者的协作，有助于获取知识和最佳实践。

*通过结合 C++和虚幻引擎的力量，开发者可以创造沉浸式体验，并充分发挥引擎的全部潜力。*

### 🌈 集成开发环境

<table><tbody><tr><td>这一部分是与 ChatGPT 共同编写的。</td></tr></tbody></table>

集成开发环境（IDE）是一种提供全面编写、调试和管理代码工具的软件应用程序。IDE 为软件开发提供了一个简化和功能丰富的环境，使开发者能够更高效地处理他们的项目。

在 Unreal Engine 和 C++开发中常用的 IDE 包括：

*   [Visual Studio](https://visualstudio.microsoft.com/)：用于 Unreal Engine 开发的 Visual Studio IDE。它提供了一套强大的 C++工具，并与 Unreal Engine 无缝集成，提供了一个稳固的开发环境。 `免费` .

*   [Visual Studio Code (VSCode)](https://code.visualstudio.com/): Visual Studio Code 是一款轻量级、跨平台的代码编辑器，拥有丰富的扩展生态系统，包括用于 Unreal Engine 开发的扩展。 `免费` .

*   [Rider](https://www.jetbrains.com/rider/): Rider 是由 JetBrains 开发的流行 IDE，专为游戏开发设计，并提供了与 Unreal Engine 项目的良好集成。 `非商用免费` .


### ⛏️ 帮助你旅程的工具

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

这里有一些可以集成到你的 IDE 中，以提升性能、调试或编写良好代码实践的工具。

*   [Visual Assist](https://www.wholetomato.com/)：一款用于重构、阅读、编写、导航和生成 C/C++/C#代码的生产力工具。 `收费` 在 `VS` 上。

*   [UnrealMacroGenerator](https://marketplace.visualstudio.com/items?itemName=Naotsun.Naotsun-UE-UMG)：提供宏编辑器，用于 Unreal Engine 的 Unreal C++。您可以创建宏并编辑已编写的宏。 `免费` 在 `VS` 上。


### 🟢 使用 Unreal Engine 进行 C++开发的优势

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

*   高性能：C++允许你编写可以直接在 CPU 和 GPU 上运行的代码，使你的游戏或应用程序能够实现非常高的性能水平。

*   与现有代码库的集成：如果你希望将现有的 C++代码集成到你的 Unreal Engine 项目中，使用 C++可以让你更轻松地实现这一点。

*   低级功能的访问：与其他编程语言相比，C++为你提供了更底层的功能访问，这在游戏开发中特别有用，因为对内存、数据结构和算法进行细粒度控制往往是必要的。

*   垃圾回收和内存管理：虽然 C++要求手动内存管理，但 Unreal Engine 提供了一个[垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))，可以高效地从内存中清除 `UObject` 类。通过手动内存处理的控制，你可以精确地指定何时分配和释放内存。


### 🔴 使用 C++与虚幻引擎的缺点

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

*   更容易出错：C++是一种强类型语言，需要精确使用分号、括号和准确的语法来确保成功编译。纠正这些问题可能耗时。相反，蓝图基于节点的图形系统不需要“正确”的语法，提供了一个更“宽容”的环境。

*   绑定于虚幻的 API：随着虚幻引擎的发展，Epic Games 可能会修改源代码，导致某些函数和成员变得过时/弃用。因此，虚幻可能会建议根据最新的 API 变化更新代码库。若不这样做，将来可能会导致编译错误。

*   更新你的代码库：在使用 C++和虚幻引擎时，你的 C++代码会被编译成一个.DLL（在 Windows 操作系统）文件，虚幻引擎可以读取并在蓝图图中使用这些文件。然而，这需要虚幻引擎重新加载才能包含你的代码更改。Epic Games 推出了热重载功能，允许在不重启编辑器的情况下重新加载代码，从而简化开发流程。尽管热重载功能有时能正常工作一段时间，但它并不稳定，经常导致蓝图损坏或其他问题。

*   需要更多存储空间：在使用虚幻引擎中的 C++时，通常需要使用“调试用编辑器符号”，这会占用大约 60 GB 的存储空间。同样地，如果你选择从其源代码构建虚幻引擎（在他们的 GitHub 页面上），你将需要大约 200 GB 的存储空间。


## 🌍 C++和编程世界的总结

如果你希望扩展你对 C++和一般编程原则及理念的了解，我强烈推荐你阅读这一部分[section](https://github.com/MrRobinOfficial/Guide-UnrealEngine/blob/dev/README_CPP.md)。

## 🚧 蓝图与 C++

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

[![Watch the video by Alex Forsythe](https://img.youtube.com/vi/VMZftEVDuCE/maxresdefault.jpg)](https://youtu.be/VMZftEVDuCE)

当你预期需要与其他 C++代码交互，或需要精细控制低级优化和内存管理时，请选择 C++。C++非常适合需要直接访问引擎内部结构和高效执行类的场景。

当你希望受益于蓝图提供的可视化脚本能力和快速原型设计，同时仍保留未来整合 C++代码的选项时，可将蓝图用作继承类。这种方式允许灵活处理，既能利用蓝图的强大功能，又能在需要时通过 C++扩展功能。

## 🎪 架构

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

刚开始接触虚幻引擎及其工作流程时，对于初学者来说可能会感到令人望而生畏，因为其中包含许多具有不同目的的组件。然而，我认为学习虚幻引擎的架构也有助于提升你的技能和经验。

你不仅能够了解虚幻引擎，还能了解游戏引擎在底层是如何工作的。与 Unity（一个闭源引擎）相比，其“架构”的解释空间相当大。

虚幻引擎也是为创建 FPS 多人游戏而构建的。你可以找到一些专门为 FPS 游戏设计的类，例如 `AGameState` 和 `APlayerState` 类。这些类用于跟踪比赛积分和生命值。

然而，你仍然可以使用虚幻引擎的架构来开发不同类型的游戏。虚幻引擎既适用于多人游戏，也适用于单人游戏。

虚幻引擎包含太多类，逐一解释每个类将需要非常长的时间。不过，有一些重要的类我必须提一下：


*   UClass 继承 `UStruct`

    *   一个对象类。
*   UObject 继承自 `UObjectBaseUtility`

    *   所有 UE 对象的基类。
    *   对象的类型由其 `UClass` 定义。
    *   这提供了创建和使用对象的支持函数，以及子类中应重写的虚拟函数。
*   AActor 继承 `UObject`

    *   Actor 是可放置或生成在关卡中的对象的基类。
    *   Actor 可包含一组 ActorComponents，这些组件可用于控制对象的移动方式、渲染方式等。Actor 的另一个主要功能是在游戏过程中通过网络复制属性和函数调用。
    *   `AActor` 本身没有变换（即在世界中的位置），它依赖于根组件的变换。
    *   常用功能：
        *   `void PreInitializeComponents()` - 在 actor 的组件调用 InitializeComponent 之前被调用。这仅在游戏运行期间和某些编辑器预览窗口中调用。
        *   `void InitializeComponent()` - 只有当组件具有 bWantsInitializeComponentSet 时才会被调用。这每个游戏会话只发生一次。
        *   `void PostInitializeComponents()` - 在角色的组件初始化后调用，仅在游戏进行中和某些编辑器预览期间。
        *   `void BeginPlay()` - 在关卡开始计时时调用，仅在真正的游戏进行中。这通常发生在 PostInitializeComponents 之后，但对于网络或子角色可能会延迟。
        *   `void Tick(float DeltaSeconds)` - 在此角色每帧调用的函数。
        *   `void EndPlay(const EEndPlayReason::Type EndPlayReason)` - 可重写的函数，在角色从关卡中移除时调用。
        *   `void SetLifeSpan(float InLifespan)` - 设置角色的生命周期。
        *   `void Destroy(bool bNetForce, bool bShouldModifyLevel)` - 销毁角色。
        *   `void SetActorTickEnabled(bool bEnabled)` - 设置此角色的 tick 函数为启用或禁用。
        *   `void SetActorTickInterval(float TickInterval)` - 设置此角色的主要 tick 函数的 tick 间隔。
*   APawn 继承 `AActor`

    *   棋子是所有可以被玩家或 AI 控制的角色的基类。它们是关卡中玩家和生物的物理表现。
    *   `APawn` 提供了基本的控制机制和输入处理支持，以及碰撞检测和物理模拟。
    *   常用功能：
        *   `void BeginPlay()` - 当关卡开始计时调用，仅在真实游戏中调用。
        *   `void Tick(float DeltaSeconds)` - 更新函数，在 Actor 的每一帧调用。
        *   `void EndPlay(const EEndPlayReason::Type EndPlayReason)` - 每当 Actor 从关卡中移除时
        *   `void SetLifeSpan(float InLifespan)` - 设置 Actor 的生存时间。
        *   `void Destroy(bool bNetForce, bool bShouldModifyLevel)` - 销毁角色。
*   AHUD 继承 `AActor`

    *   HUD 的基类。HUD 向玩家显示重要信息，例如生命值和弹药量，并提供游戏事件（如伤害或拾取能力提升）的视觉反馈。
    *   它有一个画布和一个调试画布，可以在上面绘制基本图形。它还包含一个简单的碰撞框列表，可用于简单的物品点击检测。它还包含一种渲染调试文本的方法。提供了一些用于渲染文本、纹理、矩形和材质的简单方法，这些方法也可以从蓝图访问。
*   ACharacter 继承 `APawn`

    *   角色是具有网格、碰撞和内置移动逻辑的棋子（ `APawn` ）。
    *   它们负责玩家或 AI 与世界之间的所有物理交互，并实现基本网络和输入模型。它们是为垂直方向的玩家表示设计的，可以使用 `UCharacterMovementComponent` 在世界中行走、跳跃、飞行和游泳。
    *   `ACharacter` 可以作为游戏中的玩家角色、敌人和其他类型角色的基础类。
*   AController 继承 `AActor`

    *   控制器是非物理的参与者，可以拥有一个 Pawn 来控制其动作。PlayerControllers 被人类玩家用来控制 Pawn，而 AIControllers 为它们控制的 Pawn 实现人工智能。控制器通过它们的 `Possess()` 方法来控制一个 Pawn，并通过调用 `UnPossess()` 来释放对 Pawn 的控制。
    *   控制器会接收到它们所控制的 Pawn 发生的许多事件的通知。这给控制器提供了机会来响应这些事件，拦截事件并覆盖 Pawn 的默认行为。
    *   ControlRotation（通过 `GetControlRotation()` 访问），决定了受控 Pawn 的观看/瞄准方向，并受来自鼠标或游戏手柄等输入的影响。
*   UActorComponent 继承 `UObject`

    *   ActorComponent 是定义可添加到不同类型 Actor 上的可重用行为的基类。
    *   具有变换的 ActorComponent 称为 SceneComponent（ `USceneComponent` ），而可渲染的称为 PrimitiveComponent（ `UPrimitiveComponent` ）。
    *   `UActorComponent` 不会出现在世界中。
    *   常用功能：
        *   `void BeginPlay()` - 开始组件的播放。
        *   `void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)` - 在 ActorComponent 上每帧调用的函数。
        *   `void EndPlay(const EEndPlayReason::Type EndPlayReason)` - 结束组件的游戏播放。
*   UMovementComponent 继承 `UActorComponent`

    *   MovementComponent 是一个抽象组件类，定义了每帧移动一个 PrimitiveComponent（我们的 UpdatedComponent）的功能。
*   USceneComponent 继承 `UActorComponent`

    *   一个 SceneComponent 拥有变换，支持附着，但没有渲染或碰撞功能。
    *   可用作层级中的"虚拟"组件，以平衡其他组件。
    *   被需要知道自己在世界中的位置以运行逻辑的组件使用，即 `UAudioComponnent` ， `UCameraComponent` 。
*   UPrimitiveComponent 继承 `USceneComponent`

    *   PrimitiveComponents 是包含或生成某种几何形状的 SceneComponents，通常用于渲染或作为碰撞数据使用。
    *   几何学有多种子类，但最常见的是 ShapeComponents（Capsule、Sphere、Box）、StaticMeshComponent 和 SkeletalMeshComponent。
    *   ShapeComponents 生成用于碰撞检测但不会渲染的几何体，而 StaticMeshComponents 和 SkeletalMeshComponents 包含预构建的几何体，这些几何体既会被渲染，也可以用于碰撞检测。
*   USubsystem 继承 `UObject`

    *   子系统是自动实例化的类，它们共享某些引擎结构的生命周期。
    *   子系统负责初始化、更新和关闭其关联的服务，并且可以根据需要用于自定义或扩展引擎功能。
    *   6 种类型的子系统
        *   UEngineSubsystem 共享引擎的生命周期。
        *   UEditorSubsystem 共享编辑器的生命周期。
        *   UGameInstanceSubsystem 共享游戏实例的生命周期。
        *   ULocalPlayerSubsystem - 共享本地玩家的生命周期。
        *   UWorldSubsystem - 共享 `UWorld` 的生命周期。
        *   UTickableWorldSubsystem - 共享 `UWorld` 的生命周期，并随其一起进行更新。
*   UBlueprintFunctionLibrary 继承 `UObject`

    *   这个类是任何暴露给蓝图的功能库的基类。
    *   子类中的方法应该是静态的，这个基类不应添加任何方法。
*   UEngine、UEditorEngine 和 UGameEngine 继承 `UObject`

    *   所有 Engine 类的抽象基类，负责管理对编辑器或游戏系统至关重要的系统。还定义了某些引擎系统的默认类。
    *   `UGameEngine` 管理使游戏运行的核心系统。
    *   `UEditorEngine` 驱动编辑器。与 `UGameEngine` 分开，因为它可能具有与游戏实例本身所需的期望功能差异很大的功能。
*   UGameViewportClient 继承 `UScriptViewportClient`

    *   一个游戏视口（FViewport）是平台特定渲染、音频和输入子系统的抽象高级接口。
    *   每个游戏实例都会创建一个 GameViewportClient。
*   ULocalPlayer 继承 `UObject`

    *   当前客户端/监听服务器上活跃的每个玩家都有一个 LocalPlayer。
    *   它在所有地图上都保持活跃状态，在分屏/合作模式下可能会有多个实例生成。在专用服务器上不会生成任何实例。
    *   LocalPlayer 通常与其他类（如 `APlayerController` ）一起使用，以管理本地玩家与游戏的交互。
    *   常见功能：
        *   `TSubsystemClass* GetSubsystem() const` - 获取指定类型的子系统
*   UWorld 继承 `UObject`

    *   世界是代表地图或沙盒的顶层对象，在其中 Actor 和 Component 将存在并被渲染。
    *   一个世界可以是一个单一的持久化关卡，带有可选的流式关卡列表，这些关卡通过体积和蓝图函数加载和卸载，或者它可以是一个由世界组合组织起来的关卡集合。
    *   在独立游戏中，通常只有一个世界存在，除了无缝区域转换期间，当目的地和当前世界都存在时。在编辑器中，存在许多世界：正在编辑的关卡、每个 PIE 实例、每个具有交互式渲染视口的编辑器工具，等等。
    *   常用功能：
        *   `void SpawnActor()` 或 `void SpawnActorDeferred()` - 从它的类中生成一个角色。延迟方法将允许你在它生成到世界之前设置角色的属性。
*   [ULevel](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Engine/ULevel)

    *   一个关卡是一组角色的集合（灯光、体积、网格实例等）。多个关卡可以被加载和卸载到世界中，以创建流式体验。
*   UGameInstance 继承 `UObject`

    *   运行游戏实例的高级管理对象。在游戏创建时生成，直到游戏实例关闭前不会销毁。作为独立游戏运行时，将有一个此类实例。在 PIE（编辑器内播放）模式下，每个 PIE 实例将生成一个此类实例。
    *   游戏实例可用于跨关卡管理持久数据及游戏状态，同时也可执行全局游戏操作，如处理网络、输入及其他系统级任务。
*   AGameMode 继承 `AGameModeBase`

    *   GameMode 是 GameModeBase 的一个子类，其行为类似于基于多人匹配的游戏。
    *   它具有选择出生点和匹配状态的默认行为。或者你可以定义特定游戏模式的规则和机制，例如死亡竞赛或夺旗。
    *   如果你想要一个更简单的基类，可以直接继承 GameModeBase。
    *   游戏中的每个关卡（ `ULevel` ）可以拥有自己的 `AGameMode` ，从而允许在不同关卡中使用不同的游戏模式。
*   AGameState 继承 `AGameStateBase`

    *   GameState 是一个继承自 GameStateBase 的子类，其行为类似于多人基于匹配的游戏。它与 GameMode 中的功能相关联。
    *   `AGameState` 也可以用于在网络游戏中同步游戏状态，确保所有玩家都能准确查看游戏世界。
*   APlayerState 继承 `AInfo`

    *   每个服务器上的玩家（或在独立游戏中）都会创建一个 PlayerState。
    *   PlayerStates 会复制到所有客户端，并包含关于玩家的网络游戏相关信息，例如玩家名、得分等。
*   UWidget 继承 `UVisual`

    *   这是所有暴露给 UObjects 的包装 Slate 控制的基类。
*   用户小部件继承 `UWidget`

    *   一个通过 WidgetBlueprint 实现 UI 扩展性的小部件。
    *   `UUserWidget` 提供了一个灵活的框架，用于创建按钮、文本字段和图像等 UI 元素，并且可以自定义以实现复杂的 UI 行为，如动画、过渡和数据绑定。
*   资源管理器小部件继承 `UObject`

    *   一个单例 `UObject` 负责加载和卸载 PrimaryAssets，并维护特定游戏的资源引用。游戏应该重写这个类并更改类引用
*   UDataAsset 继承 `UObject`

    *   创建一个简单的资源，用于在类实例中存储与特定系统相关的数据。
    *   可以使用继承自这个类的任何原生类在内容浏览器中创建资源。
    *   如果你需要数据继承或复杂的层次结构，应该创建数据仅蓝图类。
*   UPrimaryDataAsset 继承 `UDataAsset`

    *   一个实现了 `GetPrimaryAssetId()` 并具有资源包支持的数据资产，这允许它从 AssetManager 手动加载/卸载（ `UAssetManager` ）。
    *   表示引擎中的主要数据资产。主要数据资产是在 Unreal 编辑器中创建的游戏内容的一部分，例如网格、纹理、声音或关卡。 `UPrimaryDataAsset` 提供了一个基础类，用于创建自定义数据资产，这些资产可以在运行时被游戏加载和使用。
    *   `UPrimaryDataAsset` 可用于管理和组织游戏内容，并可根据需求定制，以提供数据验证和元数据管理等附加功能。
*   USoundBase 继承 `UObject`

    *   可播放声音对象的基类
    *   `USoundBase` 可用于在游戏世界中播放音效、音乐和其他音频。
    *   `USoundBase` 提供了多种控制音频播放的功能，包括音量、音调和空间化效果，如 3D 声音和混响。
*   UMaterial 继承 `UMaterialInterface`

    *   材质是一种可以应用于网格以控制场景视觉外观的资源。
    *   当场景中的光线照射到表面时，材质的着色模型用于计算光线如何与表面相互作用。
*   UMaterialInstance 继承 `UMaterialInterface`

    *   材质资源的实例。这样，你可以创建一个层次材质系统。
*   UMaterialInstanceDynamic 继承 `UMaterialInstance`

    *   动态生成的实例材质。
*   UTexture 继承 `UObject`

    *   表示可以在引擎中用于各种目的（如材质或用户界面元素）的图像或纹理。
*   UTexture2D 继承 `UTexture`

    *   表示可以在引擎中用于各种目的（如材质或用户界面元素）的 2D 图像或纹理。

你可以在[他们的文档](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/)中了解更多关于虚幻架构的信息。

关于虚幻架构的更多信息，我强烈推荐你可以观看关于[虚幻引擎架构的视频](https://www.youtube.com/watch?v=QcXHEsR0xHI)。

你也可以观看 [Kekdot 关于虚幻引擎多人框架的视频讨论](https://www.youtube.com/watch?v=Hsr6mbNKBLU)。

<Callout> 这个架构基于多人游戏设置。但是，如果你在制作单人游戏，那么你可以忽略一些类。主要是 `APlayerState` 和 `AGameState` （以及它们的基类）。 </Callout>

你也可以观看 Alex Forsythe 的[《虚幻引擎游戏框架：从 int main()到 BeginPlay》](https://www.youtube.com/watch?v=IaU2Hue-ApI)，他讲述了虚幻引擎如何从源代码启动你的游戏/编辑器，以及这些类如何相互协作。

## ⚓ 指南

你可以找到更多关于虚幻引擎指南的信息[inside the editor](https://dev.epicgames.com/documentation/en-us/unreal-engine/recommended-asset-naming-conventions-in-unreal-engine-projects) ，包括在编辑器内部（资源创建），以及它们的编码标准。

### 🎳 命名规范

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

![Naming Conventions](/static-img/Naming_conventions.png)

有一个 GitHub 仓库，讨论了虚幻引擎的命名规范。该仓库非常详细，解释了应该如何命名你的资源以及代码。仓库名为 Michael Allar 的[《虚幻引擎风格指南》](https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine)。

虚幻引擎遵循特定的命名规范，有助于保持代码库的一致性和可读性。在使用命名规范时，所有代码和注释应使用美式英语的拼写和语法。

帕斯卡命名法是一种编程和其他语境中使用的命名规范，通过将每个单词的首字母大写并连接在一起（不使用空格）来创建复合词或短语。在虚幻引擎中，帕斯卡命名法常用于命名类、成员变量、函数和其他结构。

在虚幻引擎中，类使用帕斯卡命名法是用户定义类命名规范的一部分。当你在虚幻引擎中创建一个新类时，建议使用帕斯卡命名法为类命名。例如：

```cpp
class AMyPlayerCharacter : public ACharacter
{
    // Class definition here
};
```

同样地，在 Unreal Engine 中，帕斯卡命名法用于成员变量和函数，以保持一致性并提高代码可读性。例如：

```cpp
class AMyPlayerCharacter : public ACharacter
{
public:
    UPROPERTY()
    float MovementSpeed;

    UFUNCTION()
    void Jump();
};
```

布尔变量使用 `b` 作为前缀，后跟帕斯卡命名法的描述性名称。例如，一个控制角色是否在跑步的布尔变量可能命名为： `bIsRunning` 。

变量、方法和类名应该是：

*   清晰的
*   明确
*   描述性

名称范围越大，一个好的描述性名称就越重要。避免过度缩写。

```cpp
// what does true mean?
bool CheckTea(FTea Tea);

// name makes it clear true means tea is fresh
bool IsTeaFresh(FTea Tea);
```

#### 🎨 缩写、首字母缩略词和同义词

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

常用语言特性

-   `arg` - 参数
-   `arr` - 数组
-   `async` - 异步
-   `attr` - 属性
-   `auth` - 身份验证
-   `btn` - 按钮
-   `buff` - 缓冲区
-   `ctx` - 上下文
-   `const` - 常量
-   `db` - 数据库
-   `dest` - 目标
-   `desc` - 描述
-   `doc` 或 `docs` - 文档
-   `dir` - 方向或目录 (根据上下文)
-   `elem` - 元素
-   `err` - 错误
-   `e` 或 `evt` - 事件
-   `exe` - 执行
-   `expr` - 表达式
-   `ext` - 扩展
-   `func` - 函数
-   `fmt` - 格式
-   `gen` - 生成
-   `hex` - 十六进制
-   `impl` - 实现
-   `imp` - 导入
-   `i` 或 `idx` - 索引
-   `info` - 信息
-   `init` - 初始化
-   `it` 或 `iter` - 迭代器
-   `ident` - 标识符
-   `lang` - 语言
-   `len` - 长度
-   `lvl` - 级别
-   `lib` - 库
-   `loc` - 位置
-   `msg` - 消息
-   `num` - 数字
-   `obj` - 对象
-   `opt` - 选项
-   `out` - 输出
-   `pkg` - 包
-   `param` - 参数
-   `px` - 像素
-   `pos` - 位置
-   `prev` - 上一个
-   `priv` - 私有
-   `pub` - 公有
-   `q` - 查询
-   `rand` - 随机
-   `rng` - 范围
-   `ref` - 引用
-   `rm` 或 `rmv` - 移除
-   `req` - 请求
-   `res` - 结果或响应 (根据上下文)
-   `ret` - 返回
-   `sel` - 选择
-   `sep` - 分隔符
-   `sec` - 序列
-   `sol` - 求解器
-   `src` - 源
-   `spec` - 说明符或规范 (根据上下文)
-   `std` - 标准
-   `stdio` - 标准输入输出
-   `stmt` - 语句
-   `stat` - 统计
-   `str` - 字符串
-   `sync` - 同步
-   `tmp` - 温度
-   `temp` - 临时
-   `util` - 工具
-   `val` - 值
-   `var` - 变量
-   `ws` - 空白
-   `win` - 窗口
-   `wiz` - 向导

---

Unreal Engine 特性

-   `PC` - 表示变量是 **PlayerController**
-   `LP` - 表示变量是 **LocalPlayer**
-   `Char` - 表示变量是 **Character** (不要与 `char` 数据类型混淆)
-   `Comp` - 表示变量是一个 **组件**
-   `Ptr` - 表示变量是一个指向对象的 **指针**。
-   `Ref` - 表示变量是一个对象的 **引用**。
-   `dt` - 增量时间

---

网络

-   `OAuth` 或 Open Authentication – 一种开放标准，用于认证应用程序或网站以访问内容。
-   `TCP` 或 Transmission Control Protocol – 一种标准，用于定义系统间如何交换消息。
-   `UDP` 或 User Datagram Protocol – 一种标准，用于定义系统间如何交换消息。

---

工具/框架

-   `IDE` 或 Integrated Development Environment - 一种为程序员提供软件开发便利的软件应用程序。
-   `JSON` 或 Javascript Object Notation – 一种文件格式，使用 JavaScript[^14] 编写，广泛用于通过网络传输数据。
-   `XML` 或 Extensible Markup Language – 一种主要用于存储和传输数据的标记语言。
-   `SQL` 或 Structured Query Language – 一种用于存储、检索和修改数据的查询语言。
-   `CSV` 或 Comma-separated values - CSV 文件是一种使用逗号分隔值的分隔文本文件。

---

数学

-   `add` - 加法
-   `sub` - 减法
-   `mul` - 乘法
-   `div` - 除法
-   `abs` - 绝对值
-   `sin` - 正弦
-   `cos` - 余弦
-   `tan` - 正切
-   `rad` - 弧度
-   `r` - 半径
-   `frac` - 分数
-   `freq` - 频率
-   `long` - 经度或纵向 (根据上下文)
-   `lat` - 纬度或横向 (根据上下文)
-   `sqrt` - 平方根
-   `mod` - 取模
-   `min` - 最小值
-   `max` - 最大值
-   `lerp` - 线性插值

---

杂项

-   `API` 或 Application Programming Interface – 一种用于连接多个隔离组件的接口。
-   `SDK` 或 Software Development Kit – 一套软件，通常用于在特定平台进行开发。
-   `TDD` 或 Test-driven development - TDD 是一种软件开发生命周期，基于短开发周期的重复：将需求转化为特定的测试用例，然后修改代码以使测试通过。
-   `UUID` 或 Universally unique identifier - UUID 是一个用于在计算机系统中识别信息的 128 位数字。
-   `GUI` 或 Graphic User Interface - GUI 或图形用户界面是一种用户界面形式，允许用户通过图形界面与电子设备交互。
-   `misc` - 杂项
-   `os` - 操作系统
-   `org` - 组织
-   `pwr` - 电源
-   `pref` - 首选项
-   `repo` - 仓库

#### 前缀

| 前缀 | 类 | 子类 |
| --- | --- | --- |
| U | UObject | UActorComponent, UPrimaryDataAsset, UEngine, UGameplayStatics |
| A | AActor | APawn, ACharaacter, AController, AHUD, AGameMode |
| F | 结构 | FHitResult, FVector, FRotator, FTableRowBase |
| E | 枚举 | EEnvQueryStatus, EConstraintType, EEndPlayReason |
| I | 接口 | IInputDevice, IHapticDevice, ITargetPlatform |
| T | 模板 | TSubclassOf, TArray, TSet, TMap, TMultiMap |
| G | 全局类 | GEngine, GConfig, GWorld, GEngineLoop, GIsEditor |

<Callout> 你知道吗， `F` 前缀实际上代表 `Float` （浮点数）。但它意外地被广泛传播，并失去了原本的含义。</Callout>

### 编码规范

> 编码约定是一套针对特定编程语言的指南，推荐在该语言编写的程序的各个方面采用编程风格、实践和方法。
>
> 这些是关于软件结构质量的指南。强烈建议软件程序员遵循这些指南，以帮助提高其源代码的可读性，并使软件维护更加容易。
>
> \-- 维基百科

枚举（Enum）类是旧式命名空间枚举的替代品，适用于常规枚举和 `UENUMs` 。例如：

```cpp
// Old enum
UENUM()
namespace EThing
{
    enum Type
    {
        Thing1,
        Thing2
    };
}

// New enum
UENUM()
enum class EThing : uint8
{
    Thing1,
    Thing2
}
```

枚举作为 `UPROPERTYs` 得到支持，并取代了旧的 `TEnumAsByte<>` 解决方案。枚举属性可以是任意大小，而不仅仅是字节：

```cpp
// Old property
UPROPERTY()
TEnumAsByte<EThing::Type> MyProperty;

// New property
UPROPERTY()
EThing MyProperty;
```

## 💎 Unreal Header Tool

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

虚幻引擎头文件工具（UHT [3](#user-content-fn-2) ）是虚幻引擎中的一个代码生成和反射系统。它处理 C++头文件中的特殊宏和元标签，并生成附加代码以支持虚幻引擎的反射系统，从而实现蓝图集成、序列化、网络等功能。

布局：

```cpp
UPROPERTY([specifier1=setting1, specifier2, ...], [meta=(key1="value1", key2="value2", ...))])
UFUNCTION([specifier1=setting1, specifier2, ...], [meta=(key1="value1", key2="value2", ...))])
UCLASS([specifier1=setting1, specifier2, ...], [meta=(key1="value1", key2="value2", ...))])
USTRUCT([specifier1=setting1, specifier2, ...], [meta=(key1="value1", key2="value2", ...))])
UENUM([specifier1=setting1, specifier2, ...])
UPARAM([specifier1=setting1, specifier2, ...])
UMETA([specifier1=setting1, specifier2, ...])
```

| 宏 | 描述 | 用例 |
| --- | --- | --- |
| UPROPERTY | 指定类成员的属性，如复制、序列化、可编辑性和蓝图可见性。 | 用于定义类中变量的属性，以控制它们如何被虚幻引擎系统处理。 |
| UFUNCTION | 标识一个可以从蓝图可视化脚本或其他系统中访问和调用的 C++函数。 | 用于将 C++函数暴露给蓝图，以便在可视化脚本中轻松使用并与虚幻引擎集成。 |
| UCLASS | 定义一个 C++类，该类被暴露给虚幻引擎的反射系统，允许其在蓝图中使用以及其他引擎功能。 | 用于定义可在蓝图中使用并集成到虚幻引擎系统（如编辑器）中的类。 |
| USTRUCT | 指定一个 C++结构体，该结构体可用于虚幻引擎的反射系统，使其可在蓝图中使用以及其他引擎功能。 | 用于定义可在蓝图中使用并集成到 Unreal Engine 系统（如编辑器）中的结构体。 |
| UENUM | 定义一个 C++枚举，可用于 Unreal Engine 的反射系统，使其在蓝图和其他引擎功能中可用。 | 用于定义可在蓝图中使用并集成到 Unreal Engine 系统（如编辑器）中的枚举。 |
| UPARAM | 指定当函数参数在蓝图或其他 Unreal Engine 系统中使用时应如何处理。 | 用于在蓝图暴露的 C++函数中定义参数属性，例如蓝图读写访问权限。 |
| UMETA | 为 UPROPERTY、UFUNCTION、UCLASS、USTRUCT 和 UENUM 提供额外的元数据，允许在 Unreal Engine 的反射系统中自定义它们的行为。 | 用于将附加信息或自定义设置附加到暴露给 Unreal Engine 反射的 C++实体。 |

### UPROPERTY

`UPROPERTY` 是一个用于在类中声明需要暴露给 Unreal Engine 反射系统的属性的宏。它允许引擎和蓝图脚本访问和修改该属性。

#### 指定符

*   `EditAnywhere` : 允许在编辑器和运行时编辑类的所有实例的属性。

*   `EditDefaultsOnly` : 仅允许在编辑器中编辑类的默认对象的属性。

*   `EditInstanceOnly` : 仅在运行时允许编辑类的实例的属性。

*   `VisibleAnywhere` : 在编辑器中显示所有类实例的属性值。

*   `VisibleDefaultsOnly` : 在编辑器中显示类的默认对象的属性值。

*   `VisibleInstanceOnly` : 仅在编辑器中显示类实例的属性值。

*   `BlueprintReadOnly` : 将属性暴露给 Blueprint 脚本，但仅限于读取，不可写入。

*   `BlueprintReadWrite` : 将属性暴露给 Blueprint 脚本，支持读取和写入。

*   `Category` : 在编辑器中将属性组织为命名类别，以改善组织性和可读性。

*   `EditFixedSize` : 指定 `TArray` 或 `TMap` 属性应在编辑器的详情面板中可编辑，且元素数量固定，禁止添加或删除。

*   `Transient` : 表示属性不应被序列化，使其非持久化，在保存对象状态时不保存。

*   `Replicated` : 当属性在服务器上发生变化时，自动将属性值复制到多玩家环境中的客户端。

*   `ReplicatedUsing` : 指定一个自定义函数，该函数应在服务器和客户端上调用以处理属性值的复制。

*   `SimpleDisplay` : 表示属性的值应在编辑器 UI 中以简单简洁的方式显示。

*   `AdvancedDisplay` : 表示该属性的值应在编辑器 UI 中以高级选项显示。

*   `Config` : 标记该属性将序列化到项目配置文件中，以便进行外部自定义。

*   `GlobalConfig` : 标记该属性将序列化到全局配置文件中，以便跨所有项目进行外部自定义。


#### 元标签

*   `DisplayName` : 在编辑器中为属性设置自定义显示名称。

*   `Tooltip` : 在编辑器中为属性提供提示描述。

*   `ClampMin` : 在编辑器中为属性设置最小允许值。

*   `ClampMax` : 在编辑器中为属性设置最大允许值。

*   `AllowPrivateAccess` : 允许访问它所属类中的私有成员。

*   `Units` : 为编辑器中的属性提供人类可读的单位标签。

*   `ForceUnits` : 强制设置单位。而不是让编辑器决定它想要什么。


#### 示例

```cpp
UPROPERTY(EditAnywhere, Category="Hello|Cruel|World")
int32 EditAnywhereNumber;
```

```cpp
UPROPERTY(Transient, Replicated)
int32 CurrentHealth;

UPROPERTY(Transient, ReplicatedUsing=OnArmorChanged)
int32 CurrentArmor;

UFUNCTION()
void OnArmorChanged();
```

```cpp
UPROPERTY(EditAnywhere, SimpleDisplay)
int32 MaxHealth = 100;

UPROPERTY(EditAnywhere, AdvancedDisplay)
float HealthRegenerationTime = 5.0f;
```

```cpp
// Must mark UCLASS with Config specifier

// Config can be overriden from the base class.
UPROPERTY(Config, BlueprintReadOnly)
bool bRegenerateHealth;

// GlobalConfig CANNOT be overridden from the base class.
UPROPERTY(GlobalConfig, BlueprintReadOnly)
bool bEnableHealthSimulation;
```

```cpp
UPROPERTY(EditAnywhere, EditFixedSize)
TArray<FName> Usernames = { TEXT("JohnDoe"), TEXT("MrRobin"), TEXT("JaneDoe") };
```

```cpp
UPROPERTY(EditAnywhere, meta=(Units="Celsius"))
float CookingTemperature;

UPROPERTY(EditAnywhere, meta=(Units="Kilograms"))
float TigerWeight;

UPROPERTY(EditAnywhere, meta=(Units="GB"))
float DiskSpace;

UPROPERTY(EditAnywhere, meta=(Units="Percent"))
float Happiness;

UPROPERTY(EditAnywhere, meta=(Units="times"))
float Deliciousness;
```

你可以通过 [UPROPERTY by BenUi](https://benui.ca/unreal/uproperty/) 了解更多关于 UPROPERTY 的信息。

### UFUNCTION

`UFUNCTION` 是一个宏，用于在类中声明需要暴露给 Unreal Engine 反射系统的函数。它允许该函数在蓝图脚本和网络复制中使用。

#### 常用修饰符

*   `BlueprintCallable` : 将函数暴露给蓝图脚本，允许从蓝图图内部调用。

*   `BlueprintPure` : 指示该函数是纯计算，不会修改任何状态，因此可以在蓝图图中使用而不会产生副作用。

*   `BlueprintImplementableEvent` : 在 C++中作为占位符函数，可以被覆盖并在蓝图中进行实现。

*   `BlueprintNativeEvent` : 类似于 `BlueprintImplementableEvent` ，但它还提供了 C++实现，可以在蓝图中可选地覆盖。

*   `Category` : 在编辑器中将属性组织成命名类别，以更好地组织和提高可读性。


#### 常见的元标签

*   `DisplayName` : 在编辑器中为函数设置自定义显示名称。

*   `Tooltip` : 在编辑器中为函数提供提示描述。

*   `ShortToolTip` : 为编辑器中的函数提供简短的提示描述。

*   `AllowPrivateAccess` : 允许访问它所属类中的私有成员。

*   `HideSelfPin` : 隐藏"self"引脚，该引脚指示被调用的对象。"self"引脚会在与调用蓝图类兼容的 `BlueprintPure` 函数上自动隐藏。频繁使用 `HideSelfPin` 元标签的函数也经常使用 `DefaultToSelf` 限定符。

*   `BlueprintInternalUseOnly` : 该函数是内部实现细节，用于实现另一个函数或节点。它永远不会直接在蓝图图中暴露。

*   `BlueprintProtected` : 该函数只能在一个蓝图中的拥有对象上调用。不能在其他实例上调用。

*   `DeprecatedFunction` : 任何对此函数的蓝图引用都会导致编译警告，提示用户该函数已弃用。您可以使用 `DeprecationMessage` 元数据指定符来添加到弃用警告消息中（例如，提供替换已弃用函数的说明）。


#### 示例

```cpp
UFUNCTION(BlueprintPure)
int32 BlueprintPureFunction();

UFUNCTION(BlueprintCallable)
int32 BlueprintCallableFunction();

UFUNCTION(BlueprintCallable)
int32 BlueprintCallableConstFunction() const;

UFUNCTION(BlueprintPure=false)
int32 BlueprintPureFalseFunction() const;
```

```cpp
UFUNCTION(BlueprintCallable, Category = "Doggy Daycare", meta=(ReturnDisplayName = "Success"))
bool TryPetDog(const FName Name);
```

您可以阅读更多关于 UFUNCTION 的信息，由 [UFUNCTION by BenUi](https://benui.ca/unreal/ufunction/) 提供。

### UCLASS

`UCLASS` 是一个宏，用于声明打算在 Unreal Engine 的反射系统中使用的类。它允许类被实例化、在蓝图中被暴露，并在各种引擎系统中使用。

#### 常见指定符

*   `Blueprintable` : 允许类在编辑器中作为蓝图使用。

*   `BlueprintType` : 指定该类可以在蓝图脚本中实例化和操作。

*   `Abstract` : 表明该类是一个抽象类，不能直接实例化。

*   `Transient` : 排除该类被序列化并保存到游戏的持久化数据中。

*   `MinimalAPI` : 限制该类的导出可见性，更适合引擎内部使用。

*   `NotBlueprintType` : 防止该类被用作蓝图。


#### 常见的元标签

*   `DisplayName` : 在编辑器中为该类设置自定义显示名称。

*   `ToolTip` : 在编辑器中为该类提供提示描述。

*   `HideCategories` : 隐藏特定属性类别在编辑器中显示。

*   `ClassGroup` : 将类分配给编辑器类选择器中的特定组。

*   `IncludePath` : 指定类生成代码的包含路径。

*   `BlueprintSpawnableComponent` : 将从 `USceneComponent` 派生的类标记为在蓝图中的可生成。


#### 示例

```cpp
UCLASS(Blueprintable)
class MyActor : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyActor")
    int32 MyIntProperty;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyActor")
    float MyFloatProperty;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyActor")
    FString MyStringProperty;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyActor")
    FMyStruct MyStructProperty;
};
```

你可以通过 [UCLASS by BenUi](https://benui.ca/unreal/uclass/) 了解更多关于 UCLASS 的信息。

### USTRUCT

`USTRUCT` 是一个宏，用于声明一个打算在虚幻引擎的反射系统中使用的 C++结构体。它使该结构体能够作为 UCLASS 中的属性使用，并向蓝图暴露。

#### 通用规范

*   `BlueprintType` : 指定该结构可以在蓝图脚本中使用。

*   `Atomic` : 确保该结构被视为原子类型，以便在多人游戏中复制。

*   `NotReplicated` : 排除该结构在网络中复制。


#### 通用元标签

*   `DisplayName` : 为编辑器中的结构设置自定义显示名称。

*   `ToolTip` : 为编辑器中的结构提供提示描述。

*   `Category` : 指定结构在编辑器中出现的分类。


#### 示例

```cpp
USTRUCT(BlueprintType)
struct FMyStruct
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, Category = "MyStruct")
    int32 Value1;

    UPROPERTY(BlueprintReadWrite, Category = "MyStruct")
    FString Value2;
};
```

你可以通过 [USTRUCT by BenUi](https://benui.ca/unreal/ustruct/) 了解更多关于 USTRUCT 的信息。

### UENUM

`UENUM` 是一个宏，用于声明一个打算在 Unreal Engine 的反射系统中使用的枚举。它允许枚举暴露给蓝图，并在 `UCLASS` 中使用。

#### 通用规范

*   `BlueprintType` : 指定该枚举可以在蓝图脚本中使用。

*   `DisplayNames` : 指定在编辑器中为每个枚举值提供的自定义显示名称列表。


#### 通用元标签

*   `DisplayName` : 在编辑器中为枚举设置自定义显示名称。

*   `ToolTip` : 在编辑器中为枚举提供提示描述。

*   `Hidden` : 在编辑器中隐藏枚举，使其不显示。

*   `Bitflags` : 指示该枚举表示一组位标志。

*   `EnumRange` : 指定枚举的最小值和最大值。


#### 示例

```cpp
UENUM(BlueprintType)
enum class EWeaponType
{
    Sword         UMETA(DisplayName = "Sword Weapon"),
    Axe           UMETA(DisplayName = "Axe Weapon"),
    Bow           UMETA(DisplayName = "Bow Weapon"),
    Wand          UMETA(DisplayName = "Magic Wand"),
};
```

您可以阅读更多关于 [UENUM by BenUi](https://benui.ca/unreal/uenum/) 的信息，由 BenUi 提供。

### UPARAM

`UPARAM` 是一个宏，用于向 Unreal Header Tool 提供附加信息。它与 UFUNCTION 和 UPROPERTY 参数一起使用，以指定引擎应如何处理数据。

*   `UPARAM(Ref)` : 用于标记按引用传递的参数。它确保在代码生成过程中将参数视为引用，这可能影响引擎如何处理该参数。

*   `UPARAM(DisplayName)` : 用于为在编辑器的蓝图节点图中出现的函数参数设置自定义显示名称。

*   `UPARAM(BlueprintCallable, BlueprintPure)` : 用于将多个限定符应用于函数参数。例如，将参数标记为同时具有 BlueprintCallable 和 BlueprintPure。

*   `UPARAM(meta = (CustomMetaTag))` : 允许开发者创建自定义元标签，并在函数参数中使用它们以向 Unreal Header Tool 提供额外信息。


#### 示例

```cpp
UCLASS()
class MyActor : public AActor
{
    GENERATED_BODY()

public:
    // A function that takes a parameter passed by reference
    UFUNCTION(BlueprintCallable, Category = "MyActor")
    void ModifyValue(UPARAM(Ref) int32& ValueToModify)
    {
        // Modify the value passed by reference
        ValueToModify *= 2;
    }
};
```

您可以阅读更多关于 UPARAM 的信息，由 BenUi 提供。

### UMETA

`UMETA` 是一个宏，用于为 UENUM 条目指定额外的元数据。它允许为枚举值添加自定义信息，用于蓝图、UI 和其他引擎系统。

#### 常见指定符

*   `DisplayName` : 在编辑器中为枚举值设置自定义显示名称。

*   `ToolTip` : 在编辑器中为枚举值提供提示描述。

*   `Hidden` : 隐藏枚举值在编辑器中的显示。

*   `DisplayPriority` : 指定枚举值在编辑器中的显示优先级。

*   `DisplayThumbnail` : 允许在编辑器中为枚举值附加自定义缩略图。

*   `CustomMetaData` : 指定开发者可以定义并按需使用的自定义元数据。


#### 示例

```cpp
UENUM(BlueprintType)
enum class EMyEnum
{
    Value1 UMETA(DisplayName = "First Value", ToolTip = "This is the first value"),
    Value2 UMETA(DisplayName = "Second Value", ToolTip = "This is the second value"),
    Value3 UMETA(Hidden),
};
```

你可以通过 [UPARAM by BenUi](https://benui.ca/unreal/uparam/) 了解更多关于 UMETA 的信息。

## 🧱 数据类型

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

![Data types](/static-img/Data_types.png)

### 字符

在 C++原生中，您使用 `char` 数据类型来编写一个字符：

```cpp
char myChar = 'a';
```

在 Unreal 中，有几种 `char` 数据类型：

*   `ANSICHAR` - 一个 ANSI 字符。通常是一个有符号类型。
*   `WIDECHAR` - 一个宽字符。通常是一个有符号类型。
*   `TCHAR` - 根据平台是否支持宽字符或许可方的需求，选择 `ANSICHAR` 或 `WIDECHAR` 。
*   `UTF8CHAR` - 一个包含 UTF8（Unicode，8 位，变宽）代码单元的 8 位字符。
*   `UTF16CHAR` - 一个包含 UTF16（Unicode，16 位，变宽）代码单元的 16 位字符。
*   `UTF32CHAR` - 一个包含 UTF32（Unicode，32 位，定宽）代码单元的 32 位字符。

在使用 Unreal 时，你通常会使用 `TCHAR` 作为 `char` 类型的数据类型。

定义 `TCHAR` ：

```cpp
TCHAR MyChar = 'A';
```

并且要使用这些数据类型的额外功能，你必须使用：

*   `FChar` for `TCHAR`
*   `FCharWide` for `WIDECHAR`
*   `FCharAnsi` for `ANSICHAR`

这里是一个函数列表，你可以从 `FChar` 访问：

*   `ToUpper()` - 仅转换 ASCII 字符。
*   `ToLower()` - 仅转换 ASCII 字符。
*   `IsUpper()` - 如果字符是大写字母，则返回布尔值。
*   `IsLower()` - 如果字符是小写字母，则返回布尔值。
*   `IsAlpha()` - 如果字符是字母，则返回布尔值。
*   `IsGraph()` - 如果字符是图形字符（可打印且不是空格），则返回布尔值。
*   `IsPrint()` - 如果字符是可打印字符（包括空白字符），则返回布尔值。
*   `IsPunct()` - 如果字符是标点字符（既不是字母数字也不是空白字符），则返回布尔值。
*   `IsAlnum()` - 如果字符是字母数字字符（字母或数字），则返回布尔值。
*   `IsDigit()` - 如果字符是十六进制数字（0-9，a-f 或 A-f），则返回布尔值。
*   `IsHexDigit()` - 如果字符是十进制数字（0-9），则返回布尔值。
*   `IsWhitespace()` - 如果字符是空白字符（空格、制表符、换行符、回车符、垂直制表符或换页符），则返回布尔值。
*   `IsControl()` - 如果字符是控制字符（非打印字符），则返回布尔值。
*   `IsOctDigit()` - 如果字符是八进制数字（0-7），则返回布尔值。
*   `ConvertCharDigitToInt()` - 将表示十进制数字的字符转换为整数。
*   `IsIdentifier()` - 如果字符是字母数字或下划线字符，则返回布尔值。
*   `IsUnderscore()` - 如果字符是下划线，则返回布尔值。
*   `ToUnsigned()` - 将字符转换为无符号整数以避免与小于 `int` 的带符号字符的符号扩展问题。

包含头文件：

```cpp
#include "Misc/Char.h"
```

这里是一个使用这些函数的 `FChar` 示例：

```cpp
TCHAR MyChar = 'a';

MyChar = FChar::ToUpper(MyChar); // MyChar: A

bool bIsDigit = FChar::IsDigit(MyChar); // false
bool bIsDigit = FChar::IsAlpha(MyChar); // true
```

你可以在 [TCHAR on Unreal's docs](https://docs.unrealengine.com/5.3/en-US/API/Runtime/Core/Misc/TChar/)了解更多关于 TCHAR 的信息。

### 布尔值

```cpp
// Unreal uses a 'b' prefix for booleans (always in lowercase).
bool bIsDead = true;
```

### 整数

在 C++原生中，你使用 `int` 数据类型来写一个整数：

```cpp
int health = 10;
```

在 Unreal 中，你使用 `int32` 来写一个整数：

```cpp
int32 Health = 10;
```

在 Unreal 中，除了标准的 `int32` 之外，不同整数类型如 `int8` 、 `int16` 和 `int64` 的可用性为开发者提供了多种选择，这些选择能够满足在数据大小和数值范围上的特定需求。

```cpp
int8 NumberA = 0;       // -128                             ->      127
int16 NumberB = 0;      // -32,768                           ->      32,767
int32 NumberC = 0;      // -2,147,483,648                   ->      2,147,483,647
int64 NumberD = 0;      // 9,223,372,036,854,775,808        ->      9,223,372,036,854,775,807
```

您还有无符号（仅正数）整数：

```cpp
uint8 NumberA = 0;      // 0    ->      255
uint16 NumberB = 0;     // 0    ->      65,535
uint32 NumberC = 0;     // 0    ->      4,294,967,295
uint64 NumberD = 0;     // 0    ->      18,446,744,073,709,551,615
```

### 浮点数

```cpp
// C++ always uses 'f' or 'F' literal for defining a float variable.
float SpeedInMetersPerSecond = 5.5f;
```

```cpp
// C++ never uses a literal for defining a double variable.
double SpeedInMetersPerSecond = 5.5;
```

### 🛟 大小可能不同

通常建议使用 Unreal 的自定义类型定义，例如使用 `int32` 而不是 `int` 来表示 32 位有符号整数。这是因为 `int` 的确切大小由 C++标准未定义。

C++实现可以定义数据类型的大小（以字节为单位）（ `sizeof(type)` ）为任何值，只要：

*   表达式 `sizeof(type) * CHAR_BIT` 的值足够高，能够包含所需的范围。
*   并且类型的顺序仍然有效（例如 `sizeof(int) <= sizeof(long)` ）。

`CHAR_BIT` 是 char 中的位数。它在 C++语言的“limits.h”头文件中声明。每个字节为 8 位。

你可以在本节中了解更多关于数据范围的信息。

因此，汇总数据大小将是：

* `char`, `signed char` and `unsigned char` are at least 8 bits

* `signed short`, `unsigned short`, `signed int` and `unsigned int` are at least 16 bits

* `signed long` and `unsigned long` are at least 32 bits

* `signed long long` and `unsigned long long` are at least 64 bits

你可以在 [Alex on Stack Overflow](https://stackoverflow.com/a/589684/17067030) 了解更多详细信息。

* * *

这是 Unreal 的完整数据类型大小列表：

| 数据类型 | 有符号 | 大小（字节） |
| --- | --- | --- |
| bool | \- | 永远不要假设大小 |
| TCHAR | \- | 永远不要假设大小 |
| uint8 | false | 1 |
| int8 | true | 1 |
| uint16 | false | 2 |
| int16 | true | 2 |
| uint32 | false | 4 |
| int32 | true | 4 |
| uint64 | false | 8 |
| int64 | true | 8 |
| float | true | 4 |
| double | true | 8 |

### 🦺 Unreal Engine 类型定义

在虚幻引擎中，您现在可以用 `int64` 代替 `signed long long` 来表示 64 位整数。这些别名称为 typedef，您可以在 [typedef keyword in C++ docs](https://en.cppreference.com/w/cpp/language/typedef)了解更多关于 typedef 关键字的信息。

您可以在本节中了解更多关于 C++ typedef 的信息。

以下是虚幻引擎的 typedef 完整列表：

```cpp
//~ Unsigned base types.
/// An 8-bit unsigned integer.
typedef FPlatformTypes::uint8		uint8;
/// A 16-bit unsigned integer.
typedef FPlatformTypes::uint16		uint16;
/// A 32-bit unsigned integer.
typedef FPlatformTypes::uint32		uint32;
/// A 64-bit unsigned integer.
typedef FPlatformTypes::uint64		uint64;

//~ Signed base types.
/// An 8-bit signed integer.
typedef	FPlatformTypes::int8		int8;
/// A 16-bit signed integer.
typedef FPlatformTypes::int16		int16;
/// A 32-bit signed integer.
typedef FPlatformTypes::int32		int32;
/// A 64-bit signed integer.
typedef FPlatformTypes::int64		int64;

//~ Character types.
/// An ANSI character. Normally a signed type.
typedef FPlatformTypes::ANSICHAR	ANSICHAR;
/// A wide character. Normally a signed type.
typedef FPlatformTypes::WIDECHAR	WIDECHAR;
/// Either ANSICHAR or WIDECHAR, depending on whether the platform supports wide characters or the requirements of the licensee.
typedef FPlatformTypes::TCHAR		TCHAR;
/// An 8-bit character containing a UTF8 (Unicode, 8-bit, variable-width) code unit.
typedef FPlatformTypes::UTF8CHAR	UTF8CHAR;
/// A 16-bit character containing a UCS2 (Unicode, 16-bit, fixed-width) code unit, used for compatibility with 'Windows TCHAR' across multiple platforms.
typedef FPlatformTypes::CHAR16		UCS2CHAR;
/// A 16-bit character containing a UTF16 (Unicode, 16-bit, variable-width) code unit.
typedef FPlatformTypes::CHAR16		UTF16CHAR;
/// A 32-bit character containing a UTF32 (Unicode, 32-bit, fixed-width) code unit.
typedef FPlatformTypes::CHAR32		UTF32CHAR;

/// An unsigned integer the same size as a pointer
typedef FPlatformTypes::UPTRINT UPTRINT;
/// A signed integer the same size as a pointer
typedef FPlatformTypes::PTRINT PTRINT;
/// An unsigned integer the same size as a pointer, the same as UPTRINT
typedef FPlatformTypes::SIZE_T SIZE_T;
/// An integer the same size as a pointer, the same as PTRINT
typedef FPlatformTypes::SSIZE_T SSIZE_T;

/// The type of the NULL constant.
typedef FPlatformTypes::TYPE_OF_NULL	TYPE_OF_NULL;
/// The type of the C++ nullptr keyword.
typedef FPlatformTypes::TYPE_OF_NULLPTR	TYPE_OF_NULLPTR;
```

<Callout type="warn"> `uint16` 、 `uint32` 、 `uint64` 、 `int8` 、 `int16` 和 `double` 在 UHT [3](#user-content-fn-2) 中不受支持。这意味着无法将其暴露给蓝图。</Callout>

### 📖 字符串数据类型

在编程语言中，字符串是基本数据类型，用于表示和操作字符序列，如单词、句子，甚至二进制数据。它们在各种编程任务中广泛使用，包括输入/输出操作、文本处理、数据序列化等。

在虚幻引擎中，字符串在处理游戏或应用程序中的文本信息方面起着至关重要的作用。虚幻引擎提供了多个与字符串相关的类，以满足不同的使用场景和需求。

您可以查阅文档[string handling from the docs](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/)了解更多关于字符串处理的信息。

### 文本宏

* `TEXT` - 该宏用于指定宽字符（UTF-16）编码，从而使字符串字面量具有平台无关性。没有该宏，您将使用ANSI编码（这可能会在其他机器上引起问题）。

* `INVTEXT` - 此宏调用 FText::AsCultureInvariant(TEXT(InTextLiteral))，其中 InTextLiteral 作为参数。它有助于从给定的字符串字面量创建文化无关的 FText。

* `LOCTEXT` - 该宏用于专门为本地化创建 `FText` 字面量。它接受一个命名空间和一个键来标识本地化的字符串。

#### FName

在虚幻引擎中， `FName` 是一种特殊类型，用于在虚幻引擎对象系统中标识对象。它针对快速比较和存储进行了优化，通常用于以性能高效的方式引用角色、组件或资源。

`FName` 类将字符串存储为哈希索引，使其成为常规字符串的轻量级和快速替代方案。正因如此， `FName` 是一种不可变字符串类。

**这里有一个示例：**

包含头文件：

```cpp
#include "UObject/NameTypes.h"
```

声明 `FName` :

```cpp
FName MyName = FName(TEXT("PlayerName"));
```

#### FText

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

`FText` 是一个专为虚幻引擎本地化支持设计的特殊字符串类。正因如此， `FText` 是不可变字符串类。FText 提供了在不同语言和文化中表示文本的能力，使其成为构建多语言游戏或应用程序的关键组件。

您可以在[Unreal's docs](https://docs.unrealengine.com/5.3/en-US/ftext-in-unreal-engine/)了解更多信息。

**这是一个示例：**

包含头文件：

```cpp
#include "Internationalization/Text.h"
```

从字符串字面量（非本地化）声明 `FText` ：

```cpp
// Avoid this! Since this cost more performance than initializing directly as FText.
FText NewGameText = FText::FromString(TEXT("New Game"));
```

要在 Unreal Editor 中使用多行 `FText` ，可以使用 `UPROPERTY` 元标记指定 `Multiline` ：

```cpp
UPROPERTY(EditAnywhere, Category = "Details", meta = (MultiLine = "true"))
FText Description;
```

从 `INVTEXT()` 宏声明 `FText` 。它从字符串字面量创建一个文化不变的 `FText` ：

```cpp
FText TooltipText = INVTEXT("Tooltip Text");

/*
    Inside Unreal Engine source code:

    // Creates a culture invariant FText from the given string literal.
    #define INVTEXT(InTextLiteral) FText::AsCultureInvariant(TEXT(InTextLiteral))
*/

// So, FText::AsCultureInvariant does the same thing as INVTEXT() macro.
FText NewTooltipText = FText::AsCultureInvariant(TEXT("This is another tooltip text"));
```

```cpp
// Define the namespace to use with LOCTEXT
// This is only valid within a single file, and must be undefined before the end of the file
#define LOCTEXT_NAMESPACE "MyNamespace"
// Create text literals
FText PlayGameText = LOCTEXT("PlayGame", "Spiel beginnen"); // German langauge

// Helpful in the editor to localize the text into another language.
FText QuitGameText = NSLOCTEXT("StartMenu", "QuitGame", "Avsluta spelet"); // Swedish language

uint32 VersionNumber = 1405476850;
FText MachineOS = INVTEXT("Windows 11 Pro, 22H2, 22621.2215");
FText UserName = INVTEXT("MrRobin");
int32 UserAge = 22;
int32 SpeedInKph = 30;
int32 FuelInPercentage = 80;

// Formatting with FText. The supported types is: int32, uint32, float, double, FText, ETextGender.
FText VersionMessageText = FText::Format(
    LOCTEXT("VersionMessage", "You current version is {0} and is running on {1}"),
    VersionNumber,
    MachineOS
);

// FString also has FString::Prinf() function for formatting. FString::Prinf() is also similar to the native C++ sprintf() function.

// Use FFormatNamedArguments for organizing the FText::Format function.
FFormatNamedArguments Args;
Args.Add(TEXT("Name"), UserName);
Args.Add(TEXT("Age"), UserAge);
FText UserText = FText::Format(LOCTEXT("UserData", "User's name is {UserName} and is {Age} years old."), Args);

// You can also use FText::FormatNamed() function for formatting as well. Great for inlining the code.
FText CarMessageText = FText::FormatNamed(
    LOCTEXT("VehicleMessage", "You current speed is {Speed} and the fuel is at {Fuel}%"),
    TEXT("Speed"), SpeedInKph,
    TEXT("Fuel"), FuelInPercentage
);

#undef LOCTEXT_NAMESPACE // Undefine the current namespace
```

你可以将特定数据类型转换为 `FText` 格式。例如，你可以使用 `FText::AsNumber()` 将数字转换为 `FText` ，并使用特定的 `FNumberFormattingOptions` 格式选项。

这里有一个示例：

```cpp
float Health = 99.8999f; // We want to round this up, like this: 100.00

bool bIncludeLeadingZero = true;
int32 Precision = 2; // Number of decimals after decimal point. (0.00)

FNumberFormattingOptions NumberFormat;
NumberFormat.MinimumIntegralDigits = (bIncludeLeadingZero) ? 1 : 0;
NumberFormat.MaximumIntegralDigits = 10000;
NumberFormat.MinimumFractionalDigits = Precision;
NumberFormat.MaximumFractionalDigits = Precision;

FText NumberText = FText::AsNumber(Health, &NumberFormat);
NumberText = FText::AsCultureInvariant(NumberText); // Disable the culture formatting
```

<Callout> 默认情况下，Unreal 在执行此格式化时会使用本地文化。如果你希望禁用文化格式化，请使用 `FText::AsCultureInvariant` 函数。</Callout>

#### FString

`FString` 是虚幻引擎中的一种动态、可变字符串类型，它提供了一种更灵活的字符串操作方法。与 `FName` 不同， `FString` 允许进行修改，例如追加、插入或删除字符，使其适用于一般字符串操作。它广泛应用于各种任务，例如显示消息、连接文本或格式化输出字符串。

示例用法：

```cpp
#include "Containers/UnrealString.h"

FString MyString = FString("Hello, World!");
```

在 `FString` 中用另一个字符串替换子字符串：

```cpp
FString OriginalString = FString("Hello, my friend.");
OriginalString.ReplaceInline(TEXT("friend"), TEXT("buddy")); // Output: "Hello, my buddy."
```

使用分隔符将 `FString` 分割为子字符串数组：

```cpp
FString Sentence = FString("This is a sentence.");
TArray<FString> Words;
Sentence.ParseIntoArray(Words, TEXT(" "), true); // Output: ["This", "is", "a", "sentence."]
```

反转一个 `FString` :

```cpp
FString Text = FString("abcde");
Text.ReverseString(); // Output: "edcba"
```

* * *

| 数据类型 | 描述 | 使用案例 |
| --- | --- | --- |
| FName | 一个快速轻量级的名稱识别器，用于虚幻引擎中的对象。 | 最适合用于识别引擎中的资源和对象，以节省内存并提高性能。 |
| FText | 一个本地化的字符串，支持文本本地化并提供文本显示功能。 | 非常适合在游戏中向用户显示文本，支持多种语言和本地化。 |
| FString | 一个可修改的动态字符串，可用于通用字符串操作。 | 适用于通用文本处理和游戏代码中的字符串操作。 |

### 🚀 数学数据类型

<Callout>
 在虚幻引擎 5.0 及以上版本中，默认情况下所有与数学相关的数据类型都使用 `double` 作为后端数据类型。这使虚幻引擎能够支持[大型世界坐标（LWC）](https://docs.unrealengine.com/5.3/en-US/large-world-coordinates-in-unreal-engine-5/)。
</Callout>

#### Vector4

一个表示 4D 向量的结构体，包含四个 float 类型的值，分别对应 `X` 、 `Y` 、 `Z` 和 `W` 分量。

声明并初始化一个 `FVector4` ：

```cpp
FVector4 MyVector = FVector(1.0f, 2.0f, 3.0f, 4.0f);
```

你也可以通过一个预制的向量进行初始化：

```cpp
FVector4 OldLocation = FVector4::ZeroVector; // (0, 0, 0)
FVector4 NewLocation = FVector4::OneVector; // (1, 1, 1)
```

<Callout> 使用 `FVector4f` 代表 `float` ，使用 `FVector4d` 代表 `double` ，作为后端转换的明确数据类型。</Callout>

* * *

要使用 `FVector4` 的整数版本：

```cpp
FIntVector4 IntVector4; // Default to 32-bit
FInt32Vector4 Int32Vector4; // 32-bit
FInt64Vector4 Int64Vector4; // 64-bit

FUintVector4 UintVector4; // Default to unsigned 32-bit
FUint32Vector4 Uint32Vector4; // Unsigned 32-bit
FUint64Vector4 FUint64Vector4; // Unsigned 64-bit
```

#### Vector3

一个表示 3D 向量的结构体，包含三个浮点值，分别对应 `X` 、 `Y` 和 `Z` 分量。它常用于表示 3D 空间中的位置或方向，并提供许多有用函数，如向量加法、减法、归一化以及点积和叉积。

声明并初始化一个 `FVector` :

```cpp
FVector MyVector = FVector(1.0f, 2.0f, 3.0f);
```

您也可以通过一个预制的向量进行初始化：

```cpp
FVector OldLocation = FVector::ZeroVector; // (0, 0, 0)
FVector NewLocation = FVector::OneVector; // (1, 1, 1)
```

您可以单独选择每个分量：

```cpp
FVector Vec = FVector::OneVector;

double X = Vec.X;
double Y = Vec.Y;
double Z = Vec.Z;

// or

double& X = Vec[0];
double& Y = Vec[1];
double& Z = Vec[2];
```

<Callout> 使用 `FVector3f` 作为 `float` ，使用 `FVector3d` 作为 `double` ，作为后端转换的显式数据类型。</Callout>

* * *

常用的静态函数：

*   `FVector::Cross()` - 计算此向量和另一个向量的叉积。
*   `FVector::CrossProduct()` - 计算两个向量的叉积。
*   `FVector::Dot()` - 计算此向量和另一个向量的点积。
*   `FVector::DotProduct()` - 计算两个向量的点积。
*   `FVector::Dist()` 或 `FVector::Distance()` - 两个点之间的欧几里得距离。
*   `FVector::Dist2D()` 或 `FVector::DistXY()` - 两个点在 XY 平面上的欧几里得距离（忽略 Z 轴）。
*   `FVector::DistSquared()` - 两个点之间的平方距离。
*   `FVector::DistSquared2D()` 或 `FVector::DistSquaredXY()` - 仅 XY 平面中两点之间的平方距离。
*   `FVector::AllComponentsEqual()` - 检查该向量的所有分量是否相同，允许一定的误差。

<Callout type="success">
 您可以使用 `|` 运算符来调用点积。
</Callout>

<Callout type="success">
 您可以使用 `^` 运算符来调用叉积。
</Callout>

常用的本地函数：

*   `GetComponentForAxis()` - 通过枚举指定轴，获取向量的特定分量。
*   `SetGetComponentForAxis()` - 通过枚举指定轴，设置向量的特定分量。
*   `Set()` - 直接设置向量的值。
*   `GetMax()` - 获取向量分量的最大值。
*   `GetAbsMax()` - 获取向量分量的最大绝对值。
*   `GetMin()` - 获取向量分量的最小绝对值。
*   `GetAbsMin()` - 获取向量分量的最小绝对值。
*   `GetAbs()` - 获取此向量的副本，其中每个分量的绝对值。
*   `Size()` 或 `Length()` - 获取此向量的长度（模）。
*   `SizeSquared()` 或 `SquaredLength()` - 获取此向量的平方长度。
*   `Size2D()` - 获取此向量二维分量的长度。
*   `SizeSquared2D()` - 获取此向量二维分量的平方长度。
*   `HeadingAngle()` - 将方向向量转换为'航向'角度。
*   `IsNearlyZero()` - 检查向量是否在指定容差范围内接近零。
*   `IsZero()` - 检查向量的所有分量是否完全为零。
*   `IsUnit()` - 检查向量是否为单位长度，具有指定的容差。
*   `IsNormalized()` - 检查向量是否已归一化。
*   `Normalize()` - 如果向量大于给定容差，则原地归一化该向量。如果不符合条件，则保持不变。
*   `GetSignVector()` - 获取向量的符号副本。每个分量被设置为+1 或-1，零的符号被视为+1。
*   `Projection()` - Z 向量的 2D 分量。
*   `GridSnap()` - 获取一个与此向量对齐到网格的副本。
*   `IsUniform()` - 检查 X、Y 和 Z 是否几乎相等。
*   `ConstainsNaN()` - 检查此向量中是否存在任何非有限值（NaN 或 Inf）的实用工具。
*   `ToString()` - 获取此向量的文本表示。
*   `ToCompactString()` - 获取此向量的简短文本表示，用于紧凑、可读的日志记录。
*   `ToText()` - 获取具有区域设置感知的此向量的文本表示。
*   `ToCompactText()` - 获取具有区域设置感知的此向量的简短文本表示，用于紧凑、可读的日志记录。

* * *

要使用 `FVector` 的整数版本：

```cpp
FIntVector IntVector = FIntVector(5, 10, -25); // Default to 32-bit
FUintVector UintVector = FUintVector(5, 10, 25); // Default to unsigned 32-bit
```

这是更明确的版本：

```cpp
FIntVector3 IntVector3; // Default to 32-bit
FInt32Vector3 Int32Vector3; // 32-bit
FInt64Vector3 Int64Vector3; // 64-bit

FUintVector3 UintVector3; // Default to unsigned 32-bit
FUint32Vector3 Uint32Vector3; // Unsigned 32-bit
FUint64Vector3 FUint64Vector3; // Unsigned 64-bit
```

#### Vector2

一个表示二维向量的结构体，包含两个 float 值用于 `X` 和 `Y` 分量。

声明并初始化一个 `FVector2D` :

```cpp
FVector2D MyVector = FVector2D(1.0f, 2.0f, 3.0f);
```

您也可以通过一个预制的向量来初始化：

```cpp
FVector2D OldLocation = FVector2D::ZeroVector; // (0, 0, 0)
FVector2D NewLocation = FVector2D::OneVector; // (1, 1, 1)
```

<Callout> 使用 `FVector2f` 表示 `float` ，使用 `FVector2d` 表示 `double` ，作为后端转换的显式数据类型。 </Callout>

* * *

要使用 `FVector2D` 的整数版本：

```cpp
FIntVector2 IntVector2; // Default to 32-bit
FInt32Vector2 Int32Vector2; // 32-bit
FInt64Vector2 Int64Vector2; // 64-bit

FUintVector2 UintVector2; // Default to unsigned 32-bit
FUint32Vector2 Uint32Vector2; // Unsigned 32-bit
FUint64Vector2 FUint64Vector2; // Unsigned 64-bit
```

#### IntPoint

一个表示 2D 整数点的结构体，包含两个 int 值作为 `X` 和 `Y` 分量。

声明并初始化一个 `FIntPoint` ：

```cpp
FIntPoint MinPoint = FIntPoint(-127, -127);
FIntPoint MaxPoint = FIntPoint(128, 128);
```

声明并初始化一个 `FUIntPoint` ：

```cpp
FUIntPoint UnsignedMinPoint = FUIntPoint(0, 0);
FUIntPoint UnsignedMaxPoint = FUIntPoint(255, 255);
```

<Callout> 使用 `FInt32Point` 代表 `int32` ， `FUint32Point` 代表 `uint32` ， `FInt64Point` 代表 `int64` ，以及 `FUint64Point` 代表 `uint64` ，作为后端转换的明确数据类型。</Callout>

#### IntRect

一个表示二维整数矩形的结构体，包含两个 IntPoint 值作为 `Min` 和 `Max` 的组件。

声明并初始化一个 `FIntRect` :

```cpp
FIntPoint MinPoint = FIntPoint(-127, -127);
FIntPoint MaxPoint = FIntPoint(128, 128);
FIntReact Rect = FIntRect(MinPoint, MaxPoint);
```

声明并初始化一个 `FUIntReact` :

```cpp
FUIntPoint UnsignedMinPoint = FUIntPoint(0, 0);
FUIntPoint UnsignedMaxPoint = FUIntPoint(255, 255);
FUIntReact UnsignedRect = FIntRect(UnsignedMinPoint, UnsignedMaxPoint);
```

<Callout> 使用 `FInt32Rect` 表示 `int32` ， `FUint32Rect` 表示 `uint32` ， `FInt64Rect` 表示 `int64` ，以及 `FUint64Rect` 表示 `uint64` ，作为后端转换的显式数据类型。</Callout>

#### Rotator

一个表示三维空间中旋转的结构体，包含三个浮点数值分别对应 `Pitch` ， `Yaw` ，和 `Roll` 角度。它通常用于表示物体的方向，并提供许多有用功能，如四元数转换以及其他向量和旋转器的旋转功能。

声明并初始化一个 `FRotator` :

```cpp
FRotator MyRotator = FRotator(0.0f, 90.0f, 0.0f);
```

您也可以通过一个预制的旋转器进行初始化：

```cpp
FRotator MyRotator = FRotator::ZeroRotator; // (0, 0, 0)
```

<Callout> 使用 `FRotator3f` 表示 `float` ，使用 `FRotator3d` 表示 `double` ，作为后端转换的明确数据类型。</Callout>

* * *

常用的静态函数：

*   `FRotator::Vector()` - 将旋转转换为指向其方向的单位向量。

常用的本地函数：

*   `GetInverse()` - 返回旋转器的逆。
*   `GridSnap()` - 获取旋转，并 snapped 到指定的度数段。

#### 四元数

一个表示 3D 空间中四元数的结构体，包含三个 float 值用于 `X` 、 `Y` 、 `Z` 和 `W` 分量。四元数是一个数学概念，用于表示 3D 旋转。它通常与 `FVector` 一起使用，用于表示 3D 空间中的方向和旋转。

声明并初始化一个 `FQuat` ：

```cpp
FQuat MyQuaternion = FQuat(0.0f, 90.0f, 0.0f, 0.0f);
```

你也可以通过一个预制的四元数进行初始化：

```cpp
FQuat MyQuaternion = FQuat::Identify; // (0, 0, 0, 0)
```

<Callout> 使用 `FQuat4f` 代替 `float` ，使用 `FQuat4d` 代替 `double` ，作为后端转换的明确数据类型。</Callout>

#### Transform

一个表示 3D 变换的结构，包含一个 `FVector` 用于平移、一个 `FQuat` 用于旋转和一个 `FVector` 用于缩放。它通常用于表示 3D 空间中物体的位置、方向和大小，并提供许多用于变换其他向量和变换的实用函数。

声明并初始化一个 `FTransform` :

```cpp
FVector Location = FVector::ZeroVector;
FRotator Rotation = FRotator::ZeroRotator;
FVector Scale = FVector::OneVector;

// Note! Unreal will convert FRotator into FQuat in the backend.
FTransform MyTransform = FTransform(Rotation, Location, Scale);
```

您也可以通过一个预制的转换来初始化：

```cpp
FTransform MyTransform = FTransform::Identify; // NaN
```

<Callout> 使用 `FTransform3f` 代表 `float` ，使用 `FTransform3d` 代表 `double` ，作为后端转换的明确数据类型。</Callout>

#### 平面

一个表示三维平面的结构体。

这是一个示例：

```cpp
float X = 0.0f;
float Y = 0.0f;
float X = 0.0f;

FPlane Plane = FVector(X, Y, Z);
```

另一种初始化 `FPlane` 的方法：

```cpp
FPlane Plane = FVector(FVector(0.0f, 0.0f, 0.0f));
```

<Callout> 将 `FPlane4f` 用于 `float` ，将 `FPlane4d` 用于 `double` ，作为后端转换的明确数据类型。</Callout>

#### 矩阵

一个表示 4x4 浮点数矩阵的结构。

这里是一个示例：

```cpp
FPlane XPlane = FPlane(1.0f, 0.0f, 0.0f, 0.0f);
FPlane YPlane = FPlane(0.0f, 1.0f, 0.0f, 0.0f);
FPlane ZPlane = FPlane(0.0f, 0.0f, 1.0f, 0.0f);
FPlane WPlane = FPlane(0.0f, 0.0f, 0.0f, 1.0f);

FMatrix Matrix = FMatrix(XPlane, YPlane, ZPlane, WPlane);
```

```cpp
FVector XVector = FVector(1.0f, 0.0f, 0.0f);
FVector YVector = FVector(0.0f, 1.0f, 0.0f);
FVector ZVector = FVector(0.0f, 0.0f, 1.0f);
FVector WVector = FVector(0.0f, 0.0f, 0.0f);

FMatrix Matrix = FMatrix(XVector, YVector, ZVector, WVector);
```

```cpp
FMatrix Matrix;

int32 RowIndex = 0;
int32 ColumnIndex = 0;

double Element = Matrix[RowIndex][ColumnIndex];
```

<Callout> 在后端转换时，使用 `FMatrix44f` 作为 `float` ，使用 `FMatrix44d` 作为 `double` ，作为显式的数据类型。</Callout>

#### 球体

一个表示 3D 球体的结构。

这里是一个示例：

```cpp
FVector Center = FVector::ZeroVector;
float Radius = 500.0f;

FSphere Sphere = FSphere(Center, Radius);
```

<Callout> 使用 `FSphere3f` 表示 `float` ，使用 `FSphere3d` 表示 `double` ，作为后端转换的明确数据类型。</Callout>

#### Box

一个表示 3D 盒子的结构体。

这里是一个示例：

```cpp
FVector MinPoint = FVector(15.5f, 15.5f);
FVector MaxPoint = FVector(25.0f, 25.0f);

FBox Box2D = FBox(MinPoint, MaxPoint);
```

<Callout>] 使用 `FBox3f` 表示 `float` ，使用 `FBox3d` 表示 `double` ，作为后端转换的明确数据类型。</Callout>

#### Box2D

一个表示 2D 框的结构。

这里是一个示例：

```cpp
FVector2D MinPoint = FVector2D(10, 10);
FVector2D MaxPoint = FVector2D(20, 20);

FBox2D Box2D = FBox2D(MinPoint, MaxPoint);
```

<Callout> 使用 `FBox2f` 表示 `float` ，使用 `FBox2d` 表示 `double` ，作为后端转换的明确数据类型。</Callout>

#### Ray

一个表示 3D 射线的结构体，包含两个向量值用于 `Origin` 和 `Direction` 分量。

这里是一个示例：

```cpp
FVector Origin = FVector::ZeroVector;
FVector Direction = FVector::ForwardVector;
bool bDirectionIsNormalized = false;

FRay Ray = FRay(Origin, Direction, bDirectionIsNormalized);
```

与 `FRay` 一起使用的函数：

```cpp
FVector Point = FVector::ZeroVector;

FVector ClosestPoint = Ray.ClosestPoint(Point);
double MinDistance = Ray.Dist(Point);
double MinSqrtDistance = Ray.DistSquared(Point);

double ScalarDistance = 0.5; // Along the ray
FVector PointAt = Ray.PointAt(ScalarDistance);
double CalcScalarDistance = Ray.GetParameter(PointAt); // Will convert back to 'ScalarDistance'
```

<Callout> 将 `FRay3f` 用于 `float` ，将 `FRay3d` 用于 `double` ，作为后端转换的显式数据类型。</Callout>

#### 颜色

`FColor` 存储每个通道 8 位（字节）精度的颜色。

`FLinearColor` 存储线性颜色，使用 32 位/组件浮点 RGBA 颜色。

这里是一个初始化它们的示例：

```cpp
FLinearColor LinearColor = FLinearColor(0.5f, 1.0f, 0.3f);
```

```cpp
FColor Color = FColor(150, 200, 50);

// or

// Supported formats are: RGB, RRGGBB, RRGGBBAA, RGB, #RRGGBB, #RRGGBBAA
FColor HexColor = FColor::FromHex(TEXT("#9fd99e"));
FString HexString = HexColor.ToHex(); // Convert it back to a string. The format of the string is RRGGBBAA.
```

`FLinearColor` 的常见颜色列表：

*   `FLinearColor::White`
*   `FLinearColor::Gray`
*   `FLinearColor::Black`
*   `FLinearColor::Transparent`
*   `FLinearColor::Red`
*   `FLinearColor::Green`
*   `FLinearColor::Blue`
*   `FLinearColor::Yellow`

`FColor` 的常见颜色列表：

*   `FColor::White`
*   `FColor::Black`
*   `FColor::Transparent`
*   `FColor::Red`
*   `FColor::Green`
*   `FColor::Blue`
*   `FColor::Yellow`
*   `FColor::Cyan`
*   `FColor::Magenta`
*   `FColor::Orange`
*   `FColor::Purple`
*   `FColor::Turquoise`
*   `FColor::Silver`
*   `FColor::Emerald`

你可以在 Unreal 的文档中了解更多关于线性颜色的信息。

你也可以在 Unreal 的文档中了解更多关于颜色的信息。

### 💐 集合

![Collections](/static-img/Collections.png)

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

| 数据容器 | 描述 | 使用场景 |
| --- | --- | --- |
| TArray | 一个在运行时可以增长或缩小大小的动态数组，支持随机访问和迭代。 | 适用于存储和管理元素集合，其中大小可能频繁变化且需要快速访问元素。 |
| TSet | 一种集合数据结构，以无特定顺序存储唯一元素，高效支持元素插入、删除和成员检查。 | 非常适合维护一组不同的元素，并能快速进行成员检查且不重复。 |
| TMap | 一种关联容器，存储键值对，允许基于键进行高效的查找和检索。 | 用于创建字典或关联数组，其中数据根据唯一键进行组织，以便快速高效地访问。 |

#### TArray

一个可以存储相同类型元素变数量的动态数组。它提供了许多有用的函数，例如添加、删除、排序和搜索元素，以及遍历它们。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/Array.h"
```

声明一个 `TArray` 的 `int32` (整数)

```cpp
TArray<int32> MyArray { 1, 2, 3 };
```

为数组添加一个元素：

```cpp
MyArray.Add(4);

// MyArray: { 1, 2, 3, 4 }
```

为数组添加多个元素：

```cpp
MyArray.Append({10, 15, 20});

// MyArray: { 1, 2, 3, 4, 10, 15, 20 }
```

从数组中删除元素：

```cpp
MyArray.RemoveAt(0);
MyArray.RemoveAt(0);

// MyArray: { 3, 4, 10, 15, 20 }
```

获取数组中的元素数量：

```cpp
int32 NumOfElements = MyArray.Num(); // 5
```

遍历数组并记录每个元素：

```cpp
for (const int32& Element : MyArray)
{
    UE_LOG(LogTemp, Log, TEXT("Element: %i"), Element);
}
```

* * *

你可以选择在栈上或堆上分配数组。如果没有指定，你正在堆上创建数组分配，而数组返回一个栈上的数据容器。

如果你不知道栈和堆分配的区别，强烈建议阅读本节的相关内容。

这里有一种在栈上分配数组的方法：

```cpp
TArray<int32, TInlineAllocator<4>> StackArray; // Allocate 4 elements on the stack

StackArray.Add(1);
StackArray.Add(2);
StackArray.Add(3);
StackArray.Add(4);

// Now we added the same amount of elements, to our buffer size (which has been allocated on the stack).
// If we try to add more elements than allocated, Unreal will default TArray to use heap allocation for the rest of elements.

StackArray.Add(5); // Will be allocated on the heap!
```

<Callout type="warn"> 如果你试图使用 `TInlineAllocator` 在栈上分配堆对象，Unreal 会默认采用堆分配。</Callout>

<Callout type="warn"> 如果你添加的元素数量超过已分配的容量，Unreal 会默认采用堆分配。</Callout>

<Callout> Unreal 会将栈分配的数组视为不同的数据类型，与普通数组不同。为了适应这一点，请使用 `TArrayView` 。</Callout>

如果你希望避免用堆分配填充剩余的元素，请使用 `TFixedAllocator` 。

```cpp
TArray<int32, TFixedAllocator<4>> StackArray; // Allocate 4 elements on the stack

StackArray.Add(1);
StackArray.Add(2);
StackArray.Add(3);
StackArray.Add(4);

StackArray.Add(5); // Unreal calls an assertion, which will CRASH Unreal in runtime mode!

// If you're continuing on with the assertion, using Visual Studio Debugger, Unreal will call Reset() function.
// Clearing out all elements, but keeping the current allocation size.

// Same thing happens with brace initialization.
TArray<int32, TFixedAllocator<4>> StackArray{ 1, 2, 3, 4, 5 }; // Allocate 4 elements on the stack, but we got 5 elements!
```

#### TSet

一种单一类型的唯一元素集合，实现为哈希表。它提供了与 `TArray` 相同的许多功能，但对于大量元素集合的查找速度更快。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/Set.h"
```

声明一个 `TSet` 的 `FName` （名字）：

```cpp
TSet<FName> MySet;
```

向集合中添加元素：

```cpp
// Add single element to the set
MySet.Add(TEXT("hello"));

// Add multiple elements to the set
MySet.Append({TEXT("cruel"), TEXT("world"), TEXT("hello")});

// MySet: { "hello", "cruel", "world" }
```

从集合中获取元素数量：

```cpp
int32 NumOfElements = MySet.Num(); // 4
```

检查元素是否存在于集合中：

```cpp
if (MySet.Contains(TEXT("cruel")))
{
    UE_LOG(LogTemp, Log, TEXT("'Cruel' element is in the set"));
}
```

从集合中移除元素：

```cpp
MySet.Remove(TEXT("cruel"));

// MySet: { "hello", "world" }
```

遍历集合并记录每个元素：

```cpp
for (const FName& Name : MySet)
{
    UE_LOG(LogTemp, Log, TEXT("Name: %s"), *Name.ToString());
}
```

将集合转换为数组：

```cpp
TArray<FName> CopyOfSet = MySet.Array();
CopyOfSet[0] = TEXT("goodbye");

// CopyOfSet: { "goodbye", "world" }
```

#### TMap

一个键值对的映射，实现为哈希表。它允许根据键快速查找值，并支持添加、删除和遍历键值对。

**这是一个示例：**

包含头文件：

```cpp
#include "Containers/Map.h"
```

声明一个 `TMap` 的 `FName` （名称）到 `int32` （整数）：

```cpp
TMap<FName, int32> MyMap = { { TEXT("player_id"), 457865 }, { TEXT("player_age"), 35 } };

// MyMap: { { "player_id", 457865 }, { "player_age", 35 } }
```

向映射中添加元素：

```cpp
int32& PlayerRankRef = MyMap.Add(TEXT("player_rank"));
PlayerRankRef = 420;

MyMap.Add(TEXT("player_speed"), 15);

// MyMap: { { "player_id", 457865 }, { "player_age", 35 }, { "player_rank", 420 }, { "player_speed", 15 } }
```

从键中在映射中查找值。否则，创建并添加键到映射（带默认值）：

```cpp
int32& PlayerIDRef = MyMap.FindOrAdd(TEXT("player_id"));
PlayerIDRef = 001100;

// MyMap: { { "player_id", 001100 }, { "player_age", 35 }, { "player_rank", 420 }, { "player_speed", 15 } }
```

获取映射中的元素数量：

```cpp
int32 NumOfElements = MyMap.Num(); // 4
```

遍历映射并记录键值对：

```cpp
for (const TPair<FName, int32>& KeyValuePair : MyMap)
{
    UE_LOG(LogTemp, Log, TEXT("Key: %s, Value: %i"), *KeyValuePair.Key.ToString(), KeyValuePair.Value);
}
```

检查"player\_rank"是否存在于映射中，如果存在则记录其值：

```cpp
if (int32* PlayerRankPtr = MyMap.Find(TEXT("player_rank")))
{
    UE_LOG(LogTemp, Log, TEXT("Player rank is: %i"), *PlayerRankPtr);
}
```

访问映射中的元素：

```cpp
int32 OutSpeed;

if (MyMap.TryGetValue(TEXT("player_speed"), OutSpeed))
{
    UE_LOG(LogTemp, Log, TEXT("Player's speed: %i [m/s]"), OutSpeed);
}
```

修改地图中的元素：

```cpp
MyMap[TEXT("player_age")] = -1;

// MyMap: { { "player_id", 001100 }, { "player_age", -1 }, { "player_rank", 420 }, { "player_speed", 15 } }
```

从地图中删除元素：

```cpp
MyMap.Remove(TEXT("player_age")); // Reference variables (such as PlayerRankRef and PlayerIDRef) become unsafe since the map size and elements have changed.

// MyMap: { { "player_id", 001100 }, { "player_rank", 420 }, { "player_speed", 15 } }
```

将地图转换为键值对数组：

```cpp
TArray<TPair<FName, int32>> KeyValueArray = MyMap.Array();
int32 PlayerID = KeyValueArray[0].Value; // 001100
```

#### 常用和有用的函数

使用这些容器，你可以使用几个有用的函数。

*   `Empty()` - 清空存储元素（同时将缓冲区大小调整为零）。
*   `Reset()` - 清空存储元素（不调整缓冲区大小）。
*   `GetSlack()` - 获取存储元素数量减去其缓冲区大小。 `Slack = NumOfElements - BufferCapacity` 。
*   `GetAllocationSize()` - 获取缓冲区容量。
*   `Shrink()` - 它将重置缓冲区大小为当前存储的元素数量。
*   `Reserve()` - 它将扩展缓冲区大小到该数量。注意，缓冲区大小之后可能会改变。
*   `RemoveAll` - 将移除所有预测作为参数的元素。
*   `RemoveAllSwap` - 与 `RemoveAll()` 函数相同，但不保持顺序。

这里有一个例子：

```cpp
#include "Containers/Array.h"

TArray<int32> Array = { 1, 2, 2, 3, 4, 4, 5 };

// Create a lamba function (which is a temporary function, which takes this class as reference parameter)
Array.RemoveAll([&](const int32& Item)
{
    // Removes all item, if the item is equal to: 2
    return Item == 2;
});

// Current elements: { 1, 3, 4, 4, 5 }

Array.RemoveAllSwap([&](const int32& Item)
{
    // Removes all item, if the item is equal to: 2
    return Item == 4;
});

// Current elements: { 5, 3, 1 }
```

```cpp
#include "Containers/Array.h"

TArray<int32> Array;
Array.Add(1);
Array.Add(2);

// Current element count: 2
// Current buffer size: 4

Array.Empty();

// Current element count: 0
// Current buffer size: 0

Array.Add(1);
Array.Add(2);

// Current element count: 2
// Current buffer size: 4

Array.Reset();

// Current element count: 0
// Current buffer size: 4
```

```cpp
TArray<int32> Array;
Array.Add(1);
Array.Add(2);
Array.Add(3);
Array.Add(4);
Array.Add(5);

// Current element count: 5
// Current buffer size: 22

int32 SlackAmount = Array.GetSlack(); // 22 - 5 = 17 (Slack = BufferCapacity - NumOfElements)

Array.RemoveAt(0);
Array.RemoveAt(1);

// Current element count: 3
// Current buffer size: 22

Array.Shrink();

// Current element count: 3
// Current buffer size: 4
```

* * *

为了移除一个元素而不允许容器缩小，你可以使用这些参数：

```cpp
#include "Containers/Array.h"

TArray<int32> Array { 1, 2, 3 };

// Removes the last element, without enable the container to shrink itself.
int32 LastElementIndex = Array.Num() - 1;
int32 NumToRemove = 1;
bool bAllowShrinking = false;
Array.RemoveAt(LastElementIndex, NumToRemove, bAllowShrinking)
```

* * *

容器在何时以及多少内存用于未来的使用情况？

如果你运行一个 for 循环并启动调试器，我们可以分析分配的大小以及容器请求更多内存时的断点位置。

```cpp
#include "Containers/Array.h"

void UpdatingAllocationSize()
{
    TArray<int32> Array;

    int32 PreviousAllocatedSize = Array.GetAllocatedSize();

    for (int32 i = 0; i < 100; ++i)
    {
        Array.Add(69);

        int32 NewAllocatedSize = Array.GetAllocatedSize();

        if (PreviousAllocatedSize != NewAllocatedSize)
        {
            UE_LOG(LogTemp, Log, TEXT("[%s - %s]: Allocation size has changed from: %i to: %i. Current number of elements: %i and current max size: %i"), ANSI_TO_TCHAR(__FUNCTION__), TEXT("Adding"), PreviousAllocatedSize, NewAllocatedSize, Array.Num(), NewAllocatedSize / sizeof(int32));

            PreviousAllocatedSize = NewAllocatedSize;
        }
    }

    // Allocation size is data size times buffer size.

    // Int32 is 4 bytes in size
    // And the buffer size is currently at 4.

    // Allocation size = 4 * 4 = 16 bytes

    /*
        LogTemp: Allocation size has changed from: 0 to: 16. Current number of elements: 1 and current max size: 4
        LogTemp: Allocation size has changed from: 16 to: 88. Current number of elements: 5 and current max size: 22
        LogTemp: Allocation size has changed from: 88 to: 188. Current number of elements: 23 and current max size: 47
        LogTemp: Allocation size has changed from: 188 to: 328. Current number of elements: 48 and current max size: 82
        LogTemp: Allocation size has changed from: 328 to: 520. Current number of elements: 83 and current max size: 130
    */

    for (int32 i = 0; Array.Num() != 0; ++i)
    {
        Array.RemoveAt(Array.Num() - 1);

        int32 NewAllocatedSize = Array.GetAllocatedSize();

        if (PreviousAllocatedSize != NewAllocatedSize)
        {
            UE_LOG(LogTemp, Log, TEXT("[%s - %s]: Allocation size has changed from: %i to: %i. Current number of elements: %i and current max size: %i"), ANSI_TO_TCHAR(__FUNCTION__), TEXT("Removing"), PreviousAllocatedSize, NewAllocatedSize, Array.Num(), NewAllocatedSize / sizeof(int32));

            PreviousAllocatedSize = NewAllocatedSize;
        }
    }

    /*
        LogTemp: Allocation size has changed from: 520 to: 260. Current number of elements: 65 and current max size: 65
        LogTemp: Allocation size has changed from: 260 to: 0. Current number of elements: 0 and current max size: 0
    */
}
```

#### Algo 命名空间

Algo 是一个包含许多容器辅助函数的命名空间。

这里是一些常用函数：

*   `Algo::Accumulate()` - 对一个范围求和。
*   `Algo::AllOf()` - 检查范围内每个元素的投影是否为真。
*   `Algo::AnyOf()` - 检查范围内至少有一个元素的投影为真。
*   `Algo::BinarySearch()` - 返回范围内第一个匹配指定值的元素的索引，该范围必须按 `<` 排序。
*   `Algo::BinarySearchBy()` - 与 `Algo::BinarySearch()` 相同，但具有自定义逻辑。
*   `Algo::Compare()` - 使用 operator== 比较两个相邻容器的元素对。
*   `Algo::CompareByPredicate()` - 使用谓词比较两个相邻容器的元素对。
*   `Algo::Copy()` - 将一个范围复制到容器中。
*   `Algo::CopyIf()` - 条件复制一个范围内的元素到容器中。
*   `Algo::Count()` - 统计范围内等于指定值的元素数量。
*   `Algo::CountBy()` - 统计范围内投影等于指定值的元素数量。
*   `Algo::CountIf()` - 统计范围内匹配给定谓词的元素数量。
*   `Algo::Find()` - 返回范围内第一个等于给定值的元素的指针。
*   `Algo::FindBy()` - 返回范围内其投影等于给定值的元素的指针。
*   `Algo::FindLast()` - 返回范围内最后一个等于给定值的元素的指针。
*   `Algo::FindLastBy()` - 返回范围内其投影等于给定值的最后一个元素的指针。
*   `Algo::FindSequence()` - 在另一个序列中搜索元素序列的第一个出现。
*   `Algo::ForEach()` - 对范围内的每个元素调用可调用对象。
*   `Algo::Includes()` - 通过比较元素对来检查一个有序连续容器是否是另一个有序连续容器的子序列。
*   `Algo::IndexOf()` - 返回范围内第一个等于给定值的元素的索引。
*   `Algo::IndexOfByPredicate()` - 返回范围内第一个匹配谓词的元素的索引。
*   `Algo::IsSorted()` - 测试范围是否按其元素类型的操作符 `<` 排序。
*   `Algo::MaxElement()` - 返回范围内最大元素的指针。
*   `Algo::MinElement()` - 返回范围内最小元素的指针。
*   `Algo::NoneOf()` - 检查范围内没有元素为真。
*   `Algo::Sort()` - 对范围进行排序。默认使用 `<` 操作符（升序）。但是可以添加自定义逻辑。
*   `Algo::SortBy()` - 与 `Algo::Sort` 相同，但使用投影方法。投影是针对值的转换。
*   `Algo::RandomShuffle()` - 随机打乱范围内的元素。
*   `Algo::RemoveIf()` - 将所有不满足谓词的元素移到范围内的前面，而将其他元素置于一个构造但未指定的状态。
*   `Algo::Replace()` - 将所有与一个值相等比较的元素替换为一个新的值。
*   `Algo::ReplaceIf()` - 将所有满足谓词的元素替换为给定的值。
*   `Algo::Reverse()` - 反转一个范围。
*   `Algo::Transform()` - 将转换应用于一个范围并将结果存储到容器中。

你可以在 Unreal 的文档中了解更多关于 Algo 的信息。

这里是一个使用它们的示例：

```cpp
#include "Algo/ForEach.h"
#include "Algo/Accumulate.h"
#include "Algo/IndexOf.h"

TArray<FString> Array;
Array.Add(TEXT("hello"));
Array.Add(TEXT("cRuEL"));
Array.Add(TEXT("WORLD"));

const int32 FoundIndex = Algo::IndexOf(Array, FString(TEXT("cRuEL")));

if (FoundIndex != INDEX_NONE)
{
    // Successfully found the index
}

const int32 FoundIndexPred = Algo::IndexOfByPredicate(Array,
    [&](const FString& Arg)
    {
        return TEXT("hello") == Arg.ToLower();
    });

if (FoundIndexPred != INDEX_NONE)
{
    // Successfully found the index with prediction
}

TArray<FString> TransformArray;

Algo::Transform(Array, TransformArray, [](const FString& Item) { return Item.ToUpper(); });

// { "HELLO", "CRUEL", "WORLD" }

Algo::Reverse(TransformArray);

// { "WORLD", "CRUEL", "HELLO" }

TArray<int32> SortArray { 1, 5, 3, -4, 2, -1 };
Algo::Sort(SortArray);

// { -4, -1, 1, 2, 3, 5 }

// Create a lambda function for this projection
auto AbsProjection = [](int32 Value) { return FMath::Abs(Value); };

// Will sort based on this projection. But will still reserve the original values.
Algo::SortBy(SortArray, AbsProjection);

// { -1, 1, 2, 3, -4, 5 }

Algo::ForEach(SortArray, [](int32& Value)
{
    Value *= 2;
});

// { -2, 2, 4, 6, -8, 10 }

// Will sort based on descending order
auto ReverseSortPredicate = [](int32 A, int32 B) { return A > B; };
Algo::SortBy(SortArray, AbsProjection, ReverseSortPredicate);

// { 10, -8, 6, 4, 2, -2 }
```

#### TMultiMap

与 `TMap` 类似，但允许多个值与同一个键关联。它还提供了遍历特定键关联的所有值的函数。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/Map.h"
```

声明一个 `FName` （名字）到浮点数的 `TMultiMap` ：

```cpp
TMultiMap<FName, float> MyMultiMap = { { TEXT("X"), 10.0f }, { TEXT("Y"), 69.0f }, { TEXT("Z"), 0.0f } }
```

向映射中添加元素：

```cpp
MyMultiMap.Add(TEXT("X"), -10.0f);
MyMultiMap.Add(TEXT("Y"), 69.0f);
MyMultiMap.AddUnique(TEXT("Y"), 69.0f); // Will not add if both key and value match an existing association in the map!

// MyMultiMap: { { TEXT("X"), 10.0f }, { TEXT("Y"), 69.0f }, { TEXT("Z"), 0.0f }, { TEXT("Y"), 69.0f }, { TEXT("X"), -10.0f } }
```

获取映射中指定键的所有值：

```cpp
TArray<float> OutValues;
MyMultiMap.MultiFind(TEXT("Y"), OutValues);

// OutValues: { 69.0f, 69.0f }
```

获取多值映射中的元素数量：

```cpp
int32 NumOfElements = MyMultiMap.Num(); // 5
```

遍历值并记录每一个：

```cpp
for (const float& Value : OutValues)
{
    UE_LOG(LogTemp, Log, TEXT("Value: %f"), Value);
}
```

移除映射中指定键的所有值：

```cpp
MyMultiMap.Remove(TEXT("Y"));

// MyMultiMap: { { TEXT("X"), 10.0f }, { TEXT("Z"), 0.0f }, { TEXT("X"), -10.0f } }
```

从指定的键和值中移除第一个关联项：

```cpp
MyMultiMap.RemoveSingle(TEXT("X"), 10.0f);

// MyMultiMap: { { TEXT("Z"), 0.0f }, { TEXT("X"), -10.0f } }
```

你可以在 Unreal 的文档中了解更多信息。

<Callout type="warn"> Unreal 不支持 `TMultiMap` 与 UHT [3](#user-content-fn-2) 。这意味着你不能将其暴露给蓝图。</Callout>

#### TStaticArray

一个具有静态元素数量的数组。

您不能添加或删除静态数组中的任何条目。但您仍然可以更改每个元素的数据。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/StaticArray.h"
```

声明一个 `TStaticArray` 的 `int32` （整数），预分配 4 个元素：

```cpp
// Allocate 4 elements of type 'FVector'
TStaticArray<FVector, 4> StaticArray;

// StaticArray: { (0, 0, 0), (0, 0, 0), (0, 0, 0), (0, 0, 0) }
```

您不能使用花括号初始化 `TStaticArray` :

```cpp
TStaticArray<int32, 4> StaticArray { 1, 2, 3, 4 }; // Won't compile!
```

更新每个元素的值：

```cpp
StaticArray[0] = FVector::OneVector;
StaticArray[1] = FVector::ZeroVector;
StaticArray[2] = FVector::OneVector;
StaticArray[3] = FVector::ZeroVector;

// StaticArray: { (1, 1, 1), (0, 0, 0), (1, 1, 1), (0, 0, 0) }
```

从静态数组中获取元素数量：

```cpp
int32 NumOfElements = StaticArray.Num(); // 4
```

遍历值并记录每个值：

```cpp
for (const FVector& Vec : StaticArray)
{
    UE_LOG(LogTemp, Log, TEXT("Value: %s"), *Vec.ToString());
}
```

你可以在 Unreal 的文档中了解更多信息。

<Callout type="warn"> Unreal Engine 不支持 `TStaticArray` 与 UHT [3](#user-content-fn-2) 。这意味着你不能将其暴露给蓝图。要在蓝图中使用静态数组，请在 `TArray` 属性上使用 `FixedSized` 指定符。</Callout>

#### FHashTable

动态大小的哈希表，用于索引其他数据结构。比 `TMap` 简单且快得多。

**这是一个示例：**

包含头文件：

```cpp
#include "Containers/HashTable.h"
```

定义一个 `FHashTable` :

```cpp
FHashTable HashTable;
```

向表中添加一个新的哈希元素：

```cpp
const uint16 Hash = 50u;
const uint16 Index = 10u;

HashTable.Add(Hash, Index);
```

你可以在虚幻引擎的文档中了解更多信息。

#### TStaticHashTable

静态大小哈希表，用于索引其他数据结构。比 `TMap` 简单且快得多。

**这里是一个示例：**

包含头文件：

```cpp
#include "Containers/HashTable.h"
```

定义一个 `TStaticHashTable` :

```cpp
static const uint32 Capacity = 16u;
TStaticHashTable<1024u, Capacity> StaticHashTable;
```

向表中添加一个新的哈希元素：

```cpp
const uint16 Hash = 50u;
const uint16 Index = 10u;

StaticHashTable.Add(Hash, Index);
```

你可以在 Unreal 的文档中了解更多信息。

#### TSortedMap

一个键到值的映射，实现为排序的 `TArray` TPairs。

它和 `TMap` 的界面几乎完全相同，设计为可替换的组件。键必须唯一，没有 `TMultiMap` 的等效排序版本。它使用的内存量只有 `TMap` 的一半，但添加和删除元素的时间复杂度为 O(n)，查找的时间复杂度为 O(Log n)。实际上，对于元素数量较少时，它的速度比 `TMap` 快，但随着 n 的增加，速度会变慢。这个映射始终按键类型保持排序，因此不能手动排序。

**这里有一个例子：**

包含头文件：

```cpp
#include "Containers/SortedMap.h"
```

创建一个 `TSortedMap` 的 `FName` （名称）到 `int32` （整数）的映射：

```cpp
TSortedMap<FName, int32> MyMap;
```

向映射中添加一些元素：

```cpp
MyMap.Add(TEXT("One"), 1);
MyMap.Add(TEXT("Two"), 2);
MyMap.Add(TEXT("Three"), 3);
```

获取与键关联的值：

```cpp
int32 Value = MyMap[TEXT("One")];
```

检查键是否存在于映射中：

```cpp
bool Exists = MyMap.Contains(TEXT("One"));
```

遍历映射并记录每个元素：

```cpp
for (const TPair<FName, int32>& Element : MyMap)
{
    UE_LOG(LogTemp, Log, TEXT("Key: %s, Value: %i"), *Element.Key.ToString(), Element.Value);
}
```

你可以在 Unreal 的文档中了解更多信息。

#### TList

简单的单链表模板。

它只存储两件事：

```cpp
ElementType			Element; // Value
TList<ElementType>* Next; // Pointer to the next node
```

适用于路径查找、二叉树搜索或对话树系统等场景。

一个链表相比于数组有一些优势，主要在于它在添加和删除元素时具有 O(1)的时间复杂度。这是因为每个节点都指向链表中的下一个节点。因此，链表在添加和删除元素时的时间复杂度为 O(1)。

你可以通过 Joel Olawanle 了解更多关于时间复杂度的信息。

使用数组相比于链表有一些缺点：

<table><tbody><tr><td>缓存未命中 当计算机读取内存时，它从 RAM（随机存取存储器）中读取。因此，它的名称是随机访问内存。使用 TArray ，你的内存分配是连续的。这意味着 TArray 将请求一个大的空间来存放其内存块。 然而，如果 TArray 找不到或无法适应一个特定的位置（因为 TArray 可以增长和缩小），它需要重新计算并找到一个新的位置。这使得添加或删除元素变得令人烦恼。 但 TArray 拥有的东西是链表所缺乏的，那就是缓存命中。缓存命中是一个术语，其中 CPU 可以将一个数组预加载到 CPU 缓存内存中。因为数组存储在连续的内存中，允许 CPU 预加载整个数组，而无需在内存位置之间来回跳转。 对于链表来说，没有连续的内存。这意味着 CPU 需要在不同位置找到每个节点。这不允许 CPU 将其先前结果缓存到内存中。这就称为缓存未命中。 来自 Dhathri Vupparapalli 博客的图片。 这是 SimonDev 关于缓存未命中和命中的视频。 你还可以在维基百科上了解更多关于 CPU 缓存的信息。 内存空间 TList 每个节点占用更多的内存空间。 因为每个节点都需要跟踪列表中的下一个节点。而下一个变量是一个指针，它在 32 位计算机上占用 4 个字节，在 64 位计算机上占用 8 个字节。 如果你只想使用基本数据类型，例如 ( int , float , double , bool 或 char )，那么你可以直接使用 TArray 。虽然 TArray 存储了一些开销，但这个开销非常小。 没有辅助函数 TList 仅提供数据元素和下一个节点的指针。 TList 不提供任何在列表中添加或删除节点的辅助函数。 如果您希望拥有这些函数，那么您可以直接使用 TLinkedList 。 只能向前遍历。 使用 TList 时，你只能向前移动。 这是因为每个节点都没有前一个节点。也就是说，你不能在列表中向后移动。 如果你想要向后移动，那么你只需要使用 TDoubleLinkedList 即可。</td></tr></tbody></table>

**这里有一个例子：**

包含头文件：

```cpp
#include "Containers/List.h"
```

```cpp
// Create the head of the list with data value of 69
TList<int32> Head(69);

// Create a new node with data 1337 and link it to the head
Head.Next = new TList<int32>(1337);

// Create another node with data 3 and link it to the previous node
Head.Next->Next = new TList<int32>(3);

// Re-assign the data value
Head.Next->Next->Next.Element = 420;

// Print the elements in the linked list
TList<int32>* CurrentNode = &Head;

while (CurrentNode != nullptr)
{
    UE_LOG(LogTemp, Log, TEXT("Element: %i"), CurrentNode->Element);
    CurrentNode = CurrentNode->Next;
}
```

<Callout> `TList` 不为每个节点提供插入或删除功能。如果您希望使用这些功能，请使用 `TLinkedList` 。</Callout>

<Callout> 一般来说，您几乎总是应该使用 `TArray` ，除非您有使用链表的具体原因。</Callout>

您可以在虚幻引擎的文档中了解更多信息。

#### TLinkedList

封装一个链接在单个链表中，具有恒定访问时间。

这个链表是非侵入式的，即它存储传递给它的元素的一个副本（通常是指针）

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/List.h"
```

定义一个 `TLinkedList` 的 `int32` （整数）：

```cpp
TLinkedList<int32> HeadNode;
```

使用 `TIterator` 遍历链表：

```cpp
for (TLinkedList<int32>::TIterator It(&HeadNode); It; It.Next())
{
    // Get the value at the current position of the iterator
    int32 Value = *It;

    // Log the value.
    UE_LOG(LogTemp, Log, TEXT("Value: %i"), Value);
}
```

你可以在 Unreal 的文档中了解更多信息。

#### TDoubleLinkedList

它只存储三件事：

```cpp
ElementType            Value;
TDoubleLinkedListNode* NextNode;
TDoubleLinkedListNode* PrevNode;
```

**这是一个示例：**

包含头文件：

```cpp
#include "Containers/List.h"
```

定义一个 `TDoubleLinkedList` 的 `int32` （整数）：

```cpp
TDoubleLinkedList<int32> A;
```

将节点添加到列表的头/尾：

```cpp
A.AddHead(69);
A.AddTail(1337);
```

获取列表中元素的数量：

```cpp
int32 NumOfElements = A.Num();
```

检查列表是否包含值 5：

```cpp
bool bContains = A.Contains(5);
```

在列表中找到一个值为 1 的节点：

```cpp
TDoubleLinkedList<int32>::TDoubleLinkedListNode* Node = A.FindNode(1);

// Log the value of the found node
if (Node != nullptr)
{
    UE_LOG(LogTemp, Log, TEXT("Value of the node: %i"), Node->GetValue());
}
else
{
    UE_LOG(LogTemp, Log, TEXT("Node with value 1 not found."));
}
```

获取列表中的下一个节点和上一个节点：

```cpp
TDoubleLinkedList<int32>::TDoubleLinkedListNode* NextNode = Node->GetNextNode();
TDoubleLinkedList<int32>::TDoubleLinkedListNode* PrevNode = Node->GetPrevNode();

// Log the values of the next and previous nodes
if (NextNode != nullptr)
{
    UE_LOG(LogTemp, Log, TEXT("Value of the next node: %i"), NextNode->GetValue());
}
else
{
    UE_LOG(LogTemp, Log, TEXT("Next node is null."));
}

if (PrevNode != nullptr)
{
    UE_LOG(LogTemp, Log, TEXT("Value of the previous node: %i"), PrevNode->GetValue());
}
else
{
    UE_LOG(LogTemp, Log, TEXT("Previous node is null."));
}
```

你可以在 Unreal 的文档中了解更多信息。

#### TQueue

这个模板实现了一个无界非侵入式队列，使用无锁链表存储队列项的副本。该模板可以在两种模式下运行：多生产者单消费者（MPSC）和单生产者单消费者（SPSC）。

该队列在两种模式下都是线程安全的。 `Dequeue()` 方法通过一种不依赖于 CPU 可能发生的指令重排的方式来编写，从而确保线程安全。 `Enqueue()` 方法在多生产者场景中使用原子比较并交换。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/Queue.h"
```

定义一个 `TQueue` 的 `FHitResult` （命中结果）：

```cpp
TQueue<FHitResult> MyQueue;
```

向队列中添加一些元素：

```cpp
AActor* TargetActor = this;
UPrimitiveComponent* TargetComponent = this;
FVector HitLocation = FVector(900.0f, 0.0f, 500.0f);
FVector HitNormal = FVector(0.0f, 0.0f, 1.0f);

MyQueue.Enqueue(FHitResult(TargetActor, TargetComponent, HitLocation, HitNormal));
MyQueue.Enqueue(FHitResult(nullptr, nullptr, FVector::ZeroVector, FVector::OneVector.GetSafeNormal()));
```

从队列中出队第一个元素：

```cpp
FHitResult DequeuedElement = MyQueue.Dequeue();
```

检查队列是否为空：

```cpp
bool IsEmpty = MyQueue.IsEmpty();
```

遍历队列：

```cpp
while (!MyQueue.IsEmpty())
{
    FHitResult HitResult = MyQueue.Dequeue();

    UE_LOG(LogTemp, Log, TEXT("Hit Target: %s"), *HitResult.GetActor()->GetName());
}
```

你可以在 Unreal 的文档中了解更多信息。

#### TArrayView

当你想要重用数组而不进行复制或引用基类时，你可以使用 `TArrayView` 。

一个静态大小的元素数组视图。设计用于允许函数在函数既不添加也不删除元素时，将固定大小的 C 风格数组或 `TArray` 与任意分配器作为参数传入。

您可以从 Unreal 的文档中了解更多信息。

这里有一个示例：

```cpp
#include "Containers/Array.h"
#include "Containers/ArrayView.h"

#include "Algo/ForEach.h"
#include "Algo/Accumulate.h"

int32 SumArray(TArrayView<const int32> ArrayView)
{
    // Sum the array
    return Algo::Accumulate(ArrayView, 0);
}

// Allocates on heap, but returns an array on the stack
TArray<int32> RegularArray = { 1, 2, 3 };

 // Allocates on the stack
TArray<int32, TInlineAllocator<4>> StackAllocatedArray = { 1, 2, 3 };

 // Allocates on the stack
int32 CArray[4] = { 1, 2, 3 };

UE_LOG(LogTemp, Log, TEXT("Sum=%i"), SumArray(RegularArray));

UE_LOG(LogTemp, Log, TEXT("Sum=%i"), SumArray(StackAllocatedArray));

UE_LOG(LogTemp, Log, TEXT("Sum=%i"), SumArray(CArray));
```

<Callout type="warn"> `TArrayView` 是一个固定大小且独立的数组。这意味着它不会影响其原始分配，也不支持 Add()或 Remove()函数。</Callout>

<Callout> 仍然可以使用 Algo 库，它提供了用于 TArrayView 和 TArray 的函数，例如 Algo::Reverse() 和 Algo::ForEach()。</Callout>

<Callout type="error"> 避免将 `TArrayView` 与临时数组变量一起使用。因为数组可能会超出作用域，这将使 `TArrayView` 变量无效并指向不同的内存块。这是因为视图依赖于数组的内存块。</Callout>

```cpp
#include "Containers/ArrayView.h"

// Note how to mark an ArrayView const!
void ConstArrayView()
{
    TArray<int32> MutableArray;
    TArrayView<int32> ArrayView = MutableArray;
    TArrayView<const int32> ConstArrayView = MutableArray;

    ArrayView[0] = 1337; // Allowed!
    ConstArrayView[0] = 69; // Compiling error!
}

// Do not create an array view to a temporary variable, as this can cause issues!
void UnsafeArrayView()
{
    // Create Array view with temporary TArray
    TArrayView<const int32> UnsafeArray = TArray<int32> { 1, 2, 3 };

    // This memory block has likely been freed, but the array view doesn't know about it!
    int32 Value = UnsafeArray[0]; // This will cause a crash!
}

// Do not modify the array while the array view is in scope! Array view is independent from the array.
void ModifyArrayView()
{
    TArray<int32> Array { 1, 2, 3 };
    TArrayView<int32> ArrayView = Array;

    int32 PreviousValue = ArrayView[0];

    Array.RemoveAt(0); // Will not update array view!

    int32 NewValue = ArrayView[0];

    bool bIsSame = PreviousValue == NewValue; // Will return true!
}
```

#### 字符串视图

`FStringView` 是一个轻量级、非拥有的字符串数据视图，复制视图本身是高效的，并且不会影响底层数据。但是，当你复制 `FStringView` 时，新的视图实例仍然引用相同的原始字符串数据。

与 `TArrayView` 相同的概念，但使用 `FString` 。

这里有一个例子：

```cpp
#include "Containers/UnrealString.h"

void ProcessString(FStringView StringView)
{
    // Use FStringView to read the string data without copying it.
    UE_LOG(LogTemp, Log, TEXT("String: %s"), *StringView);
}

FString MyString = TEXT("Hello, FStringView!");

// Pass FString as FStringView to the function without copying the data.
ProcessString(MyString);

// Copy FStringView to another variable.
FStringView CopiedStringView = MyString;

// Modifying the original FString does not affect the copied FStringView.
MyString = TEXT("Modified String");

// Print the contents of the copied FStringView.
UE_LOG(LogTemp, Log, TEXT("Copied StringView: %s"), *CopiedStringView);
```

你可以在 Unreal 的文档中了解更多信息。

#### 字符串构建器

在处理字符串时，你可能需要将很多字符串拼接在一起。有时，这会创建复杂且难以阅读的代码。而 `FString` 是可变的，允许开发者在不复制新实例的情况下修改其数据。字符串构建器仍然是一个非常有用的工具。

字符串构建器分配一个缓冲区空间，用于存储构建的字符串。其意图是让构建器作为函数局部变量在栈上分配，以避免堆分配。

缓冲区始终是连续的，该类不打算用于构建极长的字符串。

这并非用于长时间保留字符串的机制。其使用场景明确是为了在栈上构建字符串，并随后将字符串传递给函数调用或更持久的字符串存储机制，如 `FString` 等。

分配的缓冲区空间大小通过模板参数指定，如果构建的字符串超出初始缓冲区，将使用常规动态内存分配分配新的缓冲区。

* * *

构建字符串构建器有两种方式。要么使用已初始化的缓冲区大小，要么使用未知的缓冲区大小。

**这里有一个示例：**

包含头文件：

```cpp
#include "Containers/StringFwd.h"
```

要创建一个具有未知缓冲区大小的字符串构建器：

```cpp
FStringBuilderBase StringBuilder; // Note! This is using a regular dynamic memory allocation.
```

创建具有初始化缓冲区大小的字符串构建器：

```cpp
int32 BufferSize = 12; // 12 characters of TCHAR
TStringBuilder<BufferSize> StringBuilder;
```

向字符串构建器追加字符：

```cpp
StringBuilder.Appendchar('H');
StringBuilder.Appendchar('e');
StringBuilder.Appendchar('l');
StringBuilder.Appendchar('l');
StringBuilder.Appendchar('o');
StringBuilder.Appendchar(',');
StringBuilder.Appendchar(' ');
StringBuilder.Appendchar('W');
StringBuilder.Appendchar('o');
StringBuilder.Appendchar('r');
StringBuilder.Appendchar('l');
StringBuilder.Appendchar('d');

// StringBuilder: { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd' }
```

要获取字符串，可以调用 `ToString()` 或 `ToView()` 函数：

```cpp
FString Str = StringBuilder.ToString();
FStringView StrView = StringBuilder.ToView();
```

你也可以追加一个字符串：

```cpp
// Note! The string builder will allocate more memory, if necessary.

// We only allocated 12 characters, and this call will make it go over bound.
// Causing to allocate more memory on heap.
StringBuilder.Append(TEXT(" and welcome!"));

// StringBuilder: { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'l', 'c', 'o', 'm', 'e', '!' }
```

<Callout type="warn"> 如果需要，字符串构建器将分配更多内存。</Callout>

这里还有一个例子：

```cpp
TStringBuilder<256> MessageBuilder;

float PlayerHealth = 110.5285f;
MessageBuilder << TEXTVIEW("Player's health: ") << FString::SanitizeFloat(PlayerHealth);

return FString { MessageBuilder };
```

你可以在 Unreal 的文档中了解更多信息。

#### TEnumAsByte

用于以类型安全的方式将枚举值存储为字节的模板。

**这里是一个示例：**

包含头文件：

```cpp
#include "Containers/EnumAsByte.h"
```

声明一个 `TEnumAsByte` 枚举类型为 `ECollisionChannel` 的变量：

```cpp
TEnumAsByte<ECollisionChannel> Channel;
```

获取 `TEnumAsByte` 的值：

```cpp
ECollisionChannel Val = Channel.GetValue();
```

获取 `TEnumAsByte` 的整数值：

```cpp
int32 IntVal = Channel.GetIntValue();
```

为 `TEnumAsByte` 分配新值：

```cpp
Channel = ECollisionChannel::ECC_Camera;
```

记录值：

```cpp
UE_LOG(LogTemp, Log, TEXT("Value of the: %i"), UEnum::GetValueAsName(Val));
UE_LOG(LogTemp, Log, TEXT("Integer value of the: %i"), IntVal);
```

<Callout> `UPROPERTY` 支持常规枚举，并取代了使用 `TEnumAsByte` 的需求。</Callout>

你可以在虚幻引擎的文档中了解更多信息。

### 🧨 值类型 vs 引用类型

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

让我们来谈谈值类型和引用类型。

在 Python [4](#user-content-fn-11) 、Java [5](#user-content-fn-13) 和 C# [6](#user-content-fn-12) 等多种编程语言中，你可能都遇到过值类型和引用类型。

一个值类型在从另一个变量初始化时会创建一个副本。例如，让我们考虑变量 A，当我们用 A 的值初始化变量 B 时，B 中会创建一个值的独立副本。本质上，B 是一个独立实体，它持有自己的值。

```cpp
int A = 69;
int B = A; // A copy
```

另一方面，引用类型直接引用变量的内存位置。在这种情况下，当变量 B 由变量 A 初始化时，B 成为 A 相同内存位置的引用。因此，对 B 的任何更改也会影响 A，因为 B 本质上指向与 A 相同的底层值。

```cpp
int A = 69;
int& B = A; // A reference
```

在 C++中，默认情况下一切都是值类型。即使是类，也与 C# [6](#user-content-fn-12) 不同。

你可以在 Low Level Learning 上观看关于 C++中引用的视频。

这是一个示例：

```cpp
// Test struct and class
struct Coords
{
    // Constructor: Initialize X and Y with given values
    Coords(int x, int y) : X(x), Y(y) {}

public:
    int X; // X coordinate
    int Y; // Y coordinate

public:
    // Return a string representation of this Coords struct
    std::string toString() const
    {
        // Use stringstream to concatenate strings
        std::stringstream ss;
        ss << "(" << X << ", " << Y << ")";
        return ss.str();
    }
};

int main()
{
    Coords A(1, 2); // Create struct A
    Coords& B = A; // B is a reference to A
    Coords* C = &B; // C is a pointer to A
    Coords* D = new Coords(5, 10); // Create a new Coords struct with new
    Coords* E = &(*C); // E is a pointer to what C points to

    B.X = 69; // Modify X of A through B
    C->Y = 1337; // Modify Y of A through C
    D->Y = D->Y * 2; // Modify Y of dynamically allocated struct

    E = &*D; // Make E point to what D points to
    E->X = 10; // Modify X of dynamically allocated struct

    // Print statements
    std::cout << A.toString() << std::endl;
    std::cout << B.toString() << std::endl;
    std::cout << C->toString() << std::endl;
    std::cout << D->toString() << std::endl;
    std::cout << E->toString() << std::endl;

    delete D; // Deallocate memory of dynamically allocated struct

    return 0;
}
```

在引用中，你只能分配一次，并且在整个代码中不能更改。例如，你可以直接引用传递到函数中的参数。然后可以在函数内部修改这个参数，类似于 C#中的输出参数的工作方式 [6](#user-content-fn-12) 。

这是一个示例：

```cpp
bool DamageHealth(int& Health)
{
   Health -= 100; // Modifying the value through the reference
   return Health <= 0;
}

int PlayerHealth = 100;

if (DamageHealth(PlayerHealth)) // Passing the `PlayerHealth` as a direct reference
{
   // Player just died!
}
```

### 👈 指针

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

![Pointers](/static-img/Pointers.png)

最后，我们来看指针。本节将介绍原始指针和智能指针。如果你对指针一无所知，强烈建议观看 Cherno 关于指针的视频。

指针和引用相似之处在于它们都指向变量，但有一个关键区别。指针是间接引用，意味着它们可以在代码中改变，指向不同的变量。而普通引用是直接的，并且只能指向它们初始化时指定的变量。

*简而言之，指针就像在纸上写下建筑的地址。纸上的地址告诉你建筑在哪里，就像指针变量中存储的内存地址告诉你变量在内存中的位置。类似地，你也可以把纸上的地址交给别人，让他们也能找到建筑，就像你可以把指针变量传递给函数或代码的其他部分，允许它们访问内存中的变量。*

指针是编程中的宝贵工具，因为它们允许我们存储内存地址，从而实现动态内存分配和操作数据结构。通过使用指针，我们可以创建更灵活高效的代码，使程序在执行过程中能够适应不断变化的数据需求。

此外，指针在数据结构、链表以及通过引用传递数据等场景中至关重要，它们提供了一定程度的控制和精确性，从而增强了程序的功能。然而，处理指针时需要小心谨慎，因为不正确的使用可能导致内存泄漏或段错误。

#### 🦴 原始指针

原始指针有时可能很危险，因为在访问该指针时没有进行任何验证。当指针指向空值（即指针为 `nullptr` ）时，程序会抛出空指针异常，也称为段错误（segfault）。

当程序尝试访问它没有权限访问的内存位置时会发生段错误，这通常发生在程序尝试解引用空指针时。当这种情况发生时，操作系统通常会终止程序并生成错误消息。

你可以在 Microsoft Learn 上了解更多关于原始指针的信息。

为了避免这种情况，在使用指针之前，你必须先检查它是否有效。

<Callout type="warn"> 对原始指针使用名为 `IsValid()` 的函数，并对其进行任何操作。</Callout>

这里有一个示例：

```cpp
UPROPERTY()
AActor* ActorPtr = nullptr;

// Use UPROPERTY() macro, in order to tell the UHT[^2] (Unreal Header Tool), this pointer must be release into GC (garbage collector).
// If not, then this will cause a memory leak. Meaning, the pointer is still alive, even tough we are not using this memory block.

void KillActor()
{
  // IsValid() function also check if the pointer is not already destroyed by the GC (garbage collector).

  if (!IsValid(ActorPtr)) // The pointer has value of 'nullptr', therfore is NOT valid!
      return;

  ActorPtr->Destroy();
}
```

<Callout> `ActorPtr` 使用 `UPROPERTY()` 标记，以通知 UHT [3](#user-content-fn-2) 该指针存在。当指针未被使用时，垃圾收集器会将其标记并删除其内存。请注意，此过程可能需要几个帧，并非即时完成。因此，请始终使用 `IsValid()` 函数，该函数还会检查指针是否已被标记用于垃圾收集。避免使用手动检查，例如 `PlayerCharacter != nullptr` （因为它与垃圾收集系统不兼容）。</Callout>

<Callout type="warn"> 如果其他内容正在引用 `ActorPtr` ，该指针将不会通过垃圾收集被销毁（除非它是弱指针）。</Callout>

从 Unreal Engine (5.0) 版本开始，推荐使用 `TObjectPtr` 而不是 `*` 来标记原始指针。 `TObjectPtr` 类包含一些针对编辑器的优化。

这是更新后的代码：

```cpp
UPROPERTY()
TObjectPtr<AActor> ActorPtr = nullptr;
```

#### 🤖 智能指针库

在虚幻引擎中，智能指针库提供了一套模板类，用于更高效和安全地管理内存和对象所有权。这些智能指针自动处理内存管理，例如分配和释放内存，并有助于防止内存泄漏和空指针解引用。

虚幻引擎库中的关键智能指针包括 `TSharedPtr` 、 `TWeakPtr` 和 `TUniquePtr` 。它们设计用于处理各种所有权场景，并提供比原始指针更安全的替代方案。

你可以在他们的文档中了解更多关于 Unreal Smart Pointer Library 的信息。

##### TSharedPtr

`TSharedPtr` 是一个智能指针，它管理动态分配对象的共享所有权。它使用引用计数来跟踪对对象的共享引用数量，并在最后一个引用超出作用域时自动释放内存。

示例：

```cpp
TSharedPtr<int32> sharedPtr = MakeShared<int32>(42);
```

##### TWeakPtr

`TWeakPtr` 是一个智能指针，表示对动态分配对象的弱引用。只要对象存在，它允许访问该对象，但不会影响对象的引用计数。它通常用于避免循环引用问题。

示例：

```cpp
TSharedPtr<int32> sharedPtr = MakeShared<int32>(42);
TWeakPtr<int32> weakPtr = sharedPtr;
```

##### TUniquePtr

`TUniquePtr` 是一个智能指针，它表示对动态分配对象的唯一所有权。它确保只有一个指针可以拥有该对象，当拥有该对象的 `TUniquePtr` 超出作用域时，内存会自动释放。

示例：

```cpp
TUniquePtr<int32> uniquePtr = MakeUnique<int32>(42);
```

#### 🤖 智能的 `UObject` 指针

虚幻引擎的智能指针，如 `TSharedPtr` 、 `TWeakPtr` 和 `TUniquePtr` ，是通用的智能指针，可用于任何 C++ 类或类型，不仅限于虚幻引擎的 UObject 派生类。

另一方面，UObject 智能指针是 Unreal Engine 的 UObject 派生类的特定类型。这些智能指针，如 `TWeakObjectPtr` 、 `TWeakInterfacePtr` 、 `TSoftObjectPtr` 和 `TSoftClassPtr` ，旨在处理 Unreal Engine 生态系统中的 `UObject` 所有权和管理。

##### TWeakObjectPtr

这种智能指针用于持有对 `UObject` 子类的弱引用。它允许你安全地引用一个对象，而不会影响其生命周期。它通常用于防止可能创建循环依赖关系的强引用。

示例用法：

```cpp
TWeakObjectPtr<UObject> WeakPtr;

if (SomeObject.IsValid())
{
    WeakPtr = SomeObject;  // Assign weak reference to an object
}

if (WeakPtr.IsValid())
{
    // Access the object if it still exists
    WeakPtr->DoSomething();
}
```

##### TWeakInterfacePtr

这个智能指针用于持有由 `UObject` 实现的接口的弱引用。它允许你安全地引用该接口，而不会影响其生命周期。

示例用法：

```cpp
TWeakInterfacePtr<IMyInterface> WeakPtr;

if (SomeObject->Implements<IMyInterface>())
{
    WeakPtr = SomeObject;  // Assign weak reference to the interface
}

if (WeakPtr.IsValid())
{
    // Access the interface if the object still implements it
    WeakPtr->InterfaceFunction();
}
```

##### TSoftObjectPtr

这个智能指针用于持有对 `UObject` 子类的软引用。它用于引用在运行时可以加载和卸载的资源。软引用不会阻止资源被垃圾回收。

![TSoftObjectPtr](/static-img/TSoftObjectPtr_BP.png)

示例用法：

```cpp
TSoftObjectPtr<UTexture2D> SoftPtr; // Assign soft reference to a texture asset

if (SoftPtr.IsValid())
{
    UTexture2D* Texture = SoftPtr.LoadSynchronous(); // This will cause a lag spike (if the asset is heavily chained or large in size)

    if (Texture)
    {
        // Use the loaded texture
    }
}
```

异步解决方案：

```cpp
TSoftObjectPtr<UTexture2D> SoftPtr; // Assign soft reference to a texture asset

if (SoftPtr.IsValid())
{
    OnTextureLoadedDelegate.BindLambda([]()
    {
        // Called when the texture is loaded and ready to use
        UTexture2D* Texture = SoftPtr.Get();

        if (Texture)
        {
            // Use the loaded texture as needed
        }
    });

    StreamableManager.RequestAsyncLoad(SoftPtr.ToSoftObjectPath(), OnTextureLoadedDelegate);
}
```

<Callout type="warn"> 不要使用 `FSoftObjectPath` 或 `FSoftObjectPtr` 。用于内部用途。</Callout>

##### TSoftClassPtr

这个智能指针用于持有对 `UClass` 子类的软引用。它用于引用可以在运行时加载和卸载的蓝图类或其他类。

![TSoftClassPtr](/static-img/TSoftClassPtr_BP.png)

示例用法：

```cpp
TSoftClassPtr<AMyBlueprintClass> SoftPtr; // Assign soft reference to a blueprint class

if (SoftPtr.IsValid())
{
    UClass* Class = SoftPtr.LoadSynchronous(); // This will cause a lag spike (if the asset is heavily chained or large in size)

    if (Class)
    {
        // Use the loaded class
    }
}
```

异步解决方案：

```cpp
TSoftClassPtr<AMyBlueprintClass> SoftPtr; // Assign soft reference to a blueprint class

if (SoftPtr.IsValid())
{
    OnBlueprintLoadedDelegate.BindLambda([]()
    {
        // Called when the blueprint class is loaded and ready to use
        UClass* BlueprintClass = SoftPtr.Get();

        if (BlueprintClass)
        {
            // Use the loaded blueprint class as needed
            AMyBlueprintClass* NewActor = GetWorld()->SpawnActor<AMyBlueprintClass>(BlueprintClass);

            if (NewActor)
            {
                // Successfully spawned the actor based on the loaded blueprint class
            }
        }
    });

    StreamableManager.RequestAsyncLoad(SoftPtr.ToSoftObjectPath(), OnBlueprintLoadedDelegate);
}
```

<Callout type="warn"> 不要使用 `FSoftClassPath` 。旧代码。 </Callout>

* * *

| 智能指针 | 基于类型的 | 描述 |
| --- | --- | --- |
| TSharedPtr | 常规 C++类 | 用于管理动态分配对象所有权的共享指针。允许多个指针共享所有权。 |
| TWeakPtr | 常规 C++类 | 弱指针，用于非拥有引用动态分配的对象。 |
| TUniquePtr | 常规 C++类 | 唯一指针，用于独占拥有动态分配的对象。确保只有一个指针拥有该对象。 |
| TWeakObjectPtr | UObject Classes | 弱指针，用于非拥有引用的 UObject 派生对象。 |
| TWeakInterfacePtr | UObject Classes | 弱指针，用于非拥有引用的特定接口实现对象。 |
| TSoftObjectPtr | UObject Classes | 用于非拥有引用 UObject 派生对象的软指针。允许在需要时加载对象，但不会阻止它被垃圾回收。 |
| TSoftClassPtr | UObject Classes | 软指针，用于非拥有引用的 UClass 派生对象。允许在需要时加载类，但不会阻止它被垃圾回收。 |

### 🔖 关键字

在 C++中，关键字是编译器具有特殊含义的保留字。关键字不能用作代码中变量、函数或其他标识符的名称。

C++中的关键字用于定义程序的结构和行为。它们用于声明变量、函数、类和其他类型的标识符。它们还控制程序的执行流程，例如使用 `if` 、 `for` 和 `switch` 语句。

#### 常量

*   `const` - 指定对象或成员为只读且不能被修改。也就是说，它们是不可变的。

*   `constexpr` - 指定一个函数或成员可以在编译时进行评估。 `constexpr` 可用于在不需要使用宏的情况下内联变量 [7](#user-content-fn-4) 。注意，编译器不保证编译时评估（仅它可以在编译时被评估）。

*   `consteval` - 指定一个函数必须在编译时进行评估。注意，它仅适用于函数，并且编译器必须在编译时进行评估。

*   `constinit` - 指定一个变量只能用常量表达式进行初始化。


```cpp
int Add(const int& a, const int& b)
{
    a++; // Compiling error!
    return a + b;
}
```

```cpp
// Will be compiled at runtime
const float PI = 3.14f;

// Can be compiled at compile-time
constexpr double PI_DOUBLE = 3.14159265359;
```

您也可以使用 `constexpr` 关键字为函数，这样它可以直接用于其他操作中（因为它可以在编译时编译）：

`constexpr` 和宏有什么区别呢？

> 宏不会提供任何语法错误的保护，也不会为代码提供高亮支持。这意味着追踪错误和问题以及维护代码会更加危险。因此，更推荐使用 `constexpr` 关键字为成员和函数，这将生成一个"真正"的常量值。

```cpp
constexpr int getSizeOfAnArray()
{
    return 5;
}

int array[getSizeOfAnArray()]; // array has 5 elements
```

<Callout> 如果你希望在编译时获得一个"真正"的常量值，并且不期望编译器有任何处理，你可以使用 `consteval` 关键字。这会强制编译器在编译时编译你的代码。</Callout>

```cpp
consteval int getSizeOfAnArray()
{
    return 10;
}

int array[getSizeOfAnArray()]; // array has 10 elements

// Will be compiled at compile-time
// NOTE! It is also context-sensitive.
constinit int sizeOfAnArray = getSizeOfAnArray();
```

<Callout type="warn"> `consteval` 和 `constinit` 关键字仅在 C++ 20 版本中受支持。这意味着如果你的编译器不支持这些关键字，你将无法使用它们。 </Callout>

<Callout> Unreal Engine 现在支持 C++ 版本 20。</Callout>

```cpp
// Example of using constinit keyword
struct Data
{
    constinit const int i = 10;
    constinit static int j = 20;
};

static_assert(Data::j == 20);
```

这里有一个视频，由 Cazz 解释 C++ 中常量关键字的作用。

#### 访问修饰符

*   `public` - 该成员对任何可以看到该类的代码都是可访问的。
*   `protected` - 该成员可在声明它的类及其派生类中访问。
*   `private` - 该成员只能在声明它的类内部访问。

以下是一个访问修饰符的实现示例：

```cpp
class VehicleBase
{
public:
    int public_member = 10;

protected:
    int protected_member = 20;

private:
    int private_member = 30;
};

class Car : public VehicleBase
{
    public:
        void Access()
        {
            std::cout << "public_member: " << public_member << std::endl;
            std::cout << "protected_member: " << protected_member << std::endl;
            std::cout << "private_member: " << private_member << std::endl; // Will not compile
        }
};

int main()
{
    VehicleBase vehicle;
    std::cout << "public_member: " << vehicle.public_member << std::endl;
    std::cout << "protected_member: " << vehicle.protected_member << std::endl; // Will not compile
    std::cout << "private_member: " << vehicle.private_member << std::endl; // Will not compile

    Car car;
    car.Access();

    return 0;
}

```

#### 类、结构体和内存

*   `class` 和 `struct` - 用于定义封装数据和函数的用户自定义类型。在常规 C++ 中， `class` 和 `struct` 实际上是同一回事。 `struct` 暴露的成员默认为公有。
*   `new` - 为对象分配内存（在堆内存上）并调用其构造函数。
*   `delete` - 释放使用 `new` 关键字分配的内存。

```cpp
/**
 * Struct to represent a person.
 */
struct Person
{
    /** The person's name. */
    std::string name;

    /** The person's age. */
    int age;
};

// Allocate memory for a Person object and initialize its members.
Person* person = new Person;
person->name = "John Doe";
person->age = 30;

// Print out the person's name and age.
std::cout << "Name: " << person->name << std::endl;
std::cout << "Age: " << person->age << std::endl;

// Deallocate memory for the Person object.
delete person;
```

<Callout type="warn">
 在 Unreal Engine 中，建议使用 `NewObject()` 和 `MakeShared()` 这类内置的内存管理函数来为对象分配内存，而不是使用 `new` 和 `delete` 。使用 `new` 和 `delete` 可能会干扰垃圾回收器，导致游戏出现内存泄漏或崩溃。
</Callout>

那么类和结构有什么区别呢？

> 在原生 C++中，结构体和类的主要区别在于结构体的成员默认是公开的，而类的成员默认是私有的。然而，这种区别在很大程度上是语法的，结构体和类可以互换地用于定义自定义类型。

> 然而，虚幻引擎中的结构体用于表示通常用于数据存储和操作的数据类型，而类用于表示具有行为和状态的对象。

```cpp
// Code here
```

#### 与函数相关的

*   `virtual` - 指定一个函数应该是多态的，这意味着它可以被派生类重写。
*   `override` - 表示派生类中的函数打算重写基类中的函数。
*   `static` - 指定一个变量或函数与类相关联，而不是与类的特定实例相关联。
*   `inline` - 指定一个函数应该是内联的（即，它的代码应该直接插入到调用代码中，而不是调用函数）。
*   `force_inline` - 指示编译器无论是否通常这样做，都要内联一个函数。

```cpp
/**
 * @brief Struct used to store vehicle details.
 */
struct Details
{
    /**
     * @brief Unique identifier for the vehicle.
     */
    int id;
};

/**
 * @brief Abstract base class for vehicles.
 */
class VehicleBase
{
public:
    /**
     * @brief Honk the vehicle.
     *
     * This function should be implemented by derived classes to provide a way for
     * the vehicle to make a noise.
     */
    virtual void Honk() = 0;

    /**
     * @brief Get the type of the vehicle.
     *
     * @return The type of the vehicle as a string.
     */
    virtual std::string GetVehicleType() = 0;

    /**
     * @brief Get the details of the vehicle.
     *
     * This function is a static member function and can be called without an
     * instance of the class.
     *
     * @return The vehicle details.
     */
    static Details GetDetails()
    {
        return Details
        {
            id = 0
        };
    }
};

/**
 * @brief Class representing a car.
 */
class Car : public VehicleBase
{
public:
    /**
     * @brief Overridden implementation of the Honk() function.
     *
     * This function calls the base implementation of Honk() and then does
     * some additional work.
     */
    void Honk() override
    {
        // Calls the base function from the class's derived type.
        VehicleBase::Honk();
    }

    /**
     * @brief Overridden implementation of the GetVehicleType() function.
     *
     * This function returns a string representing the type of the vehicle.
     *
     * @return The type of the vehicle as a string.
     */
    std::string GetVehicleType() override
    {
        return "Car";
    }
};

/**
 * @brief Class representing a bike.
 */
class Bike : public VehicleBase
{
public:
    /**
     * @brief Overridden implementation of the Honk() function.
     *
     * This function does not call the base implementation of Honk() and
     * therefore can overwrite the logic.
     */
    void Honk() override
    {
        // Does not call the base function, therefore can overwrite the logic.

        // Some other code
    }

    /**
     * @brief Overridden implementation of the GetVehicleType() function.
     *
     * This function returns a string representing the type of the vehicle.
     *
     * @return The type of the vehicle as a string.
     */
    std::string GetVehicleType() override
    {
        return "Bike";
    }
};

// Static member function call
Details details = VehicleBase::GetDetails();
```

* * *

> “理论上，使用内联函数可以使您的程序更快，因为它们消除了与函数调用相关的开销。调用一个函数需要在栈上推送返回地址，将参数推送到栈上，跳转到函数体，然后在函数完成时执行返回指令。通过内联函数可以消除这个过程。编译器在展开内联函数与未展开的函数之间也有不同的优化机会。内联函数的权衡是，您的程序的整体大小可能会增加。”

[Microsoft 文档](https://learn.microsoft.com/en-us/cpp/cpp/inline-functions-cpp)

在内联函数时，您可以选择强制执行或交给编译器决定。通过使用 `inline` ，您是在告诉编译器，允许它们内联这个函数。但是，它并不保证内联函数。”

要强制使用内联函数，你必须使用 `force_inline` 关键字。

<Callout> 在虚幻引擎中，更常见的是使用名为 `FORCEINLINE` 的宏，它本质上扩展为 `force_inline` 关键字。</Callout>

```cpp
inline int CalcNewHealth(int Health)
{
    return Health - 10;
}

const int Health = 10;
Health = CalcNewHealth(Health); // Compiles to: Health = 10 - 10;
```

#### 类型转换

*   `dynamic_cast` - 执行运行时检查以确定对象是否可以转换为不同类型。
*   `static_cast` - 执行静态类型转换，允许在编译时将表达式转换为不同的数据类型。
*   `const_cast` - 执行类型转换，但会移除变量上声明的 const 属性。
*   `reinterpret_cast` - 执行类型转换，允许将指针转换为任何其他类型的指针。这意味着这种转换将允许你对代表值的位进行重新解释，而不会改变它们。

```cpp
// Performs a runtime check to determine whether an object can be cast to a different type.
Parent* parentPtr = dynamic_cast<Parent*>(childPtr); // NOTE! Must have asterisk inside the cast operation as well. Something that we don't need in Unreal Engine.

if (parentPtr)
{
    // Casting successful, handle parentPtr
}
else
{
    // Casting failed, handle accordingly
}
```

```cpp
// Performs a static cast, allowing an expression to be converted to a different data type at compile time.
int num = 10;
double result = static_cast<double>(num);
```

```cpp
// Removes the const from a variable, which it has been declared on.
const int x = 5;

int* y = const_cast<int*>(&x);

// Modifying the value of x through y
*y = 10; // Will be changed to 10 instead 5.
```

```cpp
// Converting a pointer to any other type of pointer, reinterpreting the bits representing the value without changing them.
int* ptr = new int(65);
char* charPtr = reinterpret_cast<char*>(ptr); // Will be casted to char pointer, with the value of 'A'.
```

<Callout type="error"> 不要在 Unreal Engine 项目中使用 C++版本的类型转换。相反，应使用引擎提供的 `Cast()` 。这种转换针对 UE 进行了优化。</Callout>

<Callout> 如果您希望在 Unreal 中使用 `static_cast()` ，则应使用引擎提供的 `StaticCast()` 。这将生成相同的代码，但会修复 Visual Studio 中的一些问题。</Callout>

```cpp
ACharacter* MyCharacter = GetPlayerCharacter();

// This will perform a dynamic cast at runtime
auto* MyActor = Cast<AActor>(MyCharacter);

// Same as Cast<>, but will do a assertion (check) as well.
// Meaning, if the cast was unsuccessful, then a crash will occur.
auto* MyPlayer = CastChecked<APlayerCharacter>(MyCharacter);
```

```cpp
// This will perform either a static or dynamic cast
// Which is compile either at compile-time or at runtime.
int32 Value = StaticCast<int32>(3.14159265359);
```

#### 流程控制

*   `if` , `else if` 和 `else` - 用于程序中的条件执行。 `if` 检查一个条件，如果条件为真则执行一段代码。 `else if` 提供一个备选条件，如果第一个条件为假则检查该条件。 `else` 如果之前的条件都不为真，则执行一段代码。

*   `switch` - 一种流程控制语句，用于根据表达式的值从多个代码块中选择一个要执行的代码块。

*   `for` - 一种循环语句，只要条件为真就重复执行一段代码。它包括初始化、条件和自增/自减表达式。

*   `while` - 另一种循环语句，只要指定条件为真就执行一段代码。

*   `do` 和 `while` - 类似于 `while` 循环，但 `do while` 循环在检查条件之前至少会执行一次代码块。

*   `break` - 用于提前退出循环或 switch 语句，将程序控制权转移到循环或 switch 之后的语句。

*   `continue` - 使程序跳过当前循环的其余部分，并继续执行下一个循环迭代。

*   `try` , `catch` 和 `finally` - 通过尝试执行可能抛出异常的代码块，捕获抛出的异常，并在 `finally` 块中执行清理代码来实现异常处理，无论是否抛出异常。


```cpp
int num = 10;

if (num > 10)
{
    // do something
}
else if (num < 10)
{
    // do something else
}
else
{
    // do something different
}
```

```cpp
int option = 2;

switch (option)
{
    case 1:
        // case 1 actions
        break;

    case 2:
        // case 2 actions
        break;

    default:
        // default actions
        break;
}
```

```cpp
for (int i = 0; i < 5; ++i)
{
    // loop body
}
```

```cpp
int i = 0;

while (i < 5)
{
    // loop body
    ++i;
}
```

```cpp
int j = 0;

do
{
    // loop body
    ++j;
}
while (j < 5);
```

```cpp
for (int i = 0; i < 10; ++i)
{
    if (i == 5)  break; // exits the loop when i equals 5

    // loop body
}
```

```cpp
for (int i = 0; i < 5; ++i)
{
    if (i == 2)  continue; // skips the rest of the loop body for i equals 2

    // loop body
}
```

```cpp
try
{
    // block of code that may throw an exception
    throw 20; // example of throwing an exception
}
catch (int e)
{
    // handle exception
    // e contains the thrown value
}
finally
{
    // clean-up code that executes whether an exception is thrown or not
}
```

#### 通用编程

*   `template` - 通过在编译时定义具有参数的类型或函数，允许进行通用编程。

```cpp
template <typename T>
void PrintArray(T* arr, size_t size)
{
    for (size_t i = 0; i < size; ++i)
        std::cout << arr[i] << ", ";

    std::cout << std::endl;
}
```

```cpp
int arr1[5] = { 1, 2, 3, 4, 5 };
double arr2[5] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
std::string arr3[5] = { "one", "two", "three", "four", "five" };

PrintArray(arr1, sizeof(arr1) / sizeof(arr1[0])); // 1, 2, 3, 4, 5,
PrintArray(arr2, sizeof(arr2) / sizeof(arr2[0])); // 1.1, 2.2, 3.3, 4.4, 5.5,
PrintArray(arr3, sizeof(arr3) / sizeof(arr3[0])); // one, two, three, four, five,
```

#### 杂项

*   `auto` - 允许编译器根据变量的初始化器推断其类型。类似于 C# 版本的 `var` 关键字。
*   `namespace` - 为标识符定义作用域，以避免命名冲突。
*   `operator` - 将函数声明为重载运算符。
*   `explicit` - 指明构造函数或转换运算符不能用于隐式类型转换。

```cpp
namespace MyNamespace
{
    /**
     * @brief This is an example class that shows how to use the `auto` keyword
     * and overloaded operators.
     */
    class MyClass
    {
    public:
        /**
         * @brief Returns the current value of the class.
         * @return The current value.
         */
        int GetValue() const { return value; }

    private:
        int value;

    public:
        /**
         * @brief Adds the given number to the current value.
         * @param number The number to add.
         * @return The result of the addition.
         */
        int Add(const int& number)
        {
            // The compiler will figure out what type it should be
            auto result = value + number;
            return result;
        }

        /**
         * @brief Updates the value of the class.
         *
         * This function is an example of bad practices.
         * As the other developers who might read code,
         * doesn't understand the return value type is.
         */
        void ExampleOfBadPractice()
        {
            auto result = Add(5);
        }

        /**
         * @brief Overloaded `+` operator.
         * @param other The number to add to the current value.
         * @return A reference to the current object (to allow chaining).
         */
        void operator+(const int& other)
        {
            value = Add(other);
        }
    };
}
```

<Callout type="success">
  建议在单行中声明变量两次时使用 `auto` 关键字。例如，在强制类型转换操作期间。如果你在函数返回值上使用 `auto` 关键字，其他开发者将极难看出返回值的类型。
</Callout>

<Callout type="error">
  UHT [3](#user-content-fn-2) 不支持 `operator` 或 `namespace` 关键字。这意味着你不能有一个带有命名空间的 C++ 类，也不能使用操作函数为蓝图。
</Callout>

## 👷 构造函数、析构函数和初始化

<table><tbody><tr><td>这一部分是与 ChatGPT 共同编写的。</td></tr></tbody></table>

#### 构造函数

构造函数是 C++中的特殊成员函数，当对象被创建时会自动调用。它们用于初始化对象的数据成员并设置其初始状态。构造函数与类同名，可以重载以接受不同的参数集，从而以多种方式初始化对象。

这里有一个例子：

```cpp
/**
 * This is a simple C++ class that demonstrates how to define a constructor.
 * Constructors are special member functions in C++ that are automatically
 * called when an object is created. They are used to initialize the object's
 * data members and set up its initial state.
 *
 * In Unreal Engine, you can define constructors and destructors in C++ classes
 * just like in standard C++. Constructors are useful for initializing
 * properties and setting up components when an object is created, while
 * destructors can be used for cleanup tasks like releasing resources or
 * stopping background processes when an object is destroyed.
 *
 * NOTE; Don't clean up UObject memory! As Unreal's garbage collector does this for you. Interfering with Unreal's GC can cause issue and even crashes.
 */
class RegularClass
{
    RegularClass()
    {
        // This constructor is called automatically,
        // when an instance of RegularClass is created.

        // It is used to initialize the object's data members,
        // and set up its initial state.
    }
};
```

#### 析构函数

析构函数是 C++中另一种特殊的成员函数，当对象被销毁或超出作用域时自动调用。它们用于执行清理任务、释放资源以及回收对象生命周期中分配的内存。与构造函数一样，析构函数的名称与类相同，但前面有一个波浪号（~）。

这里有一个示例：

```cpp
/**
 * The destructor is a special member function in C++ that is automatically called
 * when an object is destroyed or goes out of scope. It is used to perform cleanup
 * tasks, release resources, and deallocate memory allocated during the object's
 * lifetime.
 *
 * In Unreal Engine, it is generally advised not to use destructors explicitly
 * for memory cleanup. Instead, Unreal Engine provides other mechanisms, such as
 * `BeginDestroy` and `EndPlay`, to handle object cleanup and resource release when
 * an object is destroyed or removed from the game world.
 */
class RegularClass
{
public:

    ~RegularClass()
    {
        // Destructor called when an instance of RegularClass is destroyed.
        // Or goes out of scope (curly brackets).
    }
};
```

#### UE 中的构造函数和析构函数

在虚幻引擎中，你可以在 C++类中像在标准 C++中一样定义构造函数和析构函数。构造函数用于在对象创建时初始化属性和设置组件，而析构函数可用于在对象销毁时执行清理任务，如释放资源或停止后台进程。

然而，虚幻引擎有自己的垃圾回收系统，可以自动管理内存和对象的释放。这意味着使用析构函数进行内存释放或资源清理可能会干扰垃圾回收过程，并导致意外行为或崩溃。

由于虚幻引擎中的自动垃圾回收，通常建议不要显式使用析构函数进行内存清理。相反，虚幻引擎提供了其他机制，如 `BeginDestroy` 和 `EndPlay` ，用于在对象销毁或从游戏世界中移除时处理对象清理和资源释放。

这里有一个示例：

```cpp
#include "MyActor.h"

#include "GameFramework/Actor.h"
#include "GameFramework/MovementComponent.h"

AMyActor::AMyActor()
{
    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
    PrimaryActorTick.bCanEverTick = false;

    // This is the default constructor for an Actor class in Unreal Engine.
    // You can initialize properties and set up components here.

    RootComponent = CreateDefaultSubobject<USceneComponent>("SceneComponent");

    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComponent"));
    MeshComponent->SetupAttachment(RootComponent);
    MeshComponent->bCastDynamicShadow = false;

    checkf(MeshComponent, TEXT("MeshComponent cannot be a nullptr!"));
    verifyf(MeshComponent, TEXT("MeshComponent cannot be a nullptr!"));
    ensureMsgf(MeshComponent, TEXT("MeshComponent cannot be a nullptr!"));

    // Cast<T> has to be used for *UObjects* due to type safety; it will return *nullptr* in case of a failure in comparison with *StaticCast()*. StaticCast is just a wrapper to *static_cast* function.
    if (UMovementComponent* MeshAsMovementComponent = Cast<UMovementComponent>(MeshComponent))
    {
        // Cast worked!

        MeshAsMovementComponent->bSnapToPlaneAtStart = true;
    }

    UStaticMeshComponent* RootAsActorComponent = CastChecked<UActorComponent>(RootComponent); // Cast must work, otherwise a crash will occur.
}

void AMyActor::BeginPlay()
{
    Super::BeginPlay();

    // This function is automatically called when the actor is spawned or added to the world.
    // You can perform any necessary setup or initialization here.
}

void AMyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    // This function is automatically called when the actor is removed from the world or destroyed.
    // You can perform cleanup and resource release here.

    Super::EndPlay(EndPlayReason);
}
```

#### 初始化

在 C++中，初始化是指当声明变量时为其分配初始值的操作。初始化至关重要，因为它确保变量具有明确的初始值，这有助于避免意外行为并提高代码清晰度。

以下是一个演示代码片段：

```cpp
// Initialization using assignment statement
int num1 = 10;

// Initialization using brace initializer
int num2{20};
```

在使用花括号初始化器时存在一个重要区别，特别是在涉及窄化转换的情况下。窄化转换是指当一个值被赋给一个范围小于所提供值的变量时发生的情况。例如：

```cpp
int num3 = 1000;       // OK, no narrowing conversion
int num4 = 1000.5;     // OK, narrowing conversion from double to int
int num5{1000.5};      // Error, narrowing conversion from double to int
```

在最后一行，使用大括号初始化器时，编译器会生成错误，因为它检测到从 `double` 到 `int` 的窄化转换，这可能会导致数据丢失。这是一个安全特性，旨在帮助捕获意外的数据截断。

## 🏛 创建自定义类

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

![Lifecycle breakdown](/static-img/ActorLifeCycle.png)

生命周期分解

你可以在虚幻引擎的文档中了解更多关于 Actor 生命周期的信息。

### AActor

通过继承 `AActor` 类，你可以使用这些流行的函数：

```cpp
/**
 * This function is called after the class's constructor, inside the Editor.
 * It's a safe way to initialize components inside the editor.
 */
void PostInitComponents();

/**
 * "Awake/Start" method
 *
 * This function is called when an actor is spawned or respawned.
 *
 * It's the perfect place to set up default values for your actor's
 * properties, initialize components, and start any asynchronous work
 * that needs to occur when the actor is first created.
 */
void BeginPlay();

/**
 * "Update" method
 *
 * This function is called every frame, with the time since the last
 * update as its parameter.
 *
 * Use this function to update your actor's state, like checking
 * whether it's colliding with something or not.
 *
 * NOTE; Try to avoid overusing Tick() function. Since, Unreal's core logic, is simply as runs for loop and calling each function for each lickable UObject. Which can be very expensive, with many and unnecessary update calls.
 * Here are some tips to overcome this issue:
 *      - Change your workflow to an event based driven system. Either by using delegates or single call functions.
 *      - Change your tick interval to a slower interval. If you require for UObject to tick, but don't require updating a single frame (then this is a perfect fit).
 *
 * @param DeltaTime Time since last update
 */
void Tick(float DeltaTime);

/**
 * "Destroy" method
 *
 * This function is called when an actor is destroyed, or when it's
 * forced to be destroyed (e.g. when its outermost `UWorld` is shut
 * down).
 *
 * It's a good place to clean up any resources that your actor
 * allocated during its lifetime. Like delegates (NOTE; some delegates are bind directly to UObject and don't require to unbind directly).
 */
void EndPlay();

/**
 * Returns the location of the RootComponent of this Actor
 *
 * @return Location of the RootComponent
 */
FVector GetActorLocation() const;

/**
 * Returns the rotation of the RootComponent of this Actor
 *
 * @return Rotation of the RootComponent
 */
FRotator GetActorRotation() const;

/**
 * Returns the Actor's world-space scale.
 *
 * @return The world-space scale of the actor
 */
FVector GetActorScale3D() const;

/**
 * Getter for the cached world pointer, will return null if the actor is not actually spawned in a level
 *
 * @return The world pointer
 */
UWorld* GetWorld() const;

/**
 * Get the owner of this Actor, used primarily for network replication.
 *
 * @return The owner of this Actor
 */
AActor* GetOwner() const;

/**
 * Find all Actors which are attached directly to a component in this actor
 *
 * @param[out] OutActors       The array to fill with the attached actors
 * @param bResetArray          Whether to reset the array before adding new Actors
 * @param bRecursivelyIncludeAttachedActors Whether to include attached actors of attached actors also
 */
void GetAttachedActors(TArray<AActor*>& OutActors, bool bResetArray = true, bool bRecursivelyIncludeAttachedActors = false) const;

/**
 * Get all components derived from specified ComponentClass and fill in the OutComponents array with the result.
 *
 * @tparam AllocatorType       The allocator type to use for OutComponents
 * @tparam ComponentType       The type of the components to get
 * @param ComponentClass       The class of the components to get
 * @param[out] OutComponents  The array to fill with the found components
 * @param bIncludeFromChildActors Whether to include components from Child Actors also
 */
template<class AllocatorType, class ComponentType>
void GetComponents(TSubclassOf<UActorComponent> ComponentClass, TArray<ComponentType*, AllocatorType>& OutComponents, bool bIncludeFromChildActors = false) const;

/**
 * Searches components array and returns first encountered component of the specified class
 *
 * @param ComponentClass    The class of the component to search for
 * @return The found component or nullptr if not found
 */
UActorComponent* GetComponentByClass(TSubclassOf<UActorComponent> ComponentClass) const;
```

### UActorComponent

通过继承 `UActorComponent` 类，您拥有这些常用功能：

```cpp
/**
 * Returns the owner of this component
 *
 * @return Owner of this component
 */
UObject* GetOwner() const;

/**
 * Returns the SceneComponent this component is attached to, or nullptr if not attached.
 *
 * @return The SceneComponent this component is attached to, or nullptr if not attached
 */
UWorld* GetWorld() const;

/**
 * Returns whether the component is active or not
 */
bool IsActive() const;

/**
 * Returns whether this component has tick enabled or not
 */
bool IsComponentTickEnabled() const;

/**
 * Activates the SceneComponent, should be overridden by native child classes.
 *
 * @param bReset If true, reset the component before activating it
 */
void Activate(bool bReset);

/**
 * Deactivates the SceneComponent.
 */
void Deactivate();

/**
 * Set this component's tick functions to be enabled or disabled.
 *
 * @param bEnabled If true, enable the tick functions, otherwise disable
 */
void SetComponentTickEnabled(bool bEnabled);

/**
 * Sets the tick interval for this component's primary tick function.
 *
 * @param TickInterval The tick interval in seconds
 */
void SetComponentTickInterval(float TickInterval);

/**
 * Function called every frame on this ActorComponent.
 *
 * @param DeltaTime The time since the last frame in seconds
 * @param TickType The kind of tick this is (LEVELTICK_All, LEVELTICK_Editor, LEVELTICK_TimeOnly)
 * @param ThisTickFunction Pointer to the original function that is being called
 */
void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction);
```

### USceneComponent

通过继承 `USceneComponent` 类，您拥有这些常用功能：

```cpp
/**
 * Returns the SceneComponent this component is attached to, or nullptr if not attached.
 *
 * @return The SceneComponent this component is attached to, or nullptr if not attached
 */
USceneComponent* GetAttachmentRoot() const;

/**
 * Detaches this component from its parent component.
 *
 * @param bMaintainWorldTransform Whether to maintain the world transform of this component
 */
void DetachFromComponent(bool bMaintainWorldTransform = false);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 * @param SocketName            If the parent is a USkeletalMeshComponent, this is the name of the socket to attach to
 * @param AttachLocation        The location in world space to attach this component
 */
void AttachToComponent(USceneComponent* Parent, FName SocketName = NAME_None, const FAttachmentTransformRules& AttachRules = AttachmentTransformRules::KeepRelativeTransform);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 * @param AttachLocation        The location in world space to attach this component
 */
void AttachToComponent(USceneComponent* Parent, const FTransform& AttachLocation, const FAttachmentTransformRules& AttachRules  FAttachmentTransformRules::KeepRelativeTransform);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 */
void AttachTo(USceneComponent* Parent);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 */
void AttachTo(AActor* Parent);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 */
void AttachToComponent(UActorComponent* Parent, const FAttachmentTransformRules& AttachRules = AttachmentTransformRules::KeepRelativeTransform);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 */
void AttachToComponent(UActorComponent* Parent, const FTransform& AttachLocation, const FAttachmentTransformRules& AttachRules  FAttachmentTransformRules::KeepRelativeTransform);

/**
 * Attaches this component to the supplied parent component.
 *
 * @param Parent                The component to attach to
 */
void AttachTo(UActorComponent* Parent);

/**
 * Returns true if this component is currently attached to the supplied component
 *
 * @param InComponent           The component to check against
 * @return                      true if this component is currently attached to InComponent
 */
bool IsAttachedTo(const USceneComponent* InComponent) const;

/**
 * Returns true if this component is currently attached to the supplied component
 *
 * @param InComponent           The component to check against
 * @return                      true if this component is currently attached to InComponent
 */
bool IsAttachedTo(const UActorComponent* InComponent) const;

/**
 * Returns the Component to World transform, calculated from this component's AttachmentTransform,
 * unless overridden by any parents.
 */
const FTransform& GetComponentToWorld() const;

/**
 * Returns the Component to World transform, calculated from this component's AttachmentTransform,
 * unless overridden by any parents.
 */
FTransform CalcNewComponentToWorld(const FTransform& NewAttachmentTransform) const;
```

### APawn

通过继承 `APawn` 类，您拥有这些常用功能：

```cpp

/**
 * Add movement input along the given world direction vector (usually normalized) scaled by 'ScaleValue'.
 *
 * This function is used to control movement of an actor without using physics or movement components.
 * For example, it can be used to move a character in a top-down game.
 *
 * @param WorldDirection Direction vector (in world space) in which movement is input.
 * @param ScaleValue Scale value for the input.
 * @param bForce If `true`, forces the input to be applied even if the component is not moving.
 */
void AddMovementInput(FVector WorldDirection, float ScaleValue, bool bForce);

/**
 * Add input (affecting Yaw) to the Controller's ControlRotation, if it is a local PlayerController.
 *
 * This function is used to control rotation of an actor without using a camera component.
 * For example, it can be used to rotate a character in a first-person shooter game.
 *
 * @param Val Input value (affecting Yaw) to be applied to the Controller's ControlRotation.
 */
void AddControllerYawInput(float Val);

/**
 * Add input (affecting Pitch) to the Controller's ControlRotation, if it is a local PlayerController.
 *
 * This function is used to control rotation of an actor without using a camera component.
 * For example, it can be used to rotate a character in a first-person shooter game.
 *
 * @param Val Input value (affecting Pitch) to be applied to the Controller's ControlRotation.
 */
void AddControllerPitchInput(float Val);

/**
 * Add input (affecting Roll) to the Controller's ControlRotation, if it is a local PlayerController.
 *
 * This function is used to control rotation of an actor without using a camera component.
 * For example, it can be used to rotate a character in a first-person shooter game.
 *
 * @param Val Input value (affecting Roll) to be applied to the Controller's ControlRotation.
 */
void AddControllerRollInput(float Val);

/**
 * Returns velocity (in cm/s (Unreal Units/second) of the rootcomponent if it is either using physics or has an associated ovementComponent
 *
 * This function is used to get the current velocity of an actor.
 *
 * @return Current velocity of the actor's root component (in cm/s (Unreal Units/second) or (0, 0, 0) if it doesn't have any ovement components.
 */
FVector GetVelocity();
```

### UObject

通过继承 `UObject` 类，您拥有这些常用功能：

```cpp
/**
 * Returns the name of this object (with no path information)
 *
 * Name of the object.
 *
 * @return Name of the object (with no path information).
 */
FString GetName() const;

/**
 * Returns the UClass that defines the fields of this object
 *
 * @return UClass that defines the fields of this object.
 */
UClass* GetClass();

/**
 * Returns the UObject this object resides in (e.g. parent object)
 *
 * @return UObject this object resides in (e.g. parent object).
 */
UObject* GetOuter();

/**
 * Checks to see if the object appears to be valid
 *
 * @return true if the object appears to be valid, false otherwise.
 */
bool IsValidLowLevel();

/**
 * Returns true if this object is of the specified type.
 *
 * @param SomeBase The class to check this object against.
 * @return true if this object is of the specified type, false otherwise.
 */
template<typename OtherClassType>
bool IsA(OtherClassType SomeBase) const;
```

## 🏛 创建自定义接口

<table><tbody><tr><td>这一部分并非与 ChatGPT 共同编写。</td></tr></tbody></table>

接口对于以通用方式处理函数非常有用。它允许你创建一个具有指定函数的契约，程序员可以在指定的类之上进行扩展。

例如，IVehicle 可以包含 `Honk()` 或 `StallEngine()` 等函数。然而，这些函数可以在多种类中实现。例如 `ACarPawn` 或 `ABoatPawn` 。

在 C++中调用接口函数时，Unreal 会检查类型是否扩展了接口。如果没有，调用将被跳过。这允许你在 `UObject` 上调用接口函数，并且不仅限于 `ACarPawn` 或 `ABoatPawn` 类型。

这同样允许你在 Blueprint 内部扩展接口。例如，你不必在 C++中创建接口逻辑，而是在 Blueprint 级别创建逻辑。

你可以在 Unreal 的文档中了解更多关于接口的信息。

### 在 C++中创建接口

以下是用于在 C++中创建接口的模板文件：

```cpp
// IVehicle.h

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "IVehicle.generated.h"

/*
This class does not need to be modified.
Empty class for reflection system visibility.
Uses the UINTERFACE macro.
Inherits from UInterface.
*/
UINTERFACE(MinimalAPI, Blueprintable)
class UVehicle : public UInterface
{
    GENERATED_BODY()
};

/* Actual Interface declaration. */
class IVehicle
{
    GENERATED_BODY()

    // Add interface functions to this class. This is the class that will be inherited to implement this interface.

public:
    // Add interface function declarations here

    // BlueprintNativeEvent - Allows you to overwrite the function in either C++ or Blueprint
    // BlueprintImplementableEvent - Allows the function to only be overwritten in Blueprint

    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Vehicle")
    void Honk();

    UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, Category = "Vehicle")
    void StallEngine();

    UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, Category = "Vehicle")
    void Explode(bool bForce = true);
};
```

<Callout type="warn"> `BlueprintNativeEvent` 允许你在 C++ 或蓝图中对函数进行重写，但如果你使用 `BlueprintImplementableEvent` ，它只允许在蓝图中对函数进行重写。</Callout>

### 扩展接口函数：

当你将一个接口类添加到一个 C++ 类中时，你必须对所有你要重写的函数使用 `_Implementation` 后缀。否则，UHT [3](#user-content-fn-2) 将无法识别该函数。

这里是一个在 C++ 中扩展接口函数的示例：

```cpp
// ACarPawn.h

#include "CoreMinimal.h"
#include "GameFramework/Pawn.h"
#include "IVehicle.h" // Include the interface's header
#include "CarPawn.generated.h"

UCLASS()
class ACarPawn : public APawn, public IVehicle
{
protected:
    void Honk_Implementation();
    void StallEngine_Implementation();
    void Explode_Implementation(bool bForce);
};
```

```cpp
// ACarPawn.cpp

void ACarPawn::Honk_Implementation()
{
    // Add code here...
}

void ACarPawn::StallEngine_Implementation()
{
    // Add code here...
}

void ACarPawn::Explode_Implementation(bool bForce)
{
    // Add code here...
}
```

### 调用接口函数

在 C++中调用接口函数时，必须使用 `Execute` 作为前缀调用该函数。如果不使用前缀，Unreal Engine 会发出警告。

<Callout> 你是从接口本身调用接口函数。也就是说，不能使用 `ACarPawn->Explode()` （接口函数），而必须使用 `IVehicle::Execute_Explode()` ，并将参数设置为接口函数要调用的对象。</Callout>

```cpp
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.
const bool bForce = true; // Parameters

// The syntax for calling the interface function
IVehicle::Execute_Explode(CarObject, bForce);
```

### 检查 UObject 是否扩展了接口

有时，你需要检查 `UObject` 是否绑定了接口类。你可以通过调用 `Implements()` 函数来实现，该函数返回一个布尔值。或者你可以执行一个强制类型转换操作。如果转换失败，将返回 `nullptr` 。

```cpp
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.

bool bIsImplemented = CarObject->Implements<IVehicle>();
```

`Implements()` 函数的更详细版本：

```cpp
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.

bool bIsImplemented = CarObject->GetClass()->ImplementsInterface(UVehicle::StaticClass());
```

以下是强制类型转换版本：

```cpp
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.

IVehicle* VehiclePtr = Cast<IVehicle>(CarObject);
```

<Callout type="warn">
`Cast<>` 方法只有在接口在 C++类中实现时才有效。如果接口是在蓝图（Blueprint）中实现的，那么强制类型转换将返回 `nullptr` 。你可以使用 `TScriptInterface<>` 来安全地复制接口指针。或者，你可以使用弱接口指针（ `TWeakInterfacePtr` ）。
</Callout>

### 引用一个接口对象

如果你希望引用一个接口对象，并且你想要为蓝图和 C++提供安全保证，那么你必须 `TScriptInterface<>` 。

```cpp
void DestroyVehicle(const TScriptInterface<IVehicle>& Vehicle)
{
    const bool bForce = true;
    IVehicle::Execute_Explode(Vehicle.GetObject(), bForce);
}
```

然而，如果你倾向于在 C++中使用接口指针，你可以使用一个普通的原始接口指针。

```cpp
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.

IVehicle* VehiclePtr = Cast<IVehicle>(CarObject);
```

或者使用一个弱指针（ `TWeakInterfacePtr` ）。注意，这个指针是弱指针。这意味着，弱指针不会阻止它所引用的对象被销毁。

```cpp
TWeakInterfacePtr<IVehicle> VehiclePtr; // Weak pointer to the interface.
UObject* CarObject = nullptr; // The UObject, that you wish to call the function on.

VehiclePtr = Cast<IVehicle>(CarObject);

if (VehiclePtr.IsValid())
{
    // Check if the pointer is valid
}
```

关于弱指针的更多信息，你可以在 💾 Soft vs hard references 中阅读。

<Callout type="success">
 Blueprint 中的 `TScriptInterface` 比 C++版本看起来更美观。
</Callout>

## 🛸 反射系统

<table><tbody><tr><td>本节内容是与 ChatGPT 一起编写的。</td></tr></tbody></table>

虚幻引擎的反射系统是一个强大的功能，它允许在运行时访问和修改对象及其属性。反射系统通过将每个类及其成员（如属性和函数）的信息存储在可在运行时访问的元数据中来工作。这些元数据由虚幻头文件工具（UHT [3](#user-content-fn-2) ）在编译过程中自动生成。借助 `GENERATED_BODY()` 宏和 `[FileName].generated.h` 头文件。

生成的头文件通常包含在定义相应类或结构的源文件中，也包含在任何使用该类或结构的其他源文件中。这确保了元数据在编译时和运行时对引擎可用。

反射系统也用于引擎的许多其他领域，例如序列化和网络通信。当对象保存到磁盘或通过网络发送时，它们的属性会被序列化为二进制格式。反射系统用于确定要序列化的属性，以及如何将它们转换为和从二进制表示转换回来。

头文件系统的一个主要优势是它允许非常高效的编译时间。由于每个 C++文件都有自己的头文件，对一个文件的更改不需要重新编译依赖于它的其他文件。相反，只需要重新编译包含修改后的头文件的文件。

您可以从他们的文档中了解更多关于反射系统的信息。

## 🗑️ 垃圾回收

<table><tbody><tr><td>本节是与 ChatGPT 共同编写的。</td></tr></tbody></table>

垃圾回收是一种自动内存管理功能，在现代语言如 C# [6](#user-content-fn-12) 、Python [4](#user-content-fn-11) 和 Javascript [2](#user-content-fn-14) 中被使用，当对象不再使用时，它会自动从内存中移除。

在垃圾回收环境中，你可以创建对象，使用它们，并在使用完毕后将指向它们的变量设置为 null，垃圾回收器会负责释放内存。与需要手动内存管理的低级语言如 C [1](#user-content-fn-10) 和 C++不同，虚幻引擎拥有自己的垃圾回收系统，以简化开发者的内存管理。

你可以阅读更多关于栈与堆的部分。它详细介绍了编程语言中内存是如何被管理的。

你也可以在他们的文档中阅读更多关于虚幻对象处理的内容。

### 它是如何工作的

当你在虚幻引擎中创建一个继承自 UObject 的对象时，它将成为垃圾回收系统的一部分，该系统会自动识别并删除未使用的对象，时间间隔为 30-60 秒或根据系统内存需求进行调整。垃圾回收系统维护一个“根集”对象，这些对象应始终保持活动状态，它使用反射来追踪对象引用并确保对象可达。根集之外的不可达对象会被标记为垃圾回收，并释放其内存。

通过正确使用虚幻引擎的装饰器，你可以避免悬空指针和因访问已回收对象而导致的崩溃问题。

#### 规则

一个类的每个成员都应该声明为 `UPROPERTY`

> 如果一个成员被“裸露”着， unreal 将不会知道它。所以，你所指向的对象可能会在你不知不觉中被删除！将值类型（如 `int` 或 `bool` ）“裸露”着是安全的，尽管它们不能被保存、复制或出现在编辑器中。

成员指针只能指向 `UObject` 或 UObject-derived 对象

> 垃圾收集器足够智能，只能识别对象之间的关系，所以对象可能会在你指针之下的情况下被删除。

任何非 UObject 指针必须指向引擎中的“全局”对象，或其自身的 `UObject`

> 垃圾回收器可能会删除你所指向的对象的所有者。

<Callout type="warn"> 为了让垃圾回收器完成其工作（确定哪些对象可以安全删除，对于容器而言），它必须遍历每个对象的每个字段。虽然 Unreal 提供了多种类型的容器（ `TArray` ， `TMap` ， …），但垃圾回收器只考虑 `TArray` 中的指针。</Callout>

#### 示例

```cpp
UPROPERTY()
TArray<UWidget*> LotsOfWidgets;

TMap<int, TWeakObjectPtr<UWidget>> LotsOfWeakWidgets;
```

### 手动内存管理

UObjects 不应该使用 `new` 创建，而只能使用默认的创建方法（ `NewObject()` ， `SpawnActor()` ， `CreateDefaultSubobject()` ）。

### 收集并标记为垃圾

<table><tbody><tr><td>条件 通过拥有对它们的强引用（ UPROPERTY ）（来自也被引用的对象） 通过从也被引用的对象调用 UObject::AddReferencedObjects() 通过使用 UObject::AddToRoot() 将它们添加到根集（通常不必要）</td></tr></tbody></table>

当对象不满足上述任何条件时，在下一个 GC 周期它们将被标记为不可达并被垃圾回收（销毁）。

要强制销毁仍然可访问的对象，可以调用它们上的 `UObjectBaseUtility::MarkAsGarbage()` ，这将迫使它们在下一个垃圾回收周期中被销毁（通常应避免这样做，因为这就是垃圾回收的作用，而且某些类，如 `AActor` 和 `UActorComponent` 不直接支持它）。

对象的销毁不一定都在同一个帧中发生，当垃圾回收开始作用于它时，会首先调用 `BeginDestroy()` （不要自己调用这个），然后，在准备好时 `FinishDestroy()` 。

<Callout> 使用 `UPROPERTY` 声明的原始指针将被设置为 `nullptr`</Callout>

### 验证

每当代码引用 `AActor` 或 `UActorComponent` 时，它必须处理 `AActor::Destroy()` 可能被调用在 actor 或 `UActorComponent::DestroyComponent()` 可能被调用在组件的可能性。这些函数将它们标记为待删除，从而在第一时间触发它们的垃圾回收（注意：销毁一个 actor 也会销毁所有它的组件）。

由于垃圾回收器在真正销毁它们时会自动将 `UPROPERTY` 指针置为空，因此检查 actor 或组件指针是否为空就足够知道它是否安全使用，尽管你可能还想通过 `IsValid()` 检查它们上的 `IsPendingKill()` 以避免在它们被标记为销毁后访问它们（ `TWeakObjectPtr` 在检索原始指针时已经检查了这一点）。

```cpp
bool IsValid(const UObject* Test);
```

一个全局函数，自动检查对象指针是否非空且未标记为待删除。

```cpp
UObjectBase::IsValidLowLevel();
UObjectBase::IsValidLowLevelFast();
```

不应用于垃圾回收检查，因为对于 `UPROPERTY` 指针它将始终返回 true，而对于原始指针它将根据对象是否已被销毁返回 true 或 false，但在后一种情况下它也可能导致应用程序崩溃，因为指向的内存可能已被覆盖。

## 💾 软引用与硬引用

<table><tbody><tr><td>本节由 ChatGPT 共同编写。</td></tr></tbody></table>

![Soft vs hard references](/static-img/Soft_Hard_Refs.png)

### 软引用

软引用是对资产的一种弱引用，它不会创建强依赖关系。它允许资产根据使用情况或其他条件在运行时动态加载或卸载。当你想表示对资产的松散依赖关系，而不强制其加载时，会使用软引用。

软引用的一个类比可以是书中的书签。它指向特定的一页，但并不实际持有内容。你可以轻易地移除或更改书签，而不会影响书的内容。

### 硬引用

硬引用是对资产的一个强引用，它会创建一个牢固的依赖关系。它确保被引用的资产被加载，并且在引用资产被使用期间保持加载状态。当你在运行时需要确保资产的存在时，会使用硬引用。

硬引用的一个类比可以是需要嵌入到特定位置的一块拼图。这块拼图是拼图不可或缺的一部分，移除或更改它都会破坏预期的结构。

* * *

当加载具有硬引用的资产时，它会触发一系列依赖关系，导致所有具有硬引用的资产也被加载。这确保了所有必需的资产都可用于正常功能。这种加载行为被称为"链式加载"或"按需加载"。

例如，如果关卡蓝图通过硬引用引用了特定的音效提示，当关卡加载时，音效提示及其直接或间接引用的任何其他资产也会被加载，以保持所引用音效提示功能的完整性。

相比之下，如果使用软引用，所引用的资产可能初始时不加载，也可能加载，并且可以根据游戏或应用程序的具体需求动态加载或卸载。

通过合理组合软引用和硬引用，可以高效管理资产依赖关系，优化内存使用，并在运行时提供加载和卸载资产的灵活性。

参考查看器是编辑器中的一个工具，它允许你查看特定资产中的参考链，包括硬参考和软参考。这个工具帮助你弄清楚哪些资产正在加载，以及它们之间的链式依赖关系。

尺寸映射是编辑器中的另一个工具，它允许你查看主资产加载的不同资产的总和和独立尺寸。例如，你可以看到角色内存占用的大小（包括所有纹理和骨骼网格）。

你可以在名为《硬参考及避免使用硬参考的原因》的文章中了解更多关于软参考和硬参考的信息，作者是 raharuu。

你也可以在 Unreal Engine 文档中了解更多关于资产引用的信息。

## 🌍 全局函数

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

全局函数是指定义在任何类之外的函数，且不与任何特定对象实例绑定。它们可以从代码库的任何部分访问，并可用于执行不需要访问特定对象属性或方法的任务或计算。

在 Unreal Engine 中，全局函数通常用于工具函数、辅助函数或独立于任何特定对象实例操作数据的函数。

*   `IsValid()` : 检查指针或对象引用是否有效。这很重要，以避免访问或修改空指针，这可能导致崩溃或其他意外行为。

*   `Swap()` : 交换两个 `TObjectPtr` 对象的内容。

*   `Exchange()` : 将一个 `TObjectPtr` 与新对象交换内容，并返回之前的对象。

*   `MakeWeakObjectPtr()` : 从一个 `TObjectPtr` 创建一个弱指针（ `TWeakObjectPtr` ），允许对对象进行非拥有引用。

*   `Cast()` : 动态转换为另一个对象。如果转换对象不是指定的类型，它将返回 nullptr。如果对象是指定的类型或其子类，该函数将返回指向指定类型转换对象的指针。

*   `CastChecked()` : 类似于 `Cast()` ，但在调试构建中会执行运行时检查，以确保对象是指定的类型。如果检查失败，将触发断言。当您确信对象应该是特定类型并希望在开发早期捕获错误时，此函数很有用。

*   `StaticCast()` : 尝试在编译时进行转换。但是，某些代码可能仅在运行时才能工作，因此编译器将决定是否静态转换是“适当”的。


<Callout> `StaticCast()` 函数只是转发 C++中的内置转换操作，该操作称为 `static_cast()` 。这意味着在 Unreal Engine `UObject` 中没有安全性保证。</Callout>

## 🏛️ 库

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

蓝图函数库（ `UBlueprintFunctionLibrary` ）是一组静态函数的集合，提供与特定游戏对象无关的实用功能。这些库可以分组为逻辑函数集，例如 AI 蓝图库，或包含提供对不同功能区域访问的实用函数，例如系统蓝图库。

```cpp
UCLASS()
class UAnalyticsBlueprintLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_UCLASS_BODY()

public:
    /** Starts an analytics session without any custom attributes specified */
    UFUNCTION(BlueprintCallable, Category = "Analytics")
    static bool StartSession();
}
```

如上例所示，蓝图函数库间接派生于 `UObject` ，因此需要标准的 `UCLASS()` 和 `GENERATED_UCLASS_BODY()` 宏 [7](#user-content-fn-4) 。它使用 `UFUNCTION()` 宏 [7](#user-content-fn-4) 装饰那些可以从蓝图中调用的函数。蓝图函数库中的函数可以根据调用是否具有副作用，被指定为 BlueprintCallable 或 BlueprintPure。

以下是 `StartSession()` 函数的实现：

```cpp
bool UAnalyticsBlueprintLibrary::StartSession()
{
    TSharedPtr<IAnalyticsProvider> Provider = FAnalytics::Get().GetDefaultConfiguredProvider();

    if (Provider.IsValid())
        return Provider->StartSession();
    else
    {
        UE_LOG(
            LogAnalyticsBPLib,
            Warning,
            TEXT("StartSession: Failed to get the default analytics provider. Double check your [Analytics] configuration in your INI")
        );
    }

    return false;
}
```

你可以在 Blueprint 函数库了解更多！

### Kismet 库

*   `UGameplayStatics` - 可在 Blueprint 和 C++中调用的 `gameplay` 实用函数
*   `UKismetMathLibrary` - `math` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetStringLibrary` - `string` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetTextLibrary` - `text` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetSystemLibrary` - `system` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetMaterialLibrary` - `material` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetInputLibrary` - `input` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetGuidLibrary` - `guid` 可从 Blueprint 和 C++中调用的实用函数
*   `UKismetArrayLibrary` - `array` 可从 Blueprint 和 C++中调用的实用函数

### 杂项库

*   `FMath` - 数学辅助函数（更多数学函数请查看 `GenericPlatformMath.h` ）。
*   `DrawDebugHelpers.h` - 头文件包含调试绘制函数。了解更多信息请点击这里。

## 📃 宏定义

宏 [7](#user-content-fn-4) 是在编译过程之前执行文本替换的预处理指令。它们用 # 符号表示，用于定义可重用的代码片段、条件性地包含或排除代码，以及执行其他预处理操作。

使用 Unreal Engine 在 C++ 中创建宏非常简单。您可以使用 #define 预处理指令来定义宏。以下是基本语法：

```cpp
#define MACRO_NAME(value) // Macro definition
```

以下是 PI 宏的示例：

```cpp
#define PI 3.14
#define PI_MULTIPLY(x) 3.14 * x
```

以下是 Unreal Engine 中常见的宏列表：

*   `GENERATED_BODY()` - 引擎所需的模板代码。

*   `TEXT()` - 用于指定宽字符（UTF-16）编码。这使得字符串字面量成为平台无关的。没有这个宏，你将使用 ANSI 编码（这可能导致在其他机器上出现问题）。

*   `TEXTVIEW()` - 在编译时计算字符串字面量的长度。

*   `INVTEXT()` - 标记用于本地化的文本字符串。它代表"不变文本"，用于指定在本地化过程中应保持不变的文本。

*   `LOCTEXT()` - 创建本地化文本。它代表"本地化文本"，允许你定义可本地化不同语言的文本字面量。

*   `IN` 和 `OUT` - 函数参数装饰器。它们提供关于意图和数据流向的提示。 `IN` 表示该参数是输入参数，意味着它向函数提供数据。 `OUT` 表示该参数是输出参数，意味着函数将通过该参数修改或提供数据。

*   `LINE_TERMINATOR` - 在虚幻引擎中表示行终止符序列。它提供了一种与平台无关的方式，用于在文本文件或字符串中指定换行符。

*   `CONSTEXPR` - 声明常量表达式。它用于与 `constexpr` 关键字 [8](#user-content-fn-1) 结合使用，以指定函数或变量可以在编译时进行评估，并被视为常量表达式。

*   `ABSTRACT` - 声明一个抽象类。它表示一个类不能直接实例化，必须被子类继承。抽象类作为其他类的基础类，为它们提供共同功能的蓝图。

*   `UPROPERTY()` - 定义属性的类型和行为，以及其元数据和显示名称。

*   `UFUNCTION()` - 定义函数的参数和返回类型，以及其行为和元数据。

*   `UCLASS()` - 定义类的属性和行为，包括其继承层次结构、默认属性和编辑器元数据。

*   `USTRUCT()` - 定义结构体的属性和行为，包括其字段、默认值和编辑器元数据。

*   `UINTERFACE()` - 定义枚举的值，以及其元数据和显示名称。

*   `UPARAM()` - 为虚幻引擎中的函数参数指定附加元数据。此元数据可用于多种目的，例如指定编辑器中参数的类别或提示信息。

*   `UENUM()` - 定义一个可在虚幻引擎类中使用的枚举。这允许开发人员以类型安全的方式定义一组命名的常量。

*   `UMETA()` - 指定在虚幻引擎中对枚举值添加额外元数据。这些元数据可用于多种目的，例如指定编辑器中该值的显示名称或提示信息。

*   `INLINE` - 向编译器建议将函数内联，但编译器不必须遵循该建议。（替代 `inline` 关键字 [8](#user-content-fn-1) ）

*   `FORCEINLINE` - 更强的建议，要求编译器尽可能内联该函数，如果函数不能内联，甚至可能产生错误。（替代 `force_inline` 关键字 [8](#user-content-fn-1) ）'

*   `UE_LOG` - 将日志消息输出到日志文件。它接受的第一输入参数是日志分类的名称。

*   `check` 和 `checkf` （不允许在构建中使用）- 如果 `Expression` 为 false，则停止执行。 `checkf` 将 `FormattedText` 输出到日志。

*   `verify` 和 `verifyf` （允许在构建中使用）- 如果 `Expression` 为 false，则停止执行。 `verifyf` 将 `FormattedText` 输出到日志。

*   `ensure` 和 `ensureMsgf` （允许在构建中使用）- 当 `Expression` 第一次为 false 时，通知崩溃报告器。 `ensureMsgf` 将 `FormattedText` 输出到日志。

*   `ensureAlways` 和 `ensureAlwaysMsgf` （允许在构建中使用）- 如果表达式为 false，则通知崩溃报告器。 `ensureAlwaysMsgf` 将 `FormattedText` 输出到日志。

*   `unimplemented` - 如果行被触发，则停止执行，类似于 `check(false)` ，但用于应该被覆盖而不是调用的虚拟函数。

*   `checkCode` - 在 do-while 循环结构中执行 `Code` ，该结构运行一次；主要用于作为另一种检查所需信息的方式。

*   `checkNoEntry` - 如果行被触发，则停止执行，类似于 `check(false)` ，但用于应该无法访问的代码路径。

*   `checkNoReentry` - 如果行被触发超过一次，则停止执行。

*   `checkNoRecursion` - 如果一行代码在未离开作用域的情况下被多次命中，则停止执行。


内联函数是什么？

> 当函数被内联时，编译器会用函数的实际代码替换函数调用，就像代码直接写在调用位置一样。
>
> 这可以通过消除函数调用的开销来提高性能，但也可能增加可执行文件的大小。

宏和函数的区别是什么？

> 虽然宏 [7](#user-content-fn-4) 和函数 `FORCEINLINE` 都可以用来提高性能和减少代码重复，但在虚幻引擎中，通常更推荐使用函数 `FORCEINLINE` 而不是宏 [7](#user-content-fn-4) ，因为函数提供了类型安全、作用域和可见性规则，以及更好的调试支持。

## 📜 日志记录

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

所有日志都将保存在： `YourProjectName\Saved\Logs` 。

为了在编辑器中查看日志历史记录，您可以通过以下方式访问窗口： `Window -> Developer Tools -> Output Log` 。

您也可以通过控制台命令访问日志历史记录，在控制台中输入： `showlog` 。

在虚幻引擎中使用 C++向控制台记录日志，您可以使用 `UE_LOG()` 宏。这个宏接受一些参数。

1.  日志类别
2.  日志详细程度
3.  实际要记录到控制台的内容

预定义的日志类别

-   `LogPath`
-   `LogController`
-   `LogPhysics`
-   `LogBlueprint`
-   `LogBlueprintUserMessages`
-   `LogAnimation`
-   `LogRootMotion`
-   `LogLevel`
-   `LogSkeletalMesh`
-   `LogStaticMesh`
-   `LogNet`
-   `LogRep`
-   `LogNetPlayerMovement`
-   `LogNetTraffic`
-   `LogRepTraffic`
-   `LogNetFastTArray`
-   `LogNetDormancy`
-   `LogSkeletalControl`
-   `LogSubtitle`
-   `LogTexture`
-   `LogPlayerManagement`
-   `LogSecurity`
-   `LogEngineSessionManager`
-   `LogHAL`
-   `LogSerialization`
-   `LogUnrealMath`
-   `LogUnrealMatrix`
-   `LogContentComparisonCommandlet`
-   `LogNetPackageMap`
-   `LogNetSerialization`
-   `LogMemory`
-   `LogProfilingDebugging`
-   `LogCore`
-   `LogOutputDevice`
-   `LogSHA`
-   `LogStats`
-   `LogStreaming`
-   `LogInit`
-   `LogExit`
-   `LogExec`
-   `LogScript`
-   `LogLocalization`
-   `LogLongPackageNames`
-   `LogProcess`
-   `LogLoad`
-   `LogTemp`

最常见的日志类别，你可能会使用，是 `LogTemp` 和 `LogBlueprintUserMessages` 用于蓝图消息。

您也可以通过使用 `DECLARE_LOG_CATEGORY_EXTERN()` 和 `DEFINE_LOG_CATEGORY()` 宏来定义自己的日志类别。

在您的头文件中，您可以这样写：

```cpp
// .h

// Arguments:
// 1. Name of your custom category. You can use LogTemp if you don't want to define a category.
// 2. Default verbosity when one is not specified. The most common value is Log.
// Valid verbosity levels are: Fatal, Error, Warning, Display, Log, Verbose, VeryVerbose
// 3. Maximum verbosity level to allow when compiling. Can also be All
DECLARE_LOG_CATEGORY_EXTERN(MyLogCategory, Log, All);
```

然后在源文件中，您可以这样写：

```cpp
// .cpp

// Define the log category
DEFINE_LOG_CATEGORY(MyLogCategory);
```

现在您可以通过包含头文件来重用日志类别。

这是详细程度级别的类型列表：

| 详细程度级别 | 是否打印在控制台？ | 是否打印在编辑器日志中？ | 注释 |
| --- | --- | --- | --- |
| 致命 | 是 | 不适用 | 导致会话崩溃，即使禁用了日志记录 |
| 错误 | 是 | 是 | 日志文本为红色 |
| 警告 | 是 | 是 | 日志文本为黄色 |
| 显示 | 是 | 是 | 日志文本为灰色 |
| 日志 | 否 | 是 | 日志文本为灰色 |
| 详细 | 否 | 否 |  |
| 非常详细 | 否 | 否 |  |

你也可以覆盖一些现有的详细程度级别。这些设置可以在 `Engine.ini` 或 `DefaultEngine.ini` 中设置。

这是关于详细程度设置的示例：

```ini
[Core.Log]
Global=<Category>=<DesiredVerbosityLevel>
```

**这里有两个示例：**

使用简单的字符串输出到控制台：

```cpp
UE_LOG(LogTemp, Warning, TEXT("Hello"));
```

类似于 C++ 中的 `sprintf()` 函数，你可以将特定的不同参数传递给字符串格式化器。有几种参数类型需要了解。

<table><tbody><tr><td>%s - 字符串 %d 或 %i - 整数和布尔值 %f - 浮点数（float 和 double）</td></tr></tbody></table>

如何使用 `FString` 作为参数将日志输出到控制台：

```cpp
UE_LOG(LogTemp, Warning, TEXT("The Actor's name is: %s"), *YourActor->GetName());
```

<Callout type="success">
  您可以使用 `__func__` 、 `__FUNCTION__` 或 `__PRETTY_FUNCTION__` 获取函数名称，并在日志中打印出来。但是，要添加这个字符串，您必须将其转换为 TCHAR 指针。通过使用 `ANSI_TO_TCHAR()` 宏。
</Callout>

不幸的是， `UE_LOG` 不支持 `bool` 数据类型。

为了使用 `UE_LOG` 打印布尔值，您可以使用 `%i` 或 `%d` 将 `bool` （布尔值）转换为 `int32` （整数）。

使用 `bool` 作为参数将信息输出到控制台：

```cpp
bool bMyBoolean = true;

// You can either use %d or %i. Both will print an integer.
UE_LOG(LogTemp, Log, TEXT("The boolean value is: %i"), bMyBoolean); // The boolean value is: 1

// True -> 1
// False -> 0
```

你也可以将布尔值转换为字符串：

```cpp
bool bMyBoolean = false;

UE_LOG(LogTemp, Log, TEXT("The boolean value is: %s"), (bMyBoolean ? TEXT("true") : TEXT("false"))); // The boolean value is: false
```

使用 `int32` 作为参数在控制台记录日志：

```cpp
int32 MyInteger = 1337;
UE_LOG(LogTemp, Log, TEXT("The integer value is: %d"), MyInteger); // The integer value is: 1337
```

使用 `float` 作为参数在控制台记录日志：

```cpp
float MyFloat = 99.999999f;
UE_LOG(LogTemp, Log, TEXT("The float value is: %f"), MyFloat); // The float value is: 99.999999
```

使用 `double` 作为参数在控制台记录日志：

```cpp
double MyDouble = 3.1415926535897931;
UE_LOG(LogTemp, Log, TEXT("The double value is: %f"), MyDouble); // The double value is: 3.1415926535897931
```

使用 `FVector` 作为参数将日志输出到控制台：

```cpp
FVector MyVector = FVector::OneVector;

// In order to log a FVector, you need to convert into a string.
UE_LOG(LogTemp, Log, TEXT("The vector value is: %s"), *MyVector.ToString()); // The vector value is: (1, 1, 1)
```

使用 `FName` 作为参数将日志输出到控制台：

```cpp
// In order to log a FName, you need to convert into a string.
UE_LOG(LogTemp, Log, TEXT("The name is: %s"), *MyCharacter->GetFName().ToString());
```

在打印浮点数时，您还可以更改小数点。

这有助于提高可读性。

使用 `.2` 将指定小数点后两位。

这里有一个示例：

```cpp
double MyDouble = 3.1415926535897931;
UE_LOG(LogTemp, Log, TEXT("The double value is: %.2f"), MyDouble); // The double value is: 3.14
UE_LOG(LogTemp, Log, TEXT("The double value is: %.0f"), MyDouble); // The double value is: 3
UE_LOG(LogTemp, Log, TEXT("The double value is: %,2f"), MyDouble); // The double value is: 3,14
```

### UE\_LOGFMT

<table><tbody><tr><td>UE_LOG 非常冗长，需要开发者不断用 TEXT 宏包裹日志文本。 UE_LOG 也不支持打印基本类型，例如 bool 或 FStrings ，这是 Unreal 的标准字符串类型。 UE_LOG 在打印不同变量（如浮点数、整数、布尔值、字符串）时需要识别类型。</td></tr></tbody></table>

在 Unreal Engine 5.2 中，你可以使用 `UE_LOGFMT()` 宏来替代！新的 `UE_LOGFMT()` 宏可以解决许多这些问题。

这里有一个使用示例：

包含头文件：

```cpp
#include "Logging/StructuredLog.h"
```

然后要记录到控制台，只需编写：

```cpp
UE_LOGFMT(LogTemp, Log, "This message will print to my log");
```

要添加一些参数，可以编写：

```cpp
FString Name("SomeName");
int32 Value = 999;

UE_LOGFMT(LogTemp, Log, "Printing my Name: {0} with Value: {1}", Name, Value); // Printing my Name: SomeName with Value: 999
```

这里有几个例子：

```cpp
UE_LOGFMT(LogCore, Warning, "Loading '{0}' failed with error {1}", Package->GetName(), ErrorCode);
```

```cpp
UE_LOGFMT(LogCore, Warning, "Loading '{Name}' failed with error {Error}", ("Error", ErrorCode), ("Name", Package->GetName()), ("Flags", LoadFlags));
```

<Callout> FText 不支持 `UE_LOGFMT()` ，要使用 `FText` ，需要通过调用 `ToString()` 函数将其转换为 `FString` 。</Callout>

### 记录到游戏视图

目前我们只记录到控制台。为了在游戏视图中显示控制台消息，我们需要调用 `AddOnScreenDebugMessage()` 函数。您可以在全局引擎变量（ `GEngine` ）中访问此函数。

这里有一个示例：

```cpp
/*

    void AddOnScreenDebugMessage
    (
        uint64 Key, // A unique key to prevent the same message from being added multiple times.
        float TimeToDisplay, // How long to display the message, in seconds.
        FColor DisplayColor, // The color to display the text in.
        const FString & DebugMessage, // The message to display.
        bool bNewerOnTop,
        const FVector2D & TextScale
    )

    Add a FString to the On-screen debug message system. bNewerOnTop only works with Key == INDEX_NONE
    This function will add a debug message to the onscreen message list. It will be displayed for FrameCount frames.

*/

GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::White, TEXT("This message will appear on the screen!"));
```

并且为了向此函数提供参数，您需要使用 `FString::Printf()` ，它类似于 `sprintf()` 函数和 `UE_LOG()` 宏。

这是一个示例，如何使用 `FString::Printf()` 函数 `AddOnScreenDebugMessage()` 函数：

```cpp
GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, FString::Printf(TEXT("Some variable values: x = %f, y = %f"), x, y));
```

## 🪨 断言

<table><tbody><tr><td>本节由 ChatGPT 共同编写。</td></tr></tbody></table>

![Assertions](/static-img/Assertions.png)

断言是一种编程技术，用于检测和报告代码中的错误或意外行为。在 Unreal Engine 中，提供了断言宏，以便更容易地将断言添加到代码中，并在断言失败时自定义引擎的行为。

### 检查

用于在运行时测试条件，并在条件失败时报告错误。如果条件为假， `check(Expression)` 宏将向控制台打印错误消息，并根据引擎的配置停止游戏或进入调试器。

`check(Expression)` 宏通常用于检测编程错误或意外的运行时条件。

```cpp
void MyFunction()
{
    APlayerCharacter* PC = Cast<APlayerController>(GetController());

    // If the condition returns false, the game will crash.
    // By default, C++ and Unreal has some overloads for pointers and classes, which allows them to return as boolean.
    check(PC);

    // But, if you wish to be explicit:
    check(PC != nullptr);
}
```

### 验证

与 `check(Expression)` 宏类似，但仅在引擎的调试版本中启用。如果条件为假， `verify(Expression)` 宏会进入调试器但不会停止游戏。

`verify(Expression)` 宏通常用于开发或测试期间检测错误，但不会影响最终发布构建的性能。

```cpp
void MyFunction()
{
    APlayerCharacter* PC = Cast<APlayerController>(GetController());

    // Same as 'check' assertion.
    // However, this assertion will include in all builds (including shipping builds).
    verify(PC);
}
```

### 确保

与 `check(Expression)` 宏类似，但用于测试对程序不一定致命的条件。如果条件为假， `ensure(Expression)` 宏会将警告消息打印到控制台，并根据引擎的配置停止游戏或进入调试器。

`ensure(Expression)` 宏通常用于检测非致命错误或可恢复的意外情况。

```cpp
void MyFunction()
{
    APlayerCharacter* PC = Cast<APlayerController>(GetController());

    // Non-critical check (assertion only during development and editor builds).
    // This will only call once and will not retrigger for each play.
    ensure(PC);

    // To have this assertion retriggerable, then use this macro instead:
    ensureAlways(PC);
}
```

### 替代断言

还有显示文本的替代宏 [7](#user-content-fn-4) 。

- `checkf(Expression, FormattedText, ...)` 或 `checkfSlow(Expression, FormattedText, ...)` - 如果 `Expression` 为假则停止执行，并将 `FormattedText` 输出到日志
- `verifyf(Expression, FormattedText, ...)` 或 `verifySlow(Expression, FormattedText, ...)` - 如果 `Expression` 为假，则停止执行并输出 `FormattedText` 到日志
- `ensureMsgf(Expression, FormattedText, ...)` - 在第一次 `Expression` 为 `false` 时通知崩溃报告器并将 `FormattedText` 输出到日志中
- `ensureAlwaysMsgf(Expression, FormattedText, ...)` - 如果 `Expression` 为假，则通知崩溃报告器并将 `FormattedText` 输出到日志

示例：

```cpp
void MyFunction() {
    APlayerCharacter* PC = Cast<aplayercontroller>(GetController());
    checkf(PC, TEXT("Player character cannot be null!"));
    ULocalPlayer LP = PC->GetLocalPlayer();
    verifyf(LP, TEXT("Local player cannot be null in shipping builds!"));
    bool bIsDead = false;
    ensureMsgf(bIsDead, TEXT("Player shouldn't be dead!"));
}
```

### 杂项断言

还有一个 `unimplemented` 断言宏。适用于编写需要代码的函数，但目前尚未实现。

```cpp
void DoSomething()
{
    unimplemented();
}
```

另一个断言宏是 `checkCode` 。这是一个用于检查代码有效性的断言宏。在后台，代码运行在一个 while 条件设为 false 的 do-while 循环中。这可以防止循环。使用这种技术的重点是清理内存，以及能够使用 `continue` 或 `break` 关键字。

```cpp
checkCode(
    if (ObjectItem->IsPendingKill())
    {
        UE_LOG(LogGarbage, Fatal, TEXT("Object %s is part of root set though has been marked RF_PendingKill!"), *Object->GetFullName());
    }
);
```

最后，我们有 `checkNoEntry` 、 `checkNoReentry` 和 `checkNoRecursion` 断言宏。

*   `checkNoEntry` 表示代码永远不会被执行。
*   `checkNoReentry` 表示代码不应被执行多次。
*   `checkNoRecursion` 表示代码永远不应该递归调用。

```cpp
void KillPlayer()
{
    PlayerPtr->Destroy();
    PlayerPtr = nullptr;

    if (IsValid(Player))
    {
        checkNoEntry();
    }
}

void CleanupCharacters(int32 Count)
{
    if (Count > 3)
        return;

    checkNoRecursion();

    if (IsValid(Player))
    {
        checkNoReentry();
        KillPlayer();
    }

    CleanupCharacters(Count + 1);
}
```

* * *

您可以从文档中了解更多关于断言的信息。

您也可以从 Sneaky Kitty Game Dev 观看关于它的视频。

* * *

| 断言 | 描述 | 用例 |
| --- | --- | --- |
| check | 一个用于在虚幻引擎中运行时检查的宏，仅在调试版本中启用。 | \- 验证代码中的前提条件或假设。- 确保在开发和调试过程中满足关键条件。 |
|  | 如果 check 宏中指定的条件评估为假，则会触发断言失败，在 Debug 模式下停止程序执行，允许开发人员识别和修复问题。 | \- 在开发过程中检测潜在的 bug 或逻辑错误。- 识别在测试或调试过程中不应出现的意外情况。 |
|  | 在非 Debug 构建中， check 宏会被编译出去，因此它对游戏发布版本的性能没有影响。 |  |
|  |  |  |
| verify | 一个类似于 check 的宏，用于虚幻引擎中的运行时检查，但它同时在 Debug 和 Release 构建中启用。 | \- 与 check 类似的使用场景，但目的是在 Debug 和 Release 构建中检测问题。- 用于生产环境中的关键运行时检查。 |
|  | 如果 verify 宏中指定的条件评估为假，它会在 Debug 和 Release 构建中触发断言失败，停止程序的执行。 |  |
|  | 这有助于在游戏或应用程序的最终发布版本中识别和修复关键问题。 |  |
|  |  |  |
| ensure | 专为虚幻引擎设计的宏，用于运行时检查，重点在于提高发布游戏中代码的健壮性。 | \- 验证并强制执行代码中的假设、前提条件和不变量，以避免在生产环境中出现崩溃和意外行为。 |
|  | ensure 宏在 Debug 和 Release 构建中都保持激活状态，其行为可以在 Unreal Editor 项目设置中配置。 | \- 在发布构建中， ensure 可以设置为记录消息或执行安全失败操作，而不是停止程序的执行。 |
|  | 如果 ensure 宏中指定的条件评估为 false，它可能会触发断言或根据项目设置执行替代操作。 |  |

## 🔔 委托

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

![Delegates](/static-img/Delegates.png)

委托本质上是一种类型安全的函数指针，可以用来将一个或多个函数绑定到事件上，然后在事件发生时触发这些函数。

在蓝图（Blueprint）中，你可能会遇到"事件分发器"，其底层实际上就是多播委托。

Unreal 使用三种类型的委托：单播、多播和动态。

动态或非动态基本手段，如果我们想通过反射系统 [8](#user-content-fn-1) 在蓝图内部支持绑定函数，这通常会导致性能变慢。而非动态仅支持在 C++代码内部绑定函数。

然后，我们有广播和多播委托。广播支持多个监听器并一次性执行它们。而单播委托在任何时候只支持一个监听器。

您可以在虚幻引擎的文档中了解更多关于广播委托的信息。

### 定义一个委托类型

要定义动态多播委托，你可以通过这个宏声明： `DECLARE_DYNAMIC_MULTICAST_DELEGATE()` ，它需要一个委托的名称作为参数。

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMyDelegate);
```

要定义非动态多播委托，你可以通过这个宏声明： `DECLARE_MULTICAST_DELEGATE()` ，它需要一个委托的名称作为参数。

```cpp
DECLARE_MULTICAST_DELEGATE(FMyDelegate);
```

要定义动态单播委托，你可以通过这个宏声明： `DECLARE_DYNAMIC_DELEGATE()` ，它需要一个委托的名称作为参数。

```cpp
DECLARE_DYNAMIC_DELEGATE(FMyDelegate);
```

要定义非动态单播委托，你可以通过这个宏声明： `DECLARE_DELEGATE()` ，它需要一个委托的名称作为参数。

```cpp
DECLARE_DELEGATE(FMyDelegate);
```

### 声明委托变量

一旦定义了委托类型，你就可以声明该类型的委托变量。这需要使用 `UPROPERTY()` 宏来确保委托变量能被虚幻引擎正确管理。

```cpp
UPROPERTY(BlueprintAssignable)
FMyDelegate MyEvent;
```

### 将函数绑定到委托

在声明了动态委托变量后，你可以使用 `BindDynamic()` 宏将其绑定一个或多个函数。

这些都是宏，将帮助你编写更小的代码。在幕后，它将自动生成函数名称字符串。该宏接受一个指向拥有该函数的对象的引用、函数的名称以及一个可选的用户数据参数。

*   `BindDynamic(UserObject, FuncName, ...)`
*   `AddDynamic(UserObject, FuncName)`
*   `RemoveDynamic(UserObject, FuncName)`

```cpp
MyEvent.BindDynamic(this, &AMyActor::MyFunction);
```

```cpp
MyEvent.AddDynamic(this, &AMyActor::MyFunction);
```

```cpp
MyEvent.RemoveDynamic(this, &AMyActor::MyFunction);
```

带一些参数：

```cpp
MyEvent.BindDynamic(this, &AMyActor::MyFunction, 100, true, TEXT("Hello, World!"));
```

以下是用于非动态单委托的绑定函数列表：

*   `Bind()` - 绑定到一个现有的委托对象。这允许你将一个委托绑定到现有的委托，从而以一种更灵活的方式将委托绑定在一起。

*   `BindLambda()` - 绑定一个函数对象。这通常用于 lambda 函数。函数对象按值存储，因此确保它足够小且易于复制。

*   `BindRaw()` - 绑定一个原始 C++指针委托。由于原始指针不使用任何形式的引用，在删除目标对象后调用 `Execute()` 或 `ExecuteIfBound()` 是不安全的。

*   `BindStatic()` - 绑定一个原始 C++指针全局函数委托。这适用于绑定到任何类都不是成员的全局函数。

*   `BindSP()` - 绑定一个基于共享指针的成员函数委托。共享指针委托对你的对象保持一个弱引用。你可以使用 `ExecuteIfBound()` 来调用它们。

*   `BindUFunction()` - 绑定一个 `UFunction` 代理。这允许你绑定到蓝图函数或 `UObject` 子类中的函数。当代理被执行时，它将调用绑定时对象上的函数。如果对象被垃圾回收，代理将不会被执行。如果函数仍然有效，你可以使用 `ExecuteIfBound()` 来调用它。

*   `BindUObject()` - 绑定一个 `UObject` 成员函数代理。 `UObject` 代理保持对目标 `UObject` 的弱引用。你可以使用 `ExecuteIfBound()` 来调用它们。

*   `BindWeakLambda()` - 绑定一个保持对绑定对象弱引用的函数对象。这允许你将代理绑定到一个可能被垃圾回收的对象。当代理被执行时，它将检查对象是否仍然有效。如果是，它将调用函数对象。如果不是，代理将不会被执行。

*   `BindThreadSafeSP()` - 绑定一个基于共享指针的成员函数代理，该代理在任何线程中调用都是安全的。这与 `BindSP()` 类似，但它使用线程安全的引用计数方案。

*   `UnBind()` - 解绑此代理。这将清除代理，因此当被触发时不会执行。


以下是静态多播代理的绑定函数列表：

*   `Add()` - 将一个函数代理添加到此多播代理的调用列表中。当调用 `Broadcast()` 函数时，代理将被执行。

*   `AddLambda()` - 将一个函数对象（如 lambda、std::function 或函数对象类）作为代理添加。当调用 `Broadcast()` 函数时，代理将被执行。

*   `AddRaw()` - 添加一个原始 C++指针代理。当调用 `Broadcast()` 函数时，代理将被执行。代理将使用指定的参数被调用。

*   `AddStatic()` - 添加一个原始 C++指针全局函数代理。当调用 `Broadcast()` 函数时，代理将被执行。代理将使用指定的参数被调用。

*   `AddSP()` - 添加一个基于共享指针（快速，非线程安全）的成员函数代理。共享指针代理会保持对您对象的弱引用。当调用 `Broadcast()` 函数时，代理将被执行。代理将使用指定的参数被调用。

*   `AddUObject()` - 添加一个基于 UObject 的成员函数代理。UObject 代理会保持对您对象的弱引用。当调用 `Broadcast()` 函数时，代理将被执行。代理将使用指定的参数被调用。

*   `AddUFunction()` - 添加一个 UFunction 委托。当调用 `Broadcast()` 函数时，该委托将被执行。委托将使用指定的参数被调用。

*   `AddWeakLambda()` - 添加一个保持对绑定对象弱引用的 functor。这允许你将委托绑定到一个可能被垃圾回收的对象。当委托被执行时，它会检查对象是否仍然有效。如果是，它将调用 functor。如果不是，委托将不会被执行。当调用 `Broadcast()` 函数时，委托将被执行。委托将使用指定的参数被调用。

*   `AddThreadSafeSP()` - 添加一个基于共享指针的成员函数委托，该委托可以从任何线程安全地调用。这与 `AddSP()` 类似，但它使用线程安全的引用计数方案。当调用 `Broadcast()` 函数时，委托将被执行。委托将使用指定的参数被调用。


### 触发委托

最后，您可以通过调用 `Broadcast()` 方法来触发多播代理。这将导致所有绑定的函数使用指定的参数被调用。

```cpp
MyEvent.Broadcast();
```

您也可以通过调用 `Execute()` 或 `ExecuteIfBound()` 方法来触发单个代理。这将导致绑定的函数使用指定的参数被调用。

```cpp
// If delegate is not bound, this will cause a crash.
MyEvent.Execute();

// Use this function, if you are unsure, if the delegate is bound or not.
MyEvent.ExecuteIfBound();

// You can also do manual checking, before calling ´Execute()´ function.
bool bIsBound = MyEvent.IsBound();
```

### 总结

通过使用代理，开发者可以创建模块化和灵活的事件系统，这些系统可以轻松地扩展和定制。

委托可用于响应用户输入、游戏状态变化或其他类型的事件来触发事件，并可用于实现各种游戏功能和机制。

<Callout type="success"> 这里是 BenUI 提供的在线工具，用于帮助您创建委托宏。</Callout>

<Callout type="success"> 尽量在不需要计时的情况下使用委托。这有助于节省计时性能。</Callout>

<Callout type="error">
如果您使用原始绑定绑定委托，并且在之后没有解除绑定，当 `UObject` 被销毁时。这将导致内存泄漏。因为，即使 `UObject` 不再活跃，绑定仍然存在。因此，建议直接绑定 `UObject` 或 `UFunction` 。
</Callout>

| 类型 | 绑定 C++函数 | 绑定 UFUNCTION |
| --- | --- | --- |
| 单播 | 是 | 是 |
| 组播 | 是 | 否 |
| 事件（已弃用） | 是 | ? |
| 动态单播 | 否 | 是 |
| 动态组播 | 否 | 是 |
| FTimerDelegate (单播) | 是 | 是 |
| FTimerDynamicDelegate (动态单播) | 否 | 是 |

## 🧩 UMG

<table><tbody><tr><td>这一部分是与 ChatGPT 共同编写的。</td></tr></tbody></table>

UMG（虚幻引擎运动图形）是虚幻引擎中的一种可视化界面设计工具，能够为游戏和应用创建用户界面（UI）和交互元素。它提供了一个用户友好的、基于节点的系统，用于设计 UI 元素并将它们连接到 C++代码以实现功能和交互。

你可以在文档中了解更多信息。

还有一个关于 Lively Geek 制作的 UMG Widget 与 C++的视频。

### 使用 C++的 UMG

要在虚幻引擎中从 C++控制蓝图创建的组件，您可以使用 `BindWidget` 元属性。这个强大的功能允许您在虚幻运动图形（UMG）编辑器中创建的组件与相应的 C++变量之间建立连接。

通过将 `BindWidget` 元属性应用于 C++变量，您可以建立组件和变量之间的链接，从而在您的 C++代码中直接访问组件的属性和功能。

这里有一个示例，演示如何使用 `BindWidget` 。

```cpp
UPROPERTY(meta=(BindWidget)) // Binding via UMG editor
UTextBlock* PlayerDisplayNameText;
```

在这个示例中， `PlayerDisplayNameText` 变量被声明为 `UTextBlock*` 类型，表示一个文本小部件。 `meta=(BindWidget)` 属性表明这个变量绑定到了 UMG 编辑器中创建的小部件。

有了这个绑定，你现在可以直接从 C++ 代码中访问和控制 `PlayerDisplayNameText` 小部件的所有属性和函数。这允许你操作小部件的外观、处理用户交互，并根据游戏逻辑或用户输入动态更新其内容。

这里有一个展示小部件使用的示例：

```cpp
#include "MainMenu.h"

void UMainMenu::NativeConstruct()
{
    if (PlayerDisplayNameText == nullptr)
        return;

    PlayerDisplayNameText->OnClicked.AddDynamic(this, &UMainMenu::UpdatePlayerDisplayName);
}

void UMainMenu::UpdatePlayerDisplayName()
{
    if (PlayerDisplayNameText == nullptr)
        return;

    const FString& NewDisplayName = TEXT("John Doe");
    PlayerDisplayNameText->SetText(FText::FromString(NewDisplayName));
}
```

在这个示例中，假设我们有一个自定义玩家角色类，名为 `AMyPlayerCharacter` 。 `UpdatePlayerDisplayName()` 函数接收一个 `NewDisplayName` 作为参数，该参数表示玩家更新的显示名称。

在函数内部，我们检查 `PlayerDisplayNameText` 组件是否有效。如果有效，我们使用 `SetText()` 函数来更新组件显示的文本。在这种情况下，我们使用 `FText::FromString` 将 `NewDisplayName` 字符串转换为 FText 对象，然后再将其分配给 `PlayerDisplayNameText` 组件。

您可以从 BenUI 的文章中了解更多关于使用 C++绑定组件的信息。

### UI 缓动库

BenUI 还创建了一个免费的实用插件，帮助您在 C++中动画化 UMG。插件可以从 github [9](#user-content-fn-5) 安装。仓库链接。

这是来自 UI 过渡库的一个示例：

```cpp
UBUITween::Create( SomeWidget, 0.2f )
	.FromTranslation( FVector2D( -100, 0 ) )
	.FromOpacity( 0.2f )
	.ToTranslation( FVector2D( 20, 10 ) )
	.ToOpacity( 1.0f )
	.Begin();
```

## 📚 创建自定义模块

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

在虚幻引擎中，模块是一种将游戏代码组织成更小片段的方式，类似于 Unity 的汇编定义。通过将代码分离到模块中，你可以减少编译时间并使代码更加有组织。

例如，你可以创建一个名为 `Vehicle` 的模块来包含所有与车辆系统相关的代码。这将使你能够将车辆代码与其他游戏部分（如库存系统）隔离开来，并使维护和更新变得更加容易。

<Callout> Unreal Engine 模块与 C++ 20 模块无关。</Callout>

您可以在此处了解更多关于 Unreal Engine 模块的信息！

以下是 Unreal Engine 常用模块列表：

<table><tbody><tr><td>核心 CoreUObject InputCore Engine UnrealEd SlateCore Slate UMG UMGEditor</td></tr></tbody></table>

使用模块也可以帮助你专注于你正在实现的具体功能，因为你只需要处理与该模块相关的代码。

### 模块结构

所有模块都应该放在插件或项目的源目录中。模块的根文件夹应该与相应的模块同名。

每个模块的根文件夹中还应有一个\[模块名\].Build.cs 文件，其 C++代码应包含在 Private 和 Public 文件夹中。

![image](https://user-images.githubusercontent.com/61658252/236797649-1acb5aac-ab05-4676-86a4-959e443de404.png)

### 模块代码

```csharp
// Gameplay.Build.cs

using UnrealBuildTool;

public class Gameplay : ModuleRules
{
    public Gameplay(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicIncludePaths.AddRange(new string[]
        {
            // ... add public include paths required here ...
        });


        PrivateIncludePaths.AddRange(new string[]
        {
            // ... add other private include paths required here ...
        });


        PublicDependencyModuleNames.AddRange(new string[]
        {
            "Core",
            // ... add other public dependencies that you statically link with here ...
        });

        PrivateDependencyModuleNames.AddRange(new string[]
        {
            // ... add private dependencies that you statically link with here ...

            // NOTE, private dependencies will not be required to import in other modules
            // This means, if you require a plugin but don't want to import in other modules, here is the list for that.
        });

        DynamicallyLoadedModuleNames.AddRange(new string[]
        {
            // ... add any modules that your module loads dynamically here ...
        });
    }
}
```

```cpp
// Private/GameplayModule.cpp

#include "Modules/ModuleManager.h"

// NOTE, this macro is handling the default implementation for a module setup.
IMPLEMENT_MODULE(FDefaultModuleImpl, Gameplay);
```

如果您需要为模块进行更多设置（编辑器上的回调），您必须为该模块创建一个特定的类。

以下是模块类的完整设置：

```cpp
// Private/GameplayModule.cpp

#include "GameplayModule.h"

#define LOCTEXT_NAMESPACE "FGameplayModule"

void FGameplayModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FGameplayModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FGameplayModule, Gameplay)
```

```cpp
// Public/GameplayModule.h

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FGameplayModule : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	void StartupModule() override;
	void ShutdownModule() override;
};
```

### ♻️ 循环依赖

当多个模块访问同一个模块时，可能会遇到循环依赖。这种情况发生在模块 A 依赖于模块 B，而模块 B 也依赖于模块 A 时。

要解决循环依赖问题，可以采取几种方法：

*   一种方法是在\[ModuleName\].Build.cs 文件中使用 `CircularlyReferencedDependentModules` 语句。你可以在这里了解更多信息！

这里有一个示例：

```cpp
using UnrealBuildTool;

public class ModuleB : ModuleRules
{
    public ModuleB(ReadOnlyTargetRules Target) : base(Target)
    {
        PrivateDependencyModuleNames.AddRange(new string[]
        {
            "ModuleA"
        });

        CircularlyReferencedDependentModules.Add("ModuleA");  // Avoid circular dependencies errors!
    }
}
```

*   另一种选择是创建另一个模块，将代码进一步拆分成更小的部分。

*   最后，你也可以重构你的模块，完全避免循环依赖。


*最佳解决方案将取决于你的具体情况和代码的复杂性。*

## 💡 创建自定义插件

<table><tbody><tr><td>这一部分是与 ChatGPT 共同编写的。</td></tr></tbody></table>

插件是虚幻引擎的一个强大功能，允许开发者轻松扩展和自定义引擎的功能以满足其特定需求。插件本质上是一个可以添加到虚幻引擎项目中的模块，用于提供附加功能、工具和内容。与模块不同，插件设计为自包含的，并且可以在多个项目中共享。

当你创建一个插件时，你可以定义自己的模块、内容和资源，这些可以在你的项目中加载和使用。插件可以包含任意数量的模块，每个模块都有自己的类、资源和功能。这使你能够保持代码的条理清晰和分离，从而更容易管理和维护。

**使用插件的最大优势之一是它们可以与其他开发者共享，这使得创建和分发自定义功能到虚幻引擎社区变得容易。你甚至可以在虚幻市场销售你的插件，并通过你的工作获得收入。**

插件也可以用于添加对第三方库和工具的支持，例如物理引擎或音频系统。这使得将这些工具轻松集成到您的游戏中，并利用其功能，而无需从头开始编写自定义代码。

*您可以在这里了解更多关于插件的信息！*

## 📝 预处理器

<table><tbody><tr><td>本节是使用 ChatGPT 共同编写的。</td></tr></tbody></table>

在编程语言中，包括 C++，预处理器是编译器的一个组件，在真正的编译过程之前执行文本操作。它作用于源代码，并处理以井号符号 # 开头的指令。

在 C++中，预处理器处理诸如宏扩展、文件包含和条件编译等任务。它根据这些指令修改源代码，然后再将代码编译成机器可读的指令。

预处理器可用于定义宏，这些宏是在编译阶段之前由预处理器执行的文本替换。宏 [7](#user-content-fn-4) 允许代码重用、条件编译和其他预处理操作。像 `#include` 这样的指令用于包含头文件，而像 `#ifdef` 、 `#ifndef` 、 `#if` 和 `#endif` 这样的条件指令则用于根据特定条件进行条件编译。

你可以在 cppreference.com 上了解更多关于预处理器的内容。

你还可以观看由 NeuralNine 制作的名为"Preprocessor Directives"的视频。

### Pragma once

`#pragma once` 是 C++头文件中使用的预处理指令，用于确保在源文件编译过程中头文件只被包含一次，无论它被引用多少次。

它是传统头文件保护机制的一种替代方案，传统机制使用 #ifndef 和 #define 语句来防止多次包含。 `#pragma once` 是一种更简单、更高效的方法来实现相同的效果，并且被大多数现代编译器所支持。

这是一个示例：

```cpp
#pragma once

#include "Vehicle.generated.h"

UINTERFACE(BlueprintType)
class COMMONVEHICLE_API UVehicle : public UInterface
{
    GENERATED_UINTERFACE_BODY()
};

class COMMONVEHICLE_API IVehicle
{
    GENERATED_IINTERFACE_BODY()
    // ...
};
```

### 移除编辑器功能

在 Unreal Engine 中使用 C++通过预处理指令移除编辑器功能是一个好习惯，因为它允许高效编译，并通过排除特定于编辑器但最终游戏构建不需要的代码来减小最终可执行文件的大小。

以这个场景为例。

这是一个示例：

```cpp
#if WITH_EDITORONLY_DATA
    UPROPERTY(VisibleAnywhere)
    UArrowComponent* ArrowComponent;
#endif

#if WITH_EDITOR
void SetupArrow()
{
  ArrowComponent->SetArrowColor(FLinearColor::Yellow);
}
#endif
```

在这个场景中， `ArrowComponent` 不需要用于最终构建。仅在编辑器版本中需要。因此，通过使用预处理器，我们可以将其标记为移除。当 Unreal Engine 正在构建/打包游戏时，这段代码将被移除。

您也可以将 `#elif` 用作 `else if` ，将 `#else` 用作 `else` ，以便分支移除过程。

这是对此的更新示例：

```cpp
#if WITH_EDITORONLY_DATA
    UPROPERTY(VisibleAnywhere)
    UArrowComponent* ArrowComponent;
#endif

void SetupArrow()
{
#if WITH_EDITOR
    ArrowComponent->SetArrowColor(FLinearColor::Yellow);
#else
    GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Some debug message!"));
#endif
}

```

您也可以使用 `UE_BUILD_SHIPPING` 进行否定，以隔离调试代码，这样它就不会在发布版本中被编译。

示例：

```cpp
void APlayerCharacter::Kill()
{
#if !UE_BUILD_SHIPPING
    GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT("Hello, World!"));
#endif
}
```

## 🦄 单位

使用 UHT [3](#user-content-fn-2) ，您可以指定 UPROPERTY 值的特定单位。Epic 已经提供了一些基本单位，其中包括公制和英制单位。

这是 Epic 提供的一些单位列表：

```cpp
/** Enum *must* be zero-indexed and sequential. Must be grouped by relevance and ordered by magnitude. */
/** Enum *must* match the mirrored enum that exists in CoreUObject/Classes/Object.h for the purposes of UObject reflection */
enum class EUnit : uint8
{
    /** Scalar distance/length units */
    Micrometers, Millimeters, Centimeters, Meters, Kilometers,
    Inches, Feet, Yards, Miles,
    Lightyears,

    /** Angular units */
    Degrees, Radians,

    /** Speed units */
    CentimetersPerSecond, MetersPerSecond, KilometersPerHour, MilesPerHour,

    /** Temperature units */
    Celsius, Farenheit, Kelvin,

    /** Mass units */
    Micrograms, Milligrams, Grams, Kilograms, MetricTons,
    Ounces, Pounds, Stones,

    /** Force units */
    Newtons, PoundsForce, KilogramsForce, KilogramCentimetersPerSecondSquared,

    /** Torque Units */
    NewtonMeters, KilogramCentimetersSquaredPerSecondSquared,

    /** Frequency units */
    Hertz, Kilohertz, Megahertz, Gigahertz, RevolutionsPerMinute,

    /** Data Size units */
    Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes,

    /** Luminous flux units, luminous intensity, illuminance, luminance, exposure value */
    Lumens, Candela, Lux, CandelaPerMeter2, ExposureValue,

    /** Time units */
    Nanoseconds, Microseconds, Milliseconds, Seconds, Minutes, Hours, Days, Months, Years,

    /** Pixel density units */
    PixelsPerInch,

    /** Arbitrary multipliers */
    Percentage,	Multiplier,

    /** Stress units */
    Pascals, KiloPascals, MegaPascals, GigaPascals,

    /** Symbolic entry, not specifiable on meta data */
    Unspecified
};
```

指定特定单位类的枚举：

```cpp
enum class EUnitType
{
    Distance, Angle, Speed, Temperature, Mass, Force, Torque, Frequency, DataSize, LuminousFlux, LuminousIntensity, Illuminance, Luminance, Time, PixelDensity, Multipliers, ExposureValue, Stress,

    // Symbolic entry - do not use directly
    NumberOf,
};
```

### 使用 UHT 的用例：

现在，我们知道有哪些类型的单位了。现在我们可以在代码中使用它们。

首先我们可以使用 UHT [3](#user-content-fn-2) ，通过指定 meta 标签来使用它们。

```cpp
UPROPERTY(meta = (Units = "kg"))
float MassInKg{ 10.0f };
```

默认情况下，Unreal 会覆盖你的单位，使用该类别的相应单位。例如，如果我指定我的质量变量使用磅，Unreal 会覆盖并使用千克。

如果你想要禁用这个功能，那么你可以使用指定符 `ForceUnits` 。

```cpp
UPROPERTY(meta = (ForceUnits = "lbs"))
float MassInPounds{ 22.0f };
```

### 代码使用案例

虚幻引擎也有一个用于处理单位转换的类。

这里是一个使用转换类的示例：

```cpp
float Distance = 15.535f; // Unit: Miles

// Miles -> Kilometers
Distance = FUnitConversion::Convert(Distance, EUnit::Miles, EUnit::Kilometers);

// Distance: 25 [km]
```

您也可以获取指定的单位类别：

```cpp
EUnitType UnitType = FUnitConversion::GetUnitType(EUnit::Lumens);
// UnitType: LuminousFlux
```

您也可以自动将单位更改为最合适的：

```cpp
float Distance = 300000.0f; // Units: Centimeters
FNumericUnit<float> DistanceUnit = FUnitConversion::QuantizeUnitsToBestFit(Distance, EUnit::Centimeters); // Will auto select a better unit

EUnit NewUnit = DistanceUnit.Units;
float NewDistance = DistanceUnit.Value;

// NewDistance: 3.0 [km]
```

## 🎨 绘制调试形状

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

包含头文件：

```cpp
#include "DrawDebugHelpers.h"
```

### 绘制一个点

```cpp
bool bPersistentLines = true;

FVector Location = FVector(0, 0, 600);
float Size = 200.0f;
FColor Color = FColor(52, 220, 239);

DrawDebugPoint(GetWorld(), Location, Size, Color, bPersistentLines);
```

![Draw Debug Point](/static-img/debugging/draw_point.png)

结果

### 绘制一个球体

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 2.0f;

FVector Center = FVector(0, -600, 600);
float Radius = 200.0f;
int32 Segments = 26;
FColor Color = FColor(255, 0, 0);

DrawDebugSphere(GetWorld(), Center, Radius, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Sphere](/static-img/debugging/draw_sphere.png)

结果

### 画一个圆

```cpp
float Radius = 200.0f;
int32 Segments = 50;
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 10.0f;

// Draw a circle via matrix
FMatrix TransformMatrix = FMatrix();
DrawDebugCircle(GetWorld(), TransformMatrix, Radius, Segments, FColor(0, 104, 167), bPersistentLines, LifeTime, DepthPriority, Thickness);

// Draw a circle via location
FVector Center = FVector(-300, 0, 600);
DrawDebugCircle(GetWorld(), Center, Radius, Segments, FColor(0, 0, 0), bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Circle](/static-img/debugging/draw_circle.png)

结果

### 画一个圆弧

```cpp

bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 10.0f;

FVector Center = FVector(-400, -600, 600);
float Radius = 200.0f;
FVector Direction = FVector::ForwardVector;
float AngleWidth = 500.0;
int32 Segments = 50;
FColor Color = FColor::Yellow;

DrawDebugCircleArc(GetWorld(), Center, Radius, Direction, AngleWidth, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Cricle Arc](/static-img/debugging/draw_circle_arc.png)

结果

### 绘制一个 2D 甜甜圈

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 10.0f;

const FVector Location = FVector(-400, -600, 600);
const FTransform Transform = FTransform(FQuat::Identity, Location);
FMatrix TransformMatrix = Transform.ToMatrixNoScale();

float InnerRadius = 100.0f;
float OuterRadius = 300.0f;
int32 Segments = 26;
FColor Color = FColor::Cyan;

DrawDebug2DDonut(GetWorld(), TransformMatrix, InnerRadius, OuterRadius, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug 2D Donut](/static-img/debugging/draw_2d_donut.png)

结果

### 绘制一个实心盒子

```cpp
bool bPersistentLines = true;

// Draw a solid box
FVector MinPoint = FVector(0, 0, 0);
FVector MaxPoint = FVector(200, 200, 200);
FBox MyBox = FBox(MinPoint, MaxPoint);
FTransform MyTransform = FTransform(FQuat::Identity, FVector(-400, -600, 600));

DrawDebugSolidBox(GetWorld(), MyBox, FColor(200, 100, 50), MyTransform, bPersistentLines);
```

![Draw Debug Soild Box](/static-img/debugging/draw_solid_box.png)

结果

### 画一个带线的框

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 10.0f;

// Draw a wired box
FVector Center = FVector(-400, -600, 600);
FVector Extent = FVector(100, 100, 100);
FColor Color = FColor::Red;

DrawDebugBox(GetWorld(), Center, Extent, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Wired Box](/static-img/debugging/draw_wired_box.png)

结果

### 画一个圆柱体

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 2.0f;

FVector Start = FVector(0, -600, 600);
FVector End = FVector(0, -1800, 600);
float Radius = 200.0f;
int32 Segments = 26;
FColor Color = FColor(255, 0, 0);

DrawDebugCylinder(GetWorld(), Start, End, Radius, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Cylinder](/static-img/debugging/draw_cylinder.png)

结果

### 画一个胶囊

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 2.0f;

FVector Center = FVector(0, -600, 600);
float HalfHeight = 400.0f;
float Radius = 200.0f;
FQuat Rotation = FQuat::Identity;
FColor Color = FColor(255, 0, 0);

DrawDebugCapsule(GetWorld(), Center, HalfHeight, Radius, Rotation, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Capsule](/static-img/debugging/draw_capsule.png)

结果

### 画一个圆锥

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 0.0f;

FVector Origin = FVector(0, -600, 0);
FVector Direction = FVector(0, 0, -600);
float Length = 100.0f;
float AngleWidth = 45.0f;
float AngleHeight = 45.0f;
int32 NumSides = 12;
FColor Color = FColor::Yellow;

DrawDebugCone(
    GetWorld(),
    Origin,
    Direction,
    Length,
    FMath::DegreesToRadians(AngleWidth),
    FMath::DegreesToRadians(AngleHeight),
    NumSides,
    Color,
    bPersistentLines,
    LifeTime,
    DepthPriority,
    Thickness
);
```

![Draw Debug Cone](/static-img/debugging/draw_cone.png)

结果

### 画一个平面

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 2.0f;

FVector NormalVector = FVector::UpVector;
FPlane Plane = FPlane(NormalVector);
FVector Location = FVector(0, -600, 600);
FColor Color = FColor(255, 0, 0);

float Size = 100.0f;
DrawDebugSolidPlane(GetWorld(), Plane, Location, Size, Color, bPersistentLines, LifeTime, DepthPriority);

FVector2D Extents = FVector2D::One();
DrawDebugSolidPlane(GetWorld(), Plane, Location, Extents, Color, bPersistentLines, LifeTime, DepthPriority);
```

![Draw Debug Plane](/static-img/debugging/draw_plane.png)

结果

### 画一条线

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 10.0f;

FVector LocationFrom = FVector(0, -600, 600);
FVector LocationTo = FVector(0, 600, 600);
FColor Color = FColor::Emerald;

DrawDebugLine(GetWorld(), LocationFrom, LocationTo, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Line](/static-img/debugging/draw_line.png)

结果

### 画一个箭头

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 5.0f;

FVector LocationFrom =  FVector(-300, 600, 600);
FVector LocationTo = FVector(-300, -600, 600);
float ArrowSize = 120.0f;
FColor Color = FColor::Magenta;

DrawDebugDirectionalArrow(GetWorld(), LocationFrom, LocationTo, ArrowSize, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Arrow](/static-img/debugging/draw_arrow.png)

结果

### 画一个十字线

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;

FVector AxisLocation = FVector(0, 0, 1000);
FRotator AxisRotation = FRotator::ZeroRotator;
float Scale = 500.0f;
FColor Color = FColor::White;

DrawDebugCrosshairs(GetWorld(), AxisLocation, AxisRotation, Scale, Color, bPersistentLines, LifeTime, DepthPriority);
```

![Draw Debug Crosshair](/static-img/debugging/draw_crosshair.png)

结果

### 画一个相机

```cpp
bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;

FVector Location = FVector(0, -600, 600);
FRotator Rotation = FRotator::ZeroRotator;
float FOVDeg = 45.0f;
float Scale = 1.0f;
FColor Color = FColor::White;

DrawDebugCamera(GetWorld(), Location, Rotation, FOVDeg, Scale, Color, bPersistentLines, LifeTime, DepthPriority);
```

![Draw Debug Camera](/static-img/debugging/draw_camera.png)

结果

### 画一个网格

```cpp
FVector Offset = FVector(-300, 600, 600); // Example offset values

// Vertices for a cube with offset
const TArray<FVector> Verts = {
    FVector(-50, 50, 50) + Offset,  // 0
    FVector(50, 50, 50) + Offset,   // 1
    FVector(50, -50, 50) + Offset,  // 2
    FVector(-50, -50, 50) + Offset, // 3
    FVector(-50, 50, -50) + Offset, // 4
    FVector(50, 50, -50) + Offset,  // 5
    FVector(50, -50, -50) + Offset, // 6
    FVector(-50, -50, -50) + Offset // 7
};

// Indices for a cube
const TArray<int32> Indices = {
    0, 1, 2, 2, 3, 0, // Front face
    1, 5, 6, 6, 2, 1, // Right face
    5, 4, 7, 7, 6, 5, // Back face
    4, 0, 3, 3, 7, 4, // Left face
    4, 5, 1, 1, 0, 4, // Top face
    3, 2, 6, 6, 7, 3  // Bottom face
};

bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
FColor Color = FColor(255, 0, 0);

DrawDebugMesh(GetWorld(), Verts, Indices, Color, bPersistentLines, LifeTime, DepthPriority);
```

![Draw Debug Mesh](/static-img/debugging/draw_mesh.png)

结果

### 绘制字符串：

```cpp
FVector TextLocation = FVector(0, -600, 600);
FString Str = TEXT("Hello, World!");
AActor* TestBaseActor = NULL;
FColor TextColor = FColor::White;
float Duration = -1.0f;
bool bDrawShadow = false;
float FontScale = 5.0f;

DrawDebugString(GetWorld(), TextLocation, Str, TestBaseActor, TextColor, Duration, bDrawShadow, FontScale);
```

![Draw Debug String](/static-img/debugging/draw_string.png)

结果

### 绘制向心 Catmull-Rom 样条曲线

```cpp
FVector Offset = FVector(-300, 600, 600); // Example offset values

TArray<FVector> Points;
Points.Emplace(FVector(0, 0, 0) + Offset); // Add the starting point with offset
Points.Emplace(FVector(100, 50, 0) + Offset); // Add the first control point with offset
Points.Emplace(FVector(200, 100, 0) + Offset); // Add the second control point with offset
Points.Emplace(FVector(300, 0, 0) + Offset); // Add the ending point with offset

float Alpha = 0.5f;
int32 NumSamplesPerSegment = 8;

bool bPersistentLines = true;
float LifeTime = -1.0f;
uint8 DepthPriority = 0;
float Thickness = 2.0f;

FColor Color = FColor(255, 0, 0);
DrawCentripetalCatmullRomSpline(GetWorld(), Points, Color, Alpha, NumSamplesPerSegment, bPersistentLines, LifeTime, DepthPriority, Thickness);

TConstArrayView<FColor> Colors;
DrawCentripetalCatmullRomSpline(GetWorld(), Points, Colors, Alpha, NumSamplesPerSegment, bPersistentLines, LifeTime, DepthPriority, Thickness);
```

![Draw Debug Centripetal catmull-rom spline](/static-img/debugging/draw_centripetal_catmull_rom_spline.png)

结果

* * *

你可以阅读更多关于绘制形状的内容，作者是 Harrison McGuire。

你也可以观看 Ryan Sweeney 制作的关于这个主题的视频。

## ⚡ 编译插件

当你找到一个插件并尝试安装时，你可能会发现它不支持你当前的引擎版本。而且，如果没有关联版本，Unreal 的市场不会让你下载。

避免这个问题的技巧之一是手动构建插件并修复编译问题（缺少头文件或 API 变更）。通过安装具有源代码访问权限的插件。然后通过使用 UHT [3](#user-content-fn-2) （Unreal 构建工具）访问插件，你可以将插件重新构建到不同的引擎版本。

这是 `.bat` 文件（仅限 Windows）用于定位当前引擎目录，并将你自定义的插件编译到另一个引擎版本：

```
@echo off

:: Setting up config variables
set EngineVersion=<EngineVersion>
set PluginName=<PluginName>
set InputDirectory=<InputDirectory>
set OutputDirectory=<OutputDirectory>
set TargetPlatforms=Win64

set PluginPath="%cd%\%InputDirectory%\%PluginName%\%PluginName%.uplugin"
set OutputPath="%cd%\%OutputDirectory%\%EngineVersion%\%PluginName%"

:: Locating a registry key, in order to find Unreal Engine source location

for /f "skip=2 tokens=2*" %%a in ('reg query "HKEY_LOCAL_MACHINE\SOFTWARE\EpicGames\Unreal Engine\%EngineVersion%" /v "InstalledDirectory"') do set "EngineDirectory=%%b"

set AutomationToolPath="%EngineDirectory%\Engine\Build\BatchFiles\RunUAT.bat"

title Build Plugin
echo Automation Tool Path: "%AutomationToolPath%"
echo:

call %AutomationToolPath% BuildPlugin -Plugin=%PluginPath% -Package=%OutputPath% -Rocket -TargetPlatforms=%TargetPlatforms%
echo:
pause
exit 0
```

这是 bash 文件（仅限 Linux）版本：

```
#!/bin/bash

# Setting up config variables
EngineVersion="<EngineVersion>"
PluginName="<PluginName>"
InputDirectory="<InputDirectory>"
OutputDirectory="<OutputDirectory>"
TargetPlatforms="Win64"

PluginPath="$PWD/$InputDirectory/$PluginName/$PluginName.uplugin"
OutputPath="$PWD/$OutputDirectory/$EngineVersion/$PluginName"

# Locating a registry key, in order to find Unreal Engine source location
EngineDirectory=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\EpicGames\Unreal Engine\$EngineVersion" -v "InstalledDirectory" | awk 'NR==3{print $NF}')

AutomationToolPath="$EngineDirectory/Engine/Build/BatchFiles/RunUAT.bat"

echo "Automation Tool Path: \"$AutomationToolPath\""
echo

$AutomationToolPath BuildPlugin -Plugin="$PluginPath" -Package="$OutputPath" -Rocket -TargetPlatforms="$TargetPlatforms"

echo
read -p "Press Enter to continue..."
exit 0
```

## ⏳ 游戏计时器

用于执行延迟或重复操作的计时器结构。计时器在游戏场景中非常有用。

计时器安排在延迟后或一段时间内执行操作。例如，你可能希望在玩家获得能量提升物品后使其无敌，然后在 10 秒后恢复易受伤害状态。或者你可能希望在玩家穿过充满有毒气体的房间时每秒造成一次伤害。这些操作可以通过使用计时器来实现。

<Callout> 如果计时器将要被调用的对象（例如 Actor）在时间结束前被销毁，计时器将自动取消。在这种情况下，计时器句柄将变得无效，函数将不会被调用。</Callout>

```cpp
// .h

/* Handle to manage the timer */
FTimerHandle TimerHandle;

// Must mark a function with UFUNCTION, as UHT[^2] needs it, in order to find it.
UFUNCTION()
void OnExplode();
```

```cpp
// .cpp

/* Activate the bomb to explode after 1.5 seconds */
void ABombActor::OnUsed(APawn* InstigatorPawn)
{
    float Delay = 1.5f; // In seconds
    bool bLooping = false; // If we want to repeat this.

    GetWorld()->GetTimerManager().SetTimer(
        TimerHandle, // handle to cancel timer at a later time
        this, // the owning object
        &ABombActor::OnExplode, // function to call on elapsed
        Delay,
        bLooping
    );
}

void ABombActor::OnExplode()
{
    // ...
}
```

不调用 `SetTimer()` ，你可以创建一个带绑定函数的代理对象。

```cpp
FTimerHandle TimerHandle;
FTimerDelegate Delegate; // Delegate to bind function with parameters

Delegate.BindUFunction(this, &ABombActor::OnExplode);

float Delay = 1.5f;
bool bLooping = false;

GetWorld()->GetTimerManager().SetTimer(TimerHandle, Delegate, Delay, bLooping);
```

如果你希望将参数传递给绑定的函数，也可以指定参数：

```cpp
Delegate.BindUFunction(this, &APlayerCharacter::Heal, 150, true);

void Heal(int32 HealAmount, bool bReviveIfDead)
{
    // ...
}
```

如果我们想停止任何计时器，可以调用 `ClearTimer()` 或 `ClearAllTimersForObject()` ：

```cpp
// Clear the specified timer handle
GetWorld()->GetTimerManager().ClearTimer(TimerHandle);

// Alternatively you can clear ALL timers that belong to this (Actor) instance.
GetWorld()->GetTimerManager().ClearAllTimersForObject(this);
```

<Callout type="success"> 使用小于或等于零的速率调用 `SetTimer()` 与调用 `ClearTimer()` 相同。</Callout>

要暂停或恢复计时器，您可以调用 `PauseTimer()` 或 `UnPauseTimer()` 函数：

```cpp
// Pause the specified timer handle
GetWorld()->GetTimerManager().PauseTimer(TimerHandle);

// Unpause the specified timer handle
GetWorld()->GetTimerManager().UnPauseTimer(TimerHandle);
```

要检查计时器是否正在运行，您可以调用 `IsTimerActive()` 函数：

```cpp
// Is this weapon waiting to be able to fire again?
GetWorldTimerManager().IsTimerActive(this, &AUTWeapon::RefireCheckTimer);
```

您还可以通过计时器句柄获取计时器的当前速率（激活之间的时间间隔）：

```cpp
// This weapon's rate of fire changes as it warms up. Is it currently waiting to fire, and if so, how long is the current delay between shots?
GetWorldTimerManager().GetTimerRate(this, &AUTWeapon::RefireCheckTimer);
```

如果您想获取已用时间和剩余时间，可以通过 `GetTimerElapsed()` 函数访问：

```cpp
// How long will it be until this weapon is ready to fire again? If the answer comes back as -1, it is ready now.
GetWorldTimerManager().GetTimerElapsed(this, &AUTWeapon::RefireCheckTimer);
```

你可以在虚幻引擎的文档中了解更多关于游戏玩法计时器的信息。

## 🧵 游戏玩法标签

虚幻引擎有用于标记游戏中特定角色的标签系统。然而，传统的标签系统存在一些常见问题，如拼写错误、大小写敏感性和维护性差。为了解决这些问题，虚幻引擎引入了游戏玩法标签。

游戏玩法标签是虚幻引擎中一个强大的字符串标签系统，它可以帮助你以分层方式组织标签。它使用图形界面来创建和管理标签，这可以防止拼写错误。它还提高了代码的维护性。

使用 Gameplay 标签，您可以定义一个标签树结构，其中每个标签都可以有子标签。您还可以使用查询语法查询特定标签或子标签。

您可以在虚幻引擎的博客上了解更多关于 Gameplay 标签的信息。

<Callout type="warn">
  要在 C++中使用 Gameplay 标签，您必须在构建系统中包含该模块（ `GameplayTags` ）。
</Callout>

您还可以观看 LeafBranchGames 制作的视频，以了解有关 Gameplay 标签的所有信息。

## 使用

要管理您项目中现有的 Gameplay Tags，请在项目设置中打开 Gameplay Tags 选项卡。

例如，您可以创建如下的标签树：

*   `Weapon`
    *   `Gun`
        *   `Rifle`
            *   `AK47`
        *   `Pistol`
            *   `Glock-18`
        *   `Sniper`
            *   `AWP`
    *   `Melee`
        *   `Knife`

然后您可以使用查询语法来查找特定标签或子标签，如下所示：

*   `Weapon.Gun.Rifle` 将返回 `Weapon.Gun.Rifle` 的所有子标签
*   `Weapon.Gun.Pistol` 将返回 `Weapon.Gun.Pistol` 的所有子标签
*   `Weapon.Gun.Sniper` 将返回 `Weapon.Gun.Sniper` 的所有子标签
*   `Weapon.Gun` 将返回 `Weapon.Gun` 的所有子标签
*   `Weapon.Melee` 将返回 `Weapon.Melee` 的所有子标签
*   `Weapon` 将返回 `Weapon` 的所有子标签

## 数据类型

*   FGameplayTag, 是一个单一标签。它表示在 GameplayTagsManager 中注册的形如 `x.y` 的层级名称。

*   FGameplayTagContainer，用于存储一组标签。


## 代码

要在代码中使用 Gameplay 标签，可以这样做：

```cpp
// .h

#include "GameplayTagContainer.h"

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GameplayTags", meta = (Categories = "Weapon.Gun"))
FGameplayTag GunTag;
```

要在代码中定义 Gameplay 标签，可以这样做：

```cpp
// .h

#include "NativeGameplayTags.h"

/** Declares the "Weapon.Gun.Rifle.AK47" gameplay tag. */
UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_AK47)
```

```cpp
// .cpp

/** Define and expose the gameplay tag "Weapon.Gun.Rifle.AK47" to other modules and code. */
UE_DEFINE_GAMEPLAY_TAG(TAG_AK47, "Weapon.Gun.Rifle.AK47");
```

<Callout> 为了避免同时使用 `UE_DECLARE_GAMEPLAY_TAG_EXTERN()` 和 `UE_DEFINE_GAMEPLAY_TAG` ，你可以改用 `UE_DEFINE_GAMEPLAY_TAG_STATIC()` 。但是，这个宏应该只在使用声明的实现文件中使用。</Callout>

```cpp
// .cpp

/** Defines and locks the gameplay tag "Weapon.Melee.Knife" to this implementation file. */
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Weapon_Knife, "Weapon.Melee.Knife");
```

要在你的代码中使用这些标签，你可以这样做：

```cpp
FGameplayTag Tag;
bool bMatchesTag = Tag.MatchesTag(TEXT("MyTag"));

FGameplayTagContainer Tags;
FGameplayTagContainer IgnoreTags;
bool bHasTag = Tags.HasTag(TEXT("MyTag"));
bool bHasAnyTag = Tags.HasAny(IgnoreTags, TEXT("MyTag"));
```

## 🧠 多线程和异步任务

<table><tbody><tr><td>这一部分并非与 ChatGPT 一同编写。</td></tr></tbody></table>

游戏引擎运行游戏最常见的方式，仅仅是使用一个 while 循环。这种模式非常简单易懂，并且可以一致地执行。然而，这种模式并不能带来最佳的性能效益。为了提升性能，通常你需要将代码改写为多线程。

你可以从 Robert Nystrom 那里了解更多关于游戏循环的信息。

Ayliroé 撰写了一份关于 Unreal 的多线程和异步任务系统的精彩文档，你可以在 Google Docs 或论坛帖子中阅读。

默认情况下，Unreal 支持多线程，但只部分利用了它。虽然音频、渲染和统计有专门的线程，但大多数操作仍然在游戏线程中执行，包括 EventTicks 和 Blueprints。

这就是为什么在 Blueprint 中进行昂贵的计算会导致性能损失的原因。这就是多线程派上用场的地方！

### 多线程

多线程是指中央处理器（CPU）（或多核处理器中的单个核心）能够同时提供多个执行线程的能力，并由操作系统支持。在多线程应用程序中，线程共享单个或多个核心的资源，包括计算单元、CPU 缓存和转换后备缓冲器（TLB）。这使得计算速度更快。

为了让您的游戏准备好支持多线程，您也需要改变思维方式。当将代码拆分到多个线程时可能会产生竞态条件，即两个操作同时发生，并竞争哪个将首先执行。这可能导致不稳定并引发错误。

您可以从 Vulkan Guide 中了解更多关于多线程的信息。

您也可以观看 Chris Kanich 关于死锁的视频。

如果你想在蓝图内部创建多线程且只需最少的 C++代码，那么这里有一个来自 Ispheria 项目的视频。

### 可运行对象

`FRunnable` 是一个在专门新创建的线程上运行的类。你可以完全控制它。

一旦它们的工作完成，就会自动停止，通常适用于需要近乎持续运行线程的大计算任务。

这是一个示例：

```cpp
// .h
#pragma once

#include "CoreMinimal.h"
#include "HAL/Runnable.h"

class FMyThread : public FRunnable
{
public:
    FMyThread( /*Parameters*/ )
    {
        bIsRunning = true;
        Thread = FRunnableThread::Create(this, TEXT("MyThread"));
    };

    virtual ~FMyThread()
    {
    	if (Thread)
    	{
            bool bShouldWait = false; // Will forcefully terminate the thread.
    		Thread->Kill(bShouldWait);
    		delete Thread;
    	}
    }

public:
    bool Init() override;
    uint32 Run() override;
    void Exit() override;
    void Stop() override;

private:
    FRunnableThread* Thread;
    bool bIsRunning;
};
```

```cpp
// .cpp
#include "FMyThread.h"

bool FMyThread::Init()
{
    /* Should the thread start? */
    return true;
}

uint32 FMyThread::Run()
{
    while (bIsRunning)
    {
        /* Work on a dedicated thread */
    }

    return 0;
}

void FMyThread::Exit()
{
    /* Post-Run code, threaded */
}

void FMyThread::Stop()
{
    bIsRunning = true;
}
```

当你想要启动你的线程时，包含它的头部并调用它的构造函数（一定要保留指针！）：

```cpp
auto* Thread = new FMyThread( /*Parameters*/ );
```

### 任务

TaskGraph，是一个试图在多个现有线程之间平衡工作负载的工作管理器。这非常适合发送小操作包，因为它将线程管理的复杂性抽象化，还支持定义任务之间的依赖关系。

排队任务不会因线程已运行而引起性能问题，但系统可能会反应较慢，因为它需要在有限的池中寻找位置来安排工作，因此应避免发送长时间的任务以防止线程堵塞。有时，它也可能直接在游戏线程中运行任务，具体取决于配置。

#### 异步任务

如果你想在不需要创建专用类或启动新线程的情况下运行一个小的异步操作，并且不需要暂停或回调的控制逻辑，你可以将其放在运行在 TaskGraph 上的 `AsyncTask` 中：

```cpp
AsyncTask(ENamedThreads::AnyHiPriThreadNormalTask, [this] ()
{
    /* Work on the TaskGraph */
    Caller->FunctionToThread(); // Function call captured using [this]
});
```

如果你不了解 lambda，那么强烈建议你阅读这一部分的介绍。

#### ParallelFor

`AsyncTask` 的一个更高级版本，它将一个 for 循环拆分成多个在 TaskGraph 中运行的 Tasks。

```cpp
ParallelFor(Array.Num(), [&](int32 i)
{
    // Run Array.Num() operations, with current index i
    /* Work on the TaskGraph (order of execution is variable!) */
    ++Array[i];
});
```

操作内部的顺序或线程安全性没有保证，因此你可能需要使用互斥锁或原子操作与它一起使用。MSVC 有一个类似的#pragma loop(hint\_parallel(n))。实际上，你的循环内容必须足够重要才能真正从这种方法中受益。

#### FNonAbandonableTask

一种声明自定义 AsyncTasks 的方式，其格式介于 FRunnable 和 lambda-like AsyncTasks 之间。你可以在独立的类中实现自己的代码以增强可重用性，它将在 TaskGraph 上运行而不是在专用的线程中，但缺少部分 FRunnable 的初始化和停止逻辑。

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Async/AsyncWork.h"

class FMyTask : public FNonAbandonableTask
{
    friend class FAutoDeleteAsyncTask<FMyTask>;

    FMyTask( /*Parameters*/ )
    {
        /* Constructor */
    }

    void DoWork()
    {
        /* Work on the TaskGraph */
    }

    FORCEINLINE TStatId GetStatId() const
    {
        // Probably declares the Task to the TaskGraph
        RETURN_QUICK_DECLARE_CYCLE_STAT(FMyTask, STATGROUP_ThreadPoolAsyncTasks);
    }
};
```

像这样启动你的自定义任务：

```cpp
auto* MyTask = new FAsyncTask<FMyTask>( /*Parameters*/ );
MyTask->StartBackgroundTask();
```

* * *

如前所述，Ayliroé撰写了关于 Unreal 多线程和异步任务系统的精彩文档，你可以从 Google Docs 或论坛帖子中阅读。

## 🎯 扩展 Unreal Editor

<table><tbody><tr><td>这一部分并非与 ChatGPT 一同编写。</td></tr></tbody></table>

您可以通过这个 github 仓库找到编辑图标，由 EpicKiwi 制作。

### Slate

Lorem Ipsum

### 创建自定义资产类型

Lorem Ipsum

## ⚠️ 常见问题

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

![Common Errors](/static-img/Cpp_Errors.png)

在熟悉编程的过程中，你会遇到不同类型的错误和问题。定义错误/问题的类别有四种。

*   语法错误 - 违反编程语言的语法和结构规则。每种语言都有其自身的规则和指南需要遵循。例如，Python 语言不使用分号或花括号来定义代码块。

*   链接器错误 - 在链接阶段出现的问题，例如未解决的引用或模块或库之间的冲突。链接器问题也可能非常复杂且难以解决，因为它不会为开发者提供很多信息。

*   运行时错误 - 在程序执行过程中发生的错误，导致程序崩溃或行为异常。如果你能够访问崩溃报告器，运行时错误可以相当快速地解决，崩溃报告器通常包含调用栈（可以精确指出导致崩溃的函数或代码）。

*   语义错误 - 当代码在语法上正确但行为不符合预期或预期时发生的逻辑错误。语义错误可能是最难解决的一种错误，因为你需要从逻辑而非语法上理解代码。


编译器只会对语法和链接器问题报错。编译错误是指编译器无法编译的状态。这可能是由于代码中的错误，或者更不寻常的是，由于编译器本身的错误。

运行时错误可以通过崩溃报告器解决。而语义错误可以通过理解代码的逻辑推理来解决。

<Callout type="success">
  如果你感到卡壳或思维混乱，不妨花几分钟甚至几小时做点别的事情。比如出去走走、玩电子游戏、听音乐或看电影或视频。这可以帮助你大脑重新思考并更快地解决问题。
</Callout>

你可以在微软网站上找到所有的编译器错误。

### ⛔ 编译器错误

这里是你将会遇到的常见编译错误：

#### 编译器错误 C2007

**描述**

> `#define` 后面没有出现标识符。要解决此错误，请使用标识符。

以下示例生成 C2007：

```cpp
// C2007.cpp

#define   // C2007
```

可能的解决方法：

```cpp
// C2007b.cpp

// compile with: /c
#define true 1
```

错误消息的链接。

#### 编译器错误 C2065

**描述**

> 编译器无法识别标识符，因此认为其未声明。编译器需要在标识符被使用之前知道其存在。通过声明标识符，你向编译器提供了关于其名称和类型的必要信息，使其能够正确分配内存或解析引用。

以下示例生成 C2065：

```cpp
// C2065.cpp
#include <iostream>

int main()
{
    std::cout << x; // C2065 error
    return 0;
}
```

可能的解决方法：

```cpp
// C2065.cpp
#include <iostream>

int main()
{
    int x = 5; // Declare and initialize the variable x
    std::cout << x;
    return 0;
}
```

错误消息链接。

#### 编译器错误 C2628

**描述**

> 可能缺少分号。

以下示例会生成 C2628：

```cpp
// C2628.cpp
class CMyClass {} // C2628 error

int main()
{

}
```

可能的解决方法：

```cpp
// C2628b.cpp
class CMyClass {};

int main()
{

}
```

错误消息的链接。

### 💣 运行时错误

运行时错误是在程序执行时发生的一种错误。它是一种在编译时未被检测到，但在运行时才被检测到的错误类型。这意味着正在执行的代码会导致一个在程序执行之前无法预知的错误。

这里有两个运行时错误发生的例子：

如果没有崩溃报告器，解决运行时错误可能会极其困难。因为运行时错误会导致程序崩溃并终止。

如果你无法访问崩溃报告器来调试这些错误，那么可以在 VS Code 或 Visual Studio 中使用 `Visual Debugger` 。这个工具用于缓存运行时错误，并帮助你调试代码。它还具备调用堆栈功能，对于这类问题非常有帮助。

如果你无法访问可视化调试器，那么最常见且痛苦的方法就是在代码周围添加打印消息。我不推荐这种方法，因为它需要更多时间来追踪函数或代码行，并添加大量打印语句。相反，我建议你使用崩溃报告器或可视化调试器。

<Callout type="success">
  你也可以使用断言来测试代码的失败情况。但也要在失败时添加消息，这将供崩溃报告器捕获。这将增加崩溃发生时的可理解性。你可以在本节中了解更多关于断言的信息。
</Callout>

例如，如果你尝试访问数组的一个超出范围的索引，它将导致运行时错误，因为程序将尝试访问一个无效的内存位置。

### 💀 语义错误

#### 💠 整数溢出

当你对一个整数执行算术运算，其结果超出了该整数能持有的最大值时，就会发生溢出。

例如：

```cpp
int32 MaxValueOfInt32 = 2147483647;

MaxValueOfInt32++; // Will cause an overflow.

// Since an int32 can only store, both negative and positive: 2,14,748,3647.
// If you only care about the positive numbers (ex: health values), then use unsigned numbers instead.
```

负数也是如此：

```cpp
int32 MinValueOfInt32 = -2147483647;

MinValueOfInt32--; // Will cause an overflow.
```

为解决此溢出问题，可以使用更大的数据类型（ `int64` ）或使用无符号数据类型，例如 `uint32` 或 `uint64` 。

#### 💠 数组溢出

当你尝试访问数组边界之外的元素时，结果将是一个溢出。

Unreal 使用 `TArray` 和 `TArrayView` 类型来表示数组，在通过 `[]` 方括号操作（通过索引获取元素）访问它们的元素时，了解它们的最大大小非常重要。

作为一个例子

```cpp
TArray<int32> ActiveYears = { 2020, 2021, 2022 };

int32 Year = ActiveYears[10]; // Will cause an overflow

// Since the index is out of bounds of array's memory block and therefore cannot be accessed.
```

#### 🔍 作用域问题


作用域指的是代码中变量可访问的区域。在 C++中，作用域由 \{ 和 \} （大括号）定义。


有三种类型的作用域。局部、类和全局。

* * *

**局部作用域**

如果变量在函数或类内部声明，则该变量处于局部作用域。该变量仅在该函数或类内部可访问，而在其外部不可访问。

例如：

```cpp
void KillPlayer(APlayerCharacter* Player)
{
    {
        bool bIsDead = Player->Kill();

        // Able to access it
        if (bIsDead)
        {
            PrintDeath(Player);
        }
    }

    // Compile error! Cannot be accessed outside its defining scope.
    if (bIsDead)
    {

    }
}

// Same goes for this function scope

void PrintDeath(APlayerCharacter* Player)
{
    // Able to access it.
    // Since, it was defined as an argument, when the function was called.
    if (!IsValid(Player))
        return;

    // Compile error! Cannot be accessed inside another function.
    if (bIsDead)
    {

    }
}
```

* * *

**类作用域**

一个变量如果在类内部声明，则处于类作用域中。该变量只能在该类内部访问，不能在其外部访问。

例如：

```cpp
UCLASS()
class APlayerCharacter : public ACharacter
{
private:
    int32 Health;

public:
    void Kill()
    {
        Health = 0;
    }
};

void KillPlayer()
{
    Health = 0; // Compile error! Cannot be accessed outside the class scope.
}
```

这是修正后的版本：

```cpp
void KillPlayer(APlayerCharacter* Player)
{
    // Able to access it.
    // Since, the function as defined and have correct access to the current context of scope.
    Player->Kill();

    Player->Health = 0; // Compile error! Cannot be accessed, since it requires a private scope.
    // Meaning, the variable can only be accessed inside class scope.
}
```

* * *

**全局作用域**

一个变量如果在任何函数或类的外部声明，则处于全局作用域。该变量可以在程序的任何地方访问。

例如：

```cpp
int32 GPlayerHealth = 100;

UCLASS()
class AMyActor : public AActor
{
public:
    void DamagePlayer(int32 DamageAmount)
    {
        // Able to access it.
        // Since, the variable is defined in the global scope.
        GPlayerHealth -= DamageAmount;

        if (GPlayerHealth <= 0)
            GPlayerHealth = 0;
    }
};

UCLASS()
class APlayerCharacter : public ACharacter
{
public:
    void Kill()
    {
        // Able to access it.
        // Since, the variable is defined in the global scope.
        GPlayerHealth = 0;
    }
};
```

## 🐣 提示和最佳实践

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

这里有一个视频，讲解了使用虚幻引擎和 C++的一些最佳实践。

有一个名为《最佳实践（2019-2021）》的视频，由 Stephen Maloney 制作，介绍了其中一些最佳实践。

视频中还有一个谷歌文档（如果视频内容不够），提供了更多关于他一些技巧和窍门的详细信息。

### 禁用 BlueprintPure

当创建一个 `UFUNCTION` 并将其标记为 `const` 时，Unreal 会将其解释为纯函数。纯函数每次调用时（在蓝图内部）都会进行计算，而与普通函数相比，Unreal 会缓存结果并稍后使用。

纯函数适用于执行小型或快速功能的场景。例如：获取器。

使用蓝图时，每次从结果中拖动一个引脚，函数都会被计算一次。并且结果可能在不同的执行时间有所不同。

这与普通函数不同。使用普通函数时，蓝图会缓存结果。当从函数结果中拖动多个引脚时，将使用相同的值。

如果你想在 `UFUNCTION` 中标记为 const 而不让 Unreal 将其转换为纯函数，你可以添加这个限定符：

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure = false)
void ComplexFunction() const
{
    // Expensive calculations
}
```

### Switch case fall-through

在使用 switch case 时，有一个好处是有 fall-through case。在这种情况下，一个 case 可以属于多个 case，并且具有相同的性能。

尽管，这种代码可能比使用 if 语句更难阅读和理解。

```cpp
double DistanceUnificationFactor(EUnit From)
{
    // Convert to meters
    double Factor = 1;

    switch (From)
    {
        case EUnit::Micrometers:		return 0.000001;
        case EUnit::Millimeters:		return 0.001;
        case EUnit::Centimeters:		return 0.01;
        case EUnit::Kilometers:			return 1000;

        case EUnit::Lightyears:			return 9.4605284e15;

        case EUnit::Miles:				Factor *= 1760;				// fallthrough
        case EUnit::Yards:				Factor *= 3;				// fallthrough
        case EUnit::Feet:				Factor *= 12;				// fallthrough
        case EUnit::Inches:				Factor /= 39.3700787;		// fallthrough
        default: 						return Factor;				// return
    }
}
```

### 📦 重构

重构是指在不改变其外部行为的情况下，对代码库进行修改以改进其结构、可读性和可维护性。

重构是软件开发中的一个重要实践，有助于保持代码库的清洁、可维护性和可扩展性。它涉及在不改变其外部行为的情况下对代码进行渐进式改进，这对于在整个软件开发生命周期中维护一个健康和可持续的代码库至关重要。

#### 重命名

重命名成员，如变量、函数或类，是一种常见的重构技术，用于给他们赋予更有意义和描述性的名称，使代码更易于理解和维护。

示例：

```cpp
// Before refactoring
UCLASS()
class MyActor : public AActor
{
private:
    int mag;
    float dmg = 10;

public:
    float F()
    {
        mag--;
        auto d = FMath::RandRange(0, dmg);
        auto a = mag > 0 ? d : 0;
        return a;
    }
};

// After refactoring
UCLASS()
class MyActor : public AActor
{
private:
    int CurrentMagazine;
    float MaxBulletDamage = 10;

public:
    float Fire()
    {
        CurrentMagazine--;
        float BulletDamage = FMath::RandRange(0, MaxBulletDamage);
        BulletDamage = CurrentMagazine > 0 ? BulletDamage : 0;
        return BulletDamage;
    }
};
```

#### 提取方法

提取方法是重构技术的一种，你将方法内的部分代码移动到单独的方法中。这有助于提高代码可读性，鼓励代码复用，并简化复杂方法。

示例：

```cpp
// Before refactoring
void TakeActorDamage(MyActor* actor, int damage = 100)
{
    // Apply damage to the actor
    actor->TakeDamage(damage);

    // Log damage taken
    UE_LOG(LogTemp, Warning, TEXT("%s took %d damage!"), *actor->GetName(), damage);

    // Check if actor is destroyed
    if (actor->IsDestroyed())
    {
        // Log actor destruction
        UE_LOG(LogTemp, Warning, TEXT("%s has been destroyed!"), *actor->GetName());

        // Spawn explosion effect
        UGameplayStatics::SpawnEmitterAtLocation(actor->GetWorld(), ExplosionEffect, actor->GetActorLocation());

        // Play destruction sound
        UGameplayStatics::PlaySoundAtLocation(actor->GetWorld(), DestructionSound, actor->GetActorLocation());

        // Detach actor from parent
        actor->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);

        // Destroy actor
        actor->Destroy();
    }
}

// After refactoring
void ApplyDamageToActor(MyActor* actor, int damage = 100)
{
    // Apply damage to the actor
    actor->TakeDamage(damage);

    // Log damage taken
    UE_LOG(LogTemp, Warning, TEXT("%s took %d damage!"), *actor->GetName(), damage);

    // Check if actor is destroyed
    if (!actor->IsDestroyed())
        return;

    HandleActorDestruction(actor);
}

void HandleActorDestruction(MyActor* actor)
{
    // Log actor destruction
    UE_LOG(LogTemp, Warning, TEXT("%s has been destroyed!"), *actor->GetName());

    // Spawn explosion effect
    UGameplayStatics::SpawnEmitterAtLocation(actor->GetWorld(), ExplosionEffect, actor->GetActorLocation());

    // Play destruction sound
    UGameplayStatics::PlaySoundAtLocation(actor->GetWorld(), DestructionSound, actor->GetActorLocation());

    // Detach actor from parent
    actor->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);

    // Destroy actor
    actor->Destroy();
}
```

#### 类型定义

引入类型定义可以使复杂类型名称更加简洁易懂。另一方面，内联类型定义有助于降低代码复杂性，并通过避免不必要的类型别名来提高代码可读性。

示例：

```cpp
// Note, this is regular raw C++ code.

// Before refactoring
typedef std::map<std::string, std::vector<int>> NameToNumbersMap;

NameToNumbersMap numbers;

// After refactoring (Introduce typedef)
using NumbersVector = std::vector<int>;
using NameToNumbersMap = std::map<std::string, NumbersVector>;

NameToNumbersMap numbers;

// After refactoring (Inline typedef)
std::map<std::string, std::vector<int>> numbers;
```

<Callout type="warn"> Typedefs 不适用于 UHT [8](#user-content-fn-1) 。这意味着你不能将其暴露给 Blueprint。</Callout>

#### 引入变量

引入变量可以通过为中间结果赋予有意义的名称来简化复杂表达式或提高代码可读性。

示例：

```cpp
// Note, this is regular raw C++ code.

// Before refactoring
float total = (price + tax) * quantity - discount + shippingCost;

// After refactoring
float netPrice = price + tax;
float totalPrice = netPrice * quantity - discount + shippingCost;
```

#### 反转'if'语句以减少嵌套

考虑以下代码片段：

```cpp
void MyCharacter::DoSomething()
{
    if (bIsReadyToMove)
    {
        if (!bIsMoving)
        {
            if (!bIsJumping)
                MoveCharacter();
            else
            {
                // Handle already jumping
            }
        }
        else
        {
            // Handle already moving
        }
    }
    else
    {
        // Handle not ready to move
    }
}
```

如您所见， `if` 块包含整个方法体。这提供了一个机会，通过移除嵌套作用域并添加 `return` 关键字 [8](#user-content-fn-1) ，使代码更易读：

```cpp
void MyCharacter::DoSomething()
{
    if (!bIsReadyToMove)
    {
        // Handle not ready to move
        return;
    }

    if (bIsMoving)
    {
        // Handle already moving
        return;
    }

    if (bIsJumping)
    {
        // Handle already jumping
        return;
    }

    MoveCharacter();
}
```

### ⏱️ Ticking

#### 对演员

```cpp
PrimaryActorTick.bCanEverTick = false;
PrimaryActorTick.bStartWithTickEnabled = false;
```

#### 对组件

```cpp
PrimaryComponentTick.bCanEverTick =  false;
PrimaryComponentTick.bStartWithTickEnabled = false;
```

#### 如果你必须使用 Tick

*   将 tick 间隔设置为你能接受的最高值。不幸的是，对于平滑移动的物体，这通常是每帧

```cpp
PrimaryActorTick.TickInterval = 0.2f;
PrimaryComponentTick.TickInterval = 0.2f;
```

*   启用/禁用 tick，仅在需要时才 tick。

```cpp
SetActorTickEnabled()
SetComponentTickEnabled()
```

#### `FTickFunction`

所有 tick 函数的抽象基类。

入门示例代码：

##### MyTickableThing.h

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Tickable.h"

class FMyTickableThing : public FTickableGameObject
{
public:
    // FTickableGameObject Begin
    void Tick( float DeltaTime ) override;

    ETickableTickType GetTickableTickType() const override
    {
        return ETickableTickType::Always;
    }

    TStatId GetStatId() const override
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT( FMyTickableThing, STATGROUP_Tickables );
    }

    bool IsTickableWhenPaused() const
    {
        return true;
    }

    bool IsTickableInEditor() const
    {
        return false;
    }
    // FTickableGameObject End

private:
	// The last frame number we were ticked.
	// We don't want to tick multiple times per frame
	uint32 LastFrameNumberWeTicked = INDEX_NONE;
};
```

##### MyTickableThing.cpp

```cpp
#include "MyTickableThing.h"

void FMyTickableThing::Tick( float DeltaTime )
{
	if ( LastFrameNumberWeTicked == GFrameCounter )
		return;

	// Do our tick
	// ...

	LastFrameNumberWeTicked = GFrameCounter;
}
```

<Callout> Tick 任何你想的对象， `UObject` 或不 Tick！</Callout>

<Callout type="warn"> UHT [3](#user-content-fn-2) 不支持在 `USTRUCT` 内部暴露函数。然而，你仍然可以在 `USTRUCT` 内部有函数，但不仅暴露给蓝图。</Callout>

### 🔌 直接引用

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

在 C++中，直接引用是指直接指向另一个变量内存地址的引用变量。当你使用直接引用时，你实际上是在为原始变量创建一个别名或一个替代名称。这意味着对引用的任何修改都会反映在原始变量上，反之亦然。

在某些情况下，使用直接引用可以带来性能上的好处，因为它避免了创建不必要的数据副本。当你将大型对象或结构作为函数参数传递时，使用直接引用而不是按值传递（复制）可以节省内存和处理时间，特别是对于复杂的对象。

在直接引用中使用 `const` 限定符是一种安全机制，用于防止对引用的变量进行意外修改。当你将变量声明为 const 时，意味着其值在初始化后不能被改变。

在某些情况下，在直接引用中使用 `const` 还可以启用某些编译器优化，因为它向编译器提供了关于引用值不可变性的额外信息。

```cpp
// Note, this is regular raw C++ code.

int a = 5;
int b = a; // Gets a copy

b = b * 2; // B = 10 and A = 5

int& c = 10;
int& d = c;

d = 20; // C = 20 and D = C, which is 20

const int& e = 10; // Direct reference (use const for stopping ability to modify the variable)
const int& f = e;

f = 11; // COMPILER ERROR!!! Cannot modify const variable!!
```

## 🗝️ 深入探讨

<table><tbody><tr><td>本节内容由 ChatGPT 共同编写。</td></tr></tbody></table>

### K2Node

您可以通过奥斯卡·奥尔森了解更多关于 K2Node 的信息。

### ➗ 数学表达式节点

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

数学表达式节点类似于一个折叠的图。它是一个单一节点，你可以双击来打开构成其功能的子图。最初，名称/表达式是空的。每当你重命名节点时，新的表达式会被解析并生成一个新的子图。

![Math Node Example](/static-img/math_node_example.png)

你可以在 Unreal 的文档中了解更多关于数学表达式节点的信息。

### 在编辑器中调用函数

在蓝图编辑器中暴露一个可调用的函数。使用 C++时，你可以标记 `UFUNCTION` 指定符 `CallInEditor` 。

这是一个示例：

```cpp
UFUNCTION(CallInEditor, BlueprintCallable)
void DebugMessage();
```

### 通过控制台命令调用函数

要在控制台命令中调用一个 `UFUNCTION` ，您可以使用 `Exec` 指定符。这会告诉虚幻引擎将函数添加到控制台命令列表中。

这里有一个示例：

```cpp
UFUNCTION(Exec)
void KillCharacter();
```

然而，使用这种方法有一个缺点。因为虚幻引擎会根据函数和映射找到相应的名称，虚幻引擎无法调用同一函数的多个实例。它只优先考虑当前由玩家持有的 Pawn。

要调用具有多个实例的函数，可以输入 `ke * FunctionName` 。

这里有一个例子：

```console
$ ke * KillCharacter
```

<Callout> 在命令行界面（CLI）的上下文中，美元符号（ `$` ）通常被称为“提示符号”或简单地称为“提示”。它表示 CLI 已准备好接收用户的输入。提示的具体外观和行为可能会根据所使用的操作系统和外壳而有所不同。</Callout>

### 重命名变量而不破坏引用

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

在开发过程中，有时需要重命名属性、函数或类。如果在更改代码其他位置名称之前编译，可能会导致 Unreal 不再识别现有资源，并因此替换为其默认初始化值。

为解决此问题，虚幻引擎使用核心重定向功能。核心重定向功能应在您的项目的 `DefaultEngine.ini` 文件中配置，或者对于插件，应在该插件的带前缀的自命名的.ini 文件中配置（例如，引擎的 Paper2D 插件的 `BasePaper2D.ini` 文件，或游戏插件的 `Default<GamePluginName>.ini` 文件）。

无论哪种情况，核心重定向功能都将被放置在"\[CoreRedirects\]"部分中。这些核心重定向功能在加载资源时会自动重新映射过时数据，从而防止因重命名过程导致的数据丢失。

以下是属性值重定向的结构：

```ini
+PropertyRedirect=(OldName="CurrentClass.OldVariableName", NewName="NewOldVariableName")
```

Here's a full example of different use cases with redirects:

```ini
[CoreRedirects]
+PropertyRedirect=(OldName="PlayerCharacter.StartHealth", NewName="InitialHealth")

+ClassRedirects=(OldName="Pawn",NewName="MyPawn",InstanceOnly=true)

+ClassRedirects=(OldName="/Script/MyModule.MyOldClass",NewName="/Script/MyModule.MyNewClass")

+ClassRedirects=(OldName="PointLightComponent",NewName="PointLightComponent",ValueChanges=(("PointLightComponent0","LightComponent0")))

+ClassRedirects=(OldName="AnimNotify_PlayParticleEffect_C",NewName="/Script/Engine.AnimNotify_PlayParticleEffect",OverrideClassName="/Script/CoreUObject.Class")

+EnumRedirects=(OldName="ENumbers",NewName="ELetters",ValueChanges=(("NumberTwo","LetterB"),("NumberThree","LetterC")))

+FunctionRedirects=(OldName="MyOldActor.OldFunction",NewName="MyNewActor.NewFunction")
+FunctionRedirects=(OldName="MyActor.OldFunction",NewName="NewFunction")

+PackageRedirects=(OldName="OldPlugin",NewName="/NewPlugin/",MatchSubstring=true)
+PackageRedirects=(OldName="/Game/DeletedContentPackage",Removed=true)

+StructRedirects=(OldName="MyStruct",NewName="MyNewStruct")
```

你可以在虚幻引擎的文档中了解更多信息。

* * *

The `MatchSubstring` argument can be used in any Core Redirect type. If present and set to `true`, the `OldName` and `NewName` fields will be treated as substrings rather than requiring exact matches. This enables multiple matches with a single Core Redirect. In the following example, we will start with a struct and a class.

原始代码和值：

```cpp
USTRUCT()
struct FMyStruct
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestInt;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestIntFromStruct;
};

UCLASS()
class REDIRECTORSTEST_API AMyActor : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestInt;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 MainClassTestInt;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    FMyStruct TestStruct;
};
```

![Original Values](/static-img/OriginalValues.jpg)

这是我们保存到 \`AMyActor\` 资产中的原始代码和原始值集。

在创建并保存一个带有上述值的 `AMyActor` 资源后，我们可以关闭编辑器并修改 `.h` 文件中的代码以及游戏 `.ini` 文件中的核心重定向。我们将代码修改为如下所示，更改我们的 `int32` 属性的名称：

```cpp
USTRUCT()
struct FMyStruct
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestInteger;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestIntegerFromStruct;
};

UCLASS()
class REDIRECTORSTEST_API AMyActor : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 TestInteger;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    int32 MainClassTestInteger;

    UPROPERTY(EditAnywhere, Category = "Documentation")
    FMyStruct TestStruct;
};
```

通过这个修改，我们可以检查核心重定向的效果，特别是 `MatchSubstring` 的影响。

结果如下：

![NoCoreRedirect](/static-img/NoCoreRedirect.jpg)

代码中属性名称已更改，但未创建核心重定向。因此，没有数据值迁移到新属性。

![CoreRedirectWithoutMatchSubstring](/static-img/CoreRedirectWithoutMatchSubstring.jpg)

\`PropertyRedirects=(OldName="TestInt",NewName="TestInteger")\` 导致只有两个名称完全匹配的属性迁移其数据。

![CoreRedirectWithMatchSubstring](/static-img/CoreRedirectWithMatchSubstring.jpg)

\`PropertyRedirects=(OldName="TestInt",NewName="TestInteger",MatchSubstring=true)\` 由于子字符串匹配，导致我们所有的四个属性迁移。

<Callout> 由于 `MatchSubtring` 需要更彻底地检查传入的资产，因此可能会影响启动时间。 `MatchSubstring` 旨在作为进行大规模更改时的临时修复。建议立即重新保存涉及这些更改的资产，并将任何相关的代码更改与项目源代码数据库一起检查入，并删除核心重定向而不将其提交到源代码控制。</Callout>

### 曲线采样

有时，你可能想处理一条曲线。在 C++中访问曲线时，可以使用 `UCurveFloat` 类。这个类让你能够访问插值点，并在给定范围内进行评估。

你可以通过内容浏览器在杂项 → 曲线中创建它们。

<table><tbody><tr><td>模块： Engine 头文件： #include "Curves/CurveFloat.h"</td></tr></tbody></table>

```cpp
// .h

UPROPERTY(EditAnywhere)
UCurveFloat TimeCycle;

UPROPERTY(EditAnywhere, meta = (ClampMin = 0.0, ClampMax = 1.0))
float TimeOfDay = 0.5f; // Range between 0 -> 1
```

```cpp
// .cpp

// This will be our output value from the curve
float SunIntensity = 0.0f;

// Check if the curve is valid before accessing it.
// Otherwise, if curve is a nullptr, a crash will happen.
if (IsValid(TimeCycle))
{
    // We read the curve at the current level, and assign the value to MaxHP
    SunIntensity = TimeCycle->GetFloatValue(TimeOfDay);
}
```

你可以在 Unreal 的文档中了解更多关于曲线的信息。

### HTTP 请求

<table><tbody><tr><td>模块： HTTP 头文件： #include "HttpModule.h" #include "Interfaces/IHttpResponse.h" #include "PlatformHttp.h" #include "JsonObjectConverter.h" // Include this, if you want to send some JSON data into the request</td></tr></tbody></table>

```cpp
// .h

UENUM(BlueprintType)
enum class EHTTPRequestType : uint8
{
    GET,
    POST,
    PUT,
    DELETE
};

// Delegate for the callback
DECLARE_DYNAMIC_DELEGATE_ThreeParams(FHTTPRequest, const FString&, Result, int32 ResponseCode, bool, bWasSuccessful);

UFUNCTION(BlueprintCallable, Category = "MyPawn")
/**
* Send a request via HTTP protocol system.
*
* @param BaseURL - Base URL on which to process the request on.
* @param EndpointURL - Endpoint URL. Combined with base URL to get fully qualified URL for the request.
* @param RequestType - What type of request (GET, POST, PUT, DELETE)
* @param Callback - Callback of the request
* @return A boolean, if the request was successfully sent out.
*/
bool SendRequest(
    const FString BaseURL,
    const FString EndpointURL,
    const EHTTPRequestType RequestType,
    FString Payload,
    FHTTPRequest Callback
);
```

```cpp
// .cpp

bool YourClass::SendRequest(
	const FString BaseURL,
	const FString EndpointURL,
	const EHTTPRequestType RequestType,
	FString Payload,
	FHTTPRequest Callback)
{
    // Get a reference to the HTTP singleton and create a request object
    const FHttpRequestRef Request = FHttpModule::Get().CreateRequest();

    // Creates a lambda function and stores to a variable.
    auto LambdaFunc = [this, Callback](FHttpRequestPtr Req, FHttpResponsePtr Res, bool bWasSuccessful)
    {
        FString Result;

        // Check the status code
        const int32 ResCode = Res->GetResponseCode();

        if (!bWasSuccessful || ResCode < 100 || ResCode > 300)
        {
            // Only accepting 200 -> 299 response code
            Callback.ExecuteIfBound(Result, ResCode, false);
            return;
        }

        Result = Res->GetContentAsString();

        Callback.ExecuteIfBound(Result, ResCode, true);
    };

    // Bind the lambda as the callback
    Request->OnProcessRequestComplete().BindLambda(LambdaFunc);

    Request->SetURL(BaseURL + EndpointURL);
    Request->SetVerb(UEnum::GetDisplayValueAsText(RequestType).ToString());

    switch (RequestType)
    {
        case EHTTPRequestType::POST:
        case EHTTPRequestType::PUT:
        case EHTTPRequestType::DELETE:
        {
            // To send data into the request, you must include this header
            // Which tells the request to expect a JSON data type
            Request->SetHeader("Content-Type", "application/json");

            // Payload is in JSON format. Use JsonObjectConverter to convert Unreal's data type into JSON format.
            Request->SetContentAsString(Payload);
        }
        break;
    }

    // Returns true if the HTTP request has started. Does NOT return the result of the callback lambda.
    return Request->ProcessRequest();
}
```

然后你可以调用 `SendRequest()` 函数：

```cpp
void YourClass::SendTestRequest()
{
    // Final URL: BASE_URL + ENDPOINT_URL = "https://swapi.dev/api/planets/3/"
    // Helpful to split the endpoint, as you can switch to another endpoint.
    const FString BASE_URL = "https://swapi.dev/api/";
    const FString ENDPOINT_URL = "planets/3/"; // "starships/9/", "people/1/"

    FString JSON;
    FHTTPRequest Delegate;
    Delegate.BindDynamic(this, &YourClass::OnRequestCompleted);

    // Send the request with delegate passed into the parameters
    SendRequest(BASE_URL, ENDPOINT_URL, EHTTPRequestType::GET, "", Delegate);
}

void YourClass::OnRequestCompleted(const FString& Result, bool bWasSuccessful)
{
    if (!bWasSuccessful)
    {
        UE_LOGFMT(LogTemp, Log, "The Request was not successful!");
        return;
    }

    UE_LOGFMT(LogTemp, Log, "Request Output: {0}", Result);
}
```

<Callout type="success">
  你可以通过 Postman 使用 Star Wars API 示例来测试 HTTP 请求。
</Callout>

你可以在 Unreal 的文档中了解更多关于 HTTP 模块的信息。

### 加密和解密

在进行加密和解密工作时。

```cpp
// .h

// Encrypts Int32 using a 10 digit Alpha-Numeric Key into an FString
UFUNCTION(BlueprintCallable, Category = "Encryption")
static FString EncryptInt32(int32 InInt, FString EncryptionKey);

// Decrypts an encrypted FString back to Int32 using a 10 digit Alpha-Numeric Key
UFUNCTION(BlueprintCallable, Category = "Encryption")
static int32 DecryptToInt32(FString EncryptedValue, FString EncryptionKey);
```

```cpp
// .cpp

#include "Kismet/KismetStringLibrary.h"

FString YourClass::EncryptString(FString Data, FString EncryptionKey)
{
    FString EncryptedValue;

    TArray<TCHAR> ValueChars = Data.GetCharArray();
    TArray<TCHAR> KeyChars = EncryptionKey.GetCharArray();

    for (int32 i = 0; i < ValueChars.Num() -1; i++)
    {
        FString TempString;
        TempString.AppendChar(ValueChars[i]);
        EncryptedValue.AppendChar(KeyChars[UKismetStringLibrary::Conv_StringToInt(TempString)]);
    }

    return EncryptedValue;
}

FString YourClass::DecryptToString(FString EncryptedValue, FString EncryptionKey)
{
    TArray<TCHAR> ValueChars = EncryptedValue.GetCharArray();
    TArray<TCHAR> KeyChars = EncryptionKey.GetCharArray();

    FString OutString;

    for (int32 i = 0; i < ValueChars.Num() -1; i++)
    {
        OutString = (OutInt * 10) + KeyChars.Find(ValueChars[i]);
    }

    return OutString;
}
```

## 🔗 有用链接

<table><tbody><tr><td>本节并非与 ChatGPT 一同编写。</td></tr></tbody></table>

### YouTube 视频

| 作者 | 标题 | 长度 | 链接 |
| --- | --- | --- | --- |
| Mosh Hamedani | C++ 初学者教程 - 1 小时内学会 C++ | 01:22:55 | [YouTube](https://www.youtube.com/watch?v=ZzaPdXTrSb8) |
| Alex Forsythe | 蓝图与 C++：它们如何协同工作以及为何你应该同时使用两者 | 47:13 | [YouTube](https://www.youtube.com/watch?v=VMZftEVDuCE) |
| Alex Forsythe | 虚幻引擎游戏框架：从 int main()到 BeginPlay | 27:22 | [YouTube](https://www.youtube.com/watch?v=IaU2Hue-ApI) |
| Alex Forsythe | 虚幻引擎中的多人游戏：如何理解网络复制 | 22:07 | [YouTube](https://www.youtube.com/watch?v=JOJP0CvpB8w) |
| 亚历克斯·福赛斯 | 当虚幻编辑器崩溃时你该怎么办？ | 13:04 | [YouTube](https://www.youtube.com/watch?v=TXZGIvpEhW8) |
| 虚幻引擎 | UE5 中的遮罩和资产制作 | 34:07 | [YouTube](https://www.youtube.com/watch?v=R5TsbnW4fk8) |
| 虚幻引擎 | 在虚幻引擎 5 中构建开放世界 | 49:41 | [YouTube](https://www.youtube.com/watch?v=EEf07ggFWRw) |
| 虚幻引擎 | 35 个你可能不知道的 UE5 功能 | 49:55 | [YouTube](https://www.youtube.com/watch?v=k2IP5DYQ0-0) |
| 阿米尔·安萨里 | 虚幻引擎过载 - 软硬引用 | 01:13:35 | [YouTube](https://www.youtube.com/watch?v=giDf4G6Ndk8) |
| UNF 游戏 | 虚幻引擎 5 入门建模教程 - 学习在虚幻引擎中建模！ | 02:12:34 | [YouTube](https://www.youtube.com/watch?v=9InU0xbX7l0) |

### 文章

| 作者 | 标题 | 链接 |
| --- | --- | --- |
| Ben | benui | benui.ca |
| Unreal Engine | 开发者社区 | dev.epicgames.com |
| 社区驱动 | 虚幻引擎社区维基 | unrealcommunity.wiki |
| Jonas Reich | OpenUnrealConventions | jonasreich.github.io |
| Oskar Świerad | UNREAL ART OPTIMIZATION | unrealartoptimization.github.io |

### 在线工具

| 作者 | 标题 | 描述 | 链接 |
| --- | --- | --- | --- |
| Naotsun | UnrealMacroGenerator |  | [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=Naotsun.Naotsun-UE-UMG) |
| Sébastien Rancoud | blueprintUE | 非官方工具，旨在帮助虚幻引擎开发者 | [blueprintUE](https://blueprintue.com/) |
| 马特·戈德博尔特 | 编译器探索器 | 从你的网络浏览器交互式运行编译器并与汇编交互 | [Compiler Explorer](https://godbolt.org/) |
|  | 虚幻引擎 4 控制台变量和命令 | 所有 UE 命令列表 | [UE Commands](https://digilander.libero.it/ZioYuri78/) |

### 杂项

| 作者 | 标题 | 描述 | 链接 |
| --- | --- | --- | --- |
| 托马斯·英格拉姆 | 开发者笔记 | 查看和发布开发者文档中的笔记。 | [Chrome Web Store](https://chrome.google.com/webstore/detail/developer-notes/fchdfdnnpkphopmdaochdfnmcahndmnb) |

## 🆘 支持

If you have any questions or issue, just write either to my [YouTube channel](https://www.youtube.com/@mrrobinofficial), [Email](mailto:mrrobin123mail@gmail.com) or [Twitter DM](https://twitter.com/MrRobinOfficial).


## 📍 脚注

## 脚注

1.  C 是一种过程式编程语言，以其效率和可移植性而闻名，常用于系统级编程和嵌入式系统开发。 ↩ ↩ 2

2.  JavaScript 是一种通用、动态的脚本语言，常用于网页开发，为网站添加交互性和功能。 ↩ ↩ 2

3.  虚幻引擎头文件工具（UHT）是一个强大的工具，用于管理虚幻引擎项目中 C++文件之间的依赖关系。头文件工具设计为与虚幻构建工具（UBT）协同工作，后者负责编译引擎及其所有模块。 ↩ ↩ 2 ↩ 3 ↩ 4 ↩ 5 ↩ 6 ↩ 7 ↩ 8 ↩ 9 ↩ 10 ↩ 11 ↩ 12

4.  Python 是一种用户友好型、高级语言，常用于脚本编写、数据分析、Web 开发和人工智能应用。 ↩ ↩ 2

5.  Java 是一种多用途、跨平台的语言，以其“一次编写，到处运行”的能力而闻名，常用于 Web 开发和企业应用。 ↩

6.  C#是由微软开发的一种高级、面向对象的编程语言，广泛用于使用.NET 框架构建 Windows 应用程序和游戏。 ↩ ↩ 2 ↩ 3 ↩ 4

7.  C++中的宏是预处理器指令，能够在编译前通过文本替换来定义可重用的代码片段。这里有一个关于它的视频。 ↩ ↩ 2 ↩ 3 ↩ 4 ↩ 5 ↩ 6 ↩ 7 ↩ 8

8.  关键字，也称为保留字。 ↩ ↩ 2 ↩ 3 ↩ 4 ↩ 5 ↩ 6

9.  GitHub 是一个基于网络的平台和版本控制仓库，它允许个人和团队通过提供代码存储、版本跟踪、问题跟踪以及拉取请求和代码审查等协作功能来共同开发软件项目。链接到其网站。 ↩
