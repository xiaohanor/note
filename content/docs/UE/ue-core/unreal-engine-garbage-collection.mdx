---
title: Unreal Engine 垃圾回收原理深度解析
---
## I. Unreal Engine 内存管理概览 \[#i-unreal-engine-内存管理概览]

### 游戏开发中的内存挑战 \[#游戏开发中的内存挑战]

在实时应用如游戏开发中，内存管理至关重要。游戏引擎需要持续创建、更新和销毁大量动态对象，例如角色、道具、粒子特效和用户界面元素。手动管理这些对象的生命周期极易引入各种问题，包括内存泄漏（即不再使用的内存未被释放）、悬空指针（即指向已释放内存的指针）以及由于频繁的内存分配和释放操作导致的性能卡顿。传统的 C++ 手动 `new`/`delete` 模式在复杂、多线程的游戏环境中尤其容易出错，且难以调试。因此，确保内存操作的可预测性和高效性，对于维持流畅的游戏体验至关重要的。

### Unreal Engine 为何选择垃圾回收机制管理 UObject \[#unreal-engine-为何选择垃圾回收机制管理-uobject]

Unreal Engine (UE) 针对其核心对象类型 `UObject` 及其派生类，采用了一种自动内存管理系统——垃圾回收（Garbage Collection, GC）。这一设计决策显著简化了开发流程，减轻了开发者手动跟踪和管理大量引擎对象的内存生命周期的负担。GC 的核心思想是，只要一个

`UObject` 实例处于“使用中”（即从特定根集合可达），它就不会被删除。这种机制有效地防止了许多常见的内存错误，如双重释放或使用已释放内存等，这些错误在大型代码库中往往难以发现和修复。通过自动化

`UObject` 的内存管理，UE 提高了开发效率和系统稳定性，使得开发者能够将更多精力集中在游戏逻辑的实现上，而非底层的内存细节。然而，这种自动化也依赖于强大的反射系统来支持 GC 的运作，并且可能在某些情况下引入性能峰值，需要通过增量式 GC 等技术进行优化。

### 报告范围与核心要点 \[#报告范围与核心要点]

本报告将深入探讨 Unreal Engine 垃圾回收系统的核心原理，包括其运作方式、反射系统在其中的关键作用、与其他内存管理机制（如智能指针和原生 C++ 内存管理）的交互，以及显式对象销毁的流程。此外，报告还将分析 UE GC 系统的演进及其现代改进，并提供优化性能的最佳实践。理解这些原理对于在 Unreal Engine 中开发稳定且高性能的游戏至关重要。

## II. Unreal Engine 标记-清除垃圾回收的核心原理 \[#ii-unreal-engine-标记-清除垃圾回收的核心原理]

### 标记-清除算法详解 \[#标记-清除算法详解]

Unreal Engine 的垃圾回收器采用的是\*\*标记-清除（Mark-and-Sweep）\*\*算法来管理 `UObject` 的内存。这种算法分为两个主要阶段：

* **标记阶段（Mark Phase）**：此阶段从一组被称为“根集合（Root Set）”的对象开始，对所有 `UObject` 实例进行图遍历。引擎会识别所有由根集合直接或间接引用的`UObject` 实例，并将它们标记为“可达”或“在使用中”。这个过程实质上是一个深度优先搜索（DFS）或类似的图遍历，旨在构建一个“垃圾回收图”或“不可触碰列表”，其中包含了所有仍在使用的对象。标记-清除算法能够有效处理循环引用问题，这是传统引用计数机制的常见痛点。然而，如果不对其进行优化，这种遍历和标记过程可能会导致“停顿世界（Stop-the-World）”式的暂停，从而在实时应用中产生明显的性能卡顿 4。这种对用户体验的直接影响促使了增量式垃圾回收的发展。
* **清除阶段（Sweep Phase）**：在标记阶段完成后，清除阶段会遍历内存中的所有 `UObject`。任何未被标记为可达的 `UObject`（即“不可达”或“未被引用”的对象）都将被销毁，其占用的内存将被回收并返回给系统。

### 根集合：定义、目的与示例 \[#根集合定义目的与示例]

“根集合”是 Unreal Engine 垃圾回收系统中的基础概念，它是一组被垃圾回收器始终视为活跃的 `UObject` 实例。任何直接或间接被根集合中对象引用的对象，都将被视为“在使用中”并保留在内存中。

常见的根集合对象包括：

* 已加载世界的 `UWorld` 实例，以及一些残余世界实例。

* 关卡中的 `AActor` 和 `USceneComponent` 实例。

* 通过 `AddToRoot()` 函数显式添加到根集合的对象。

* 新生成的 `AActor` 通常会自动成为根集合的一部分。

根集合的概念对于所有追踪式垃圾回收器都至关重要。在 Unreal Engine 中，其精心定义的根集合确保了核心游戏元素（如世界、角色和组件）不会被过早回收，从而构成了所有其他可达对象赖以存在的基础。如果对根集合的使用不当（例如，不必要地添加对象），可能导致内存膨胀。没有明确定义的根集合，GC 将无法确定可达性，从而可能错误地回收重要的游戏对象。引擎自动将 `UWorld` 和关卡中的 `AActor` 等关键对象包含在根集合中，简化了开发者的工作。然而，开发者在使用 `AddToRoot()` 时必须谨慎，因为这会绕过正常的垃圾回收规则，可能导致不再真正需要的对象持续占用内存，从而成为潜在的内存泄漏源。

### 可达性分析：引擎如何遍历对象图 \[#可达性分析引擎如何遍历对象图]

可达性分析是垃圾回收的核心过程。从根集合开始，GC 系统利用 Unreal 的反射系统来检查 `UObject` 中所有被 `UPROPERTY` 标记的成员变量。如果一个`UPROPERTY` 指向另一个 `UObject`，该对象就会被添加到“不可触碰列表”中，并且遍历会从这个新发现的对象继续递归进行。

需要强调的是，在此遍历过程中，只有 `UPROPERTY` 标记的指针（包括 `TArray` 中的指针）才会被 GC 考虑；原生 C++ 指针（`UObject*`）则会被 GC 忽略。这意味着，GC 的“智能”仅限于反射系统所暴露的信息。如果一个`UObject*` 指针被存储在一个没有 `UPROPERTY()` 标记的普通 C++ 成员变量中，GC 将无法识别这个引用。如果一个对象仅被此类“裸”指针引用，它将被视为不可达并被回收，即使程序逻辑仍然打算使用它。这会导致悬空指针，可能立即引发崩溃，或导致难以察觉的、不一致的内存损坏 。因此，对`UPROPERTY` 的正确使用至关重要，任何未被 `UPROPERTY` 标记的 `UObject` 引用都将创建一个 GC 无法识别的“隐藏”引用，从而可能导致被引用对象过早删除和悬空指针。这凸显了开发者正确标记代码的关键责任。

## III. Unreal 反射系统的不可或缺作用 \[#iii-unreal-反射系统的不可或缺作用]

### UPROPERTY：其在 GC 追踪对象引用中的关键功能 \[#uproperty其在-gc-追踪对象引用中的关键功能]

Unreal 属性系统（即反射系统）是 Unreal Engine 的一项基础技术，它允许程序在运行时检查和操作 C++ 类型。

`UPROPERTY()` 是使成员变量对该反射系统可见的关键宏。对于 `UObject` 指针而言，`UPROPERTY()` 宏会通知垃圾回收器关于该引用的存在，确保在标记阶段，被指向的 `UObject` 被视为可达。这对于 GC 的正确运行至关重要。

必须强调的是，使用“裸”的 `UObject` 指针（即未被 `UPROPERTY` 标记的指针）非常危险：GC 将不会跟踪它们，可能导致被引用对象过早删除和悬空指针。反射系统与 GC 的紧密耦合，通过`UPROPERTY` 强制执行，在 Unreal Engine 中创建了一种独特的编程范式。`UPROPERTY` 不仅仅关乎内存安全，它还支持序列化、蓝图暴露和网络复制等功能。这意味着正确使用`UPROPERTY` 是任何基于 `UObject` 的系统的多方面要求，其重要性远超简单的内存管理。如果 `UPROPERTY` 仅影响 GC，其重要性虽然很高但有限。然而，由于它是许多其他核心引擎功能（如编辑器细节面板、保存/加载、多人游戏）的入口，因此对于 `UObject` 成员变量而言，正确使用 `UPROPERTY` 变得不可或缺。这迫使开发者遵循一种特定的编码风格，虽然对于纯 C++ 程序员来说可能最初不熟悉，但最终在 Unreal 生态系统中提供了更集成和强大的开发体验。因此，“裸指针”的危险不仅是 GC 问题，更是一个系统性问题。

### UStruct 与 UObject：内存管理和 GC 参与的根本区别 \[#ustruct-与-uobject内存管理和-gc-参与的根本区别]

`UObject` 是 Unreal Engine 中主要由垃圾回收器管理的对象实体。与之不同，`UStruct`（或 `UScriptStruct`）被设计为“值类型”，适用于小量数据聚合（例如 `FVector`、`FRotator`）。关键在于，`UStruct` 本身不参与垃圾回收；它们必须始终存在于 `UObject` 内部或作为局部栈变量。与`UObject` 相比，`UStruct` 没有额外的 GC 簿记开销。然而，`UStruct` *可以*包含被 `UPROPERTY` 标记的 `UObject` 指针，并且如果该 `UStruct` 本身是 `UObject` 中被 `UPROPERTY` 标记的成员的一部分，这些指针*将*被 GC 追踪。

`UObject` 和 `UStruct` 之间的区别反映了引擎对性能的考量。`UStruct` 提供了一种轻量级、纯数据的方法，避免了小而频繁使用数据的 GC 开销，而 `UObject` 则提供健壮的生命周期管理和引擎集成。如果对这种区别理解不清，可能导致不必要的 `UObject` 开销或不安全的 `UStruct` 使用。如果每个小型数据容器都是一个 `UObject`，GC 图将变得过于庞大，增加遍历时间和内存开销。`UStruct` 提供了一种在不产生此成本的情况下分组数据的方法。然而，由于 `UStruct` 本身不被 GC 追踪，如果 `UStruct` 中直接包含的 `UObject*` 指针不属于 `UPROPERTY` 链，则可能导致未被追踪的引用。规则是，`UStruct` 必须包含在 `UObject` 的 `UPROPERTY` 中，其内部的 `UPROPERTY` 才能被 GC 考虑。

### 容器类型：TArray 和其他 UPROPERTY 标记的容器如何与 GC 交互 \[#容器类型tarray-和其他-uproperty-标记的容器如何与-gc-交互]

为了使垃圾回收器正常工作，它必须遍历每个对象的每个字段。尽管 Unreal 提供了多种容器类型（如`TArray`、`TMap`、`TSet`），但垃圾回收器主要只考虑 `UPROPERTY` 标记的 `TArray` 中包含的 `UObject` 指针。这意味着，如果一个`TArray<UObject*>` 被声明为 `UPROPERTY`，其元素（即它们指向的 `UObject`）将被追踪以确定可达性。

GC 对容器中 `UObject` 指针（主要是在 `UPROPERTY` 标记的 `TArray` 中）的有限支持意味着开发者在 `TMap`、`TSet` 或自定义容器中存储 `UObject` 引用时必须高度自律。对于这些情况，可能需要通过 `AddReferencedObjects` 手动声明引用，以防止对象被过早回收。引擎的反射系统对包含 `UObject` 指针的 `TArray` 有特定的逻辑。对于 `TMap` 或 `TSet`，虽然它们可以持有 `UObject` 指针，但 GC 的自动遍历可能不那么健壮或明确。这意味着，如果一个 `UObject` 仅由 `TMap<Key, UObject*>` 引用（即使 `TMap` 本身是 `UPROPERTY`），如果 GC 没有明确地遍历 `TMap` 值，它就有可能被回收。这通常需要重写使用此类容器的类的 `AddReferencedObjects` 函数，以明确告知 GC 这些引用。

## IV. GC 之外的内存管理：智能指针与原生 C++ \[#iv-gc-之外的内存管理智能指针与原生-c]

### TSharedPtr 与 TUniquePtr：非 UObject 内存管理的使用场景 \[#tsharedptr-与-tuniqueptr非-uobject-内存管理的使用场景]

Unreal Engine 的垃圾回收器*仅*管理 `UObject` 及其派生类。对于标准 C++ 对象（非`UObject` 派生类），Unreal 提供了自己的智能指针库，类似于 C++11 的 `std::shared_ptr` 和 `std::unique_ptr`。

* **`TSharedPtr`**：作为原生 C++ 对象的引用计数器。当其引用计数降至零时，对象将被销毁。需要注意的是，`TSharedPtr` 存在循环引用导致内存泄漏的风险。

* **`TUniquePtr`**：提供对原生 C++ 对象的独占所有权。当 `TUniquePtr` 超出作用域时，它所指向的对象将被删除。在 Unreal Engine 游戏开发中，`TUniquePtr` 很少用于对象所有权，因为它可能导致蓝图方面的问题。

Unreal Engine 的双重内存管理系统（`UObject` 的 GC 管理，非 `UObject` 的智能指针管理）要求开发者明确选择正确的工具。将 `TSharedPtr` 或 `TUniquePtr` 错误地用于 `UObject` 将导致与 GC 冲突的销毁尝试，从而引发崩溃。如果一个`TSharedPtr` 持有 `UObject`，当其引用计数降至零时，它会尝试 `delete` 该 `UObject`。然而，该 `UObject` 也由 Unreal 的 GC 管理，GC 最终会再次尝试 `delete` 它，从而导致双重释放和崩溃。这种严格的分离要求开发者对类型有清晰的认识。

### TWeakObjectPtr：管理 UObject 弱引用和防止循环依赖的作用 \[#tweakobjectptr管理-uobject-弱引用和防止循环依赖的作用]

`TWeakObjectPtr` 是一种专门用于 `UObject` 的弱指针。它**不会**阻止被引用的 `UObject` 被垃圾回收。如果 `UObject` 被销毁，`TWeakObjectPtr` 会自动变为 `nullptr`，并且 `IsValid()` 将返回 `false`。

`TWeakObjectPtr` 的主要用途是**打破 `UObject` 之间的循环引用**。一个强`UPROPERTY` 引用会创建一个硬链接，使对象保持活跃；而 `TWeakObjectPtr` 则允许一个对象“观察”另一个对象，而不会阻止其被回收。例如，UI 元素引用角色，或临时菜单项引用相关数据时，`TWeakObjectPtr` 都非常有用。

`TWeakObjectPtr` 是维护内存健康和防止由不可达对象循环引起的隐性内存泄漏的关键工具。它的必要性凸显了在 GC 环境中管理对象图的复杂性，即使是自动化系统也需要开发者介入来解决特定的拓扑问题。如果没有 `TWeakObjectPtr`，一个常见的场景，如对象 A 引用对象 B，而对象 B 又引用对象 A（例如，一个角色持有武器，武器又持有对其所有者的引用），就会形成一个循环。即使 A 和 B 都已不再从根集合可达，GC 也会因为它们相互之间的强引用而认为它们“在使用中”，从而阻止它们的回收。

`TWeakObjectPtr` 允许其中一个引用是“弱”的，从而打破循环，并允许 GC 在这两个对象真正从根集合不可达时将其回收。

### 管理原生 C++ 指针和非 UObject 内存 \[#管理原生-c-指针和非-uobject-内存]

对于使用 `new`/`delete` 分配的原生 C++ 类或结构体内存，开发者需要完全负责其管理。理想情况下，此类原生 C++ 对象应包含在 `UObject` 内部或由 Unreal 的智能指针管理。

`FGCObject` 是一个接口，适用于需要参与 GC 引用追踪的自定义 C++ 类（例如，如果它们本身持有 `UObject` 指针）。Unreal Engine 的内存模型是混合型的。虽然 `UObject` 由 GC 管理，但其底层的 C++ 性质意味着开发者仍然需要熟练掌握原生内存管理或智能指针的使用，以处理非 `UObject` 类型。这种混合方法增加了复杂性，但也提供了灵活性。Unreal Engine 基于 C++ 构建，而 C++ 本身不具备原生 GC。为了在简化内存管理的同时利用 C++ 的性能，Epic 创造了 `UObject` 及其 GC。然而，并非所有事物都需要成为 `UObject`。对于性能关键的数据结构或第三方库，原生 C++ 对象通常是首选 。这意味着开发者必须了解何时使用 `UObject` 以及何时使用原生 C++ 或智能指针，并正确管理后者。

### 表1：UObject 与非 UObject 内存管理对比 \[#表1uobject-与非-uobject-内存管理对比]

|类型|管理方式|GC 参与|创建方法|常见用例|关键注意事项|
|---|---|---|---|---|---|
|`UObject` (及派生类如 `AActor`, `UActorComponent`)|Unreal GC|是|`NewObject<>`, `SpawnActor<>`, `CreateDefaultSubobject<>`|游戏逻辑、资产、组件|引用需 `UPROPERTY` 标记，避免 `new`|
|`UStruct`|包含在 `UObject` 中|否 (但可包含 GC 追踪指针)|栈/堆分配|小型数据结构、值类型|必须由 `UObject` 或栈拥有，可包含 `UPROPERTY`|
|原生 C++ 对象|手动 (`new`/`delete`)|否|`new`|性能关键数据、外部库|手动释放，可能导致泄漏/崩溃|
|`TSharedPtr` (用于非 `UObject`)|`TSharedPtr` (引用计数)|否|`new`/`MakeShareable`|原生对象的共享所有权|循环引用风险，仅用于非 `UObject`|
|`TUniquePtr` (用于非 `UObject`)|`TUniquePtr` (独占所有权)|否|`new`/`MakeUnique`|原生对象的独占所有权|独占所有权，仅用于非 `UObject`|
|`TWeakObjectPtr` (用于 `UObject`)|Unreal GC (弱引用)|否 (但追踪 GC 管理对象)|直接赋值/`Pin()`|打破循环引用，临时观察|不阻止 GC，需检查 `IsValid()`|

## V. 对象生命周期与显式销毁机制 \[#v-对象生命周期与显式销毁机制]

### MarkPendingKill 与 MarkAsGarbage：标记对象以待后续 GC \[#markpendingkill-与-markasgarbage标记对象以待后续-gc]

`UObject` 在从根集合变得不可达时会自动被回收。然而，对于那些仍可达但需要显式移除的对象，可以调用 `MarkPendingKill()` 或 `MarkAsGarbage()` 等函数。这些函数会设置 `RF_PendingKill` 标志，将指向该对象的 `UPROPERTY` 引用置空，并将其从全局搜索中移除，确保它将在**下一个 GC 周期**中被销毁。

值得注意的是，`AActor` 和 `UActorComponent` 类通常有自己的 `Destroy()` 或 `DestroyComponent()` 方法，这些方法在内部会调用 `MarkPendingKill()` 。尽管 GC 是自动的，`MarkPendingKill` 仍提供了一种关键机制，用于在非确定性 GC 系统中实现确定性对象销毁。它允许开发者在对象变得不可达**之前**发出其已过时的信号，这对于需要显式“清理”对象（例如，当角色死亡或投射物命中时）的游戏逻辑至关重要。在游戏中，对象通常不会随机地“变得不可达”；它们往往是根据游戏逻辑被明确地从游戏世界中移除（例如，子弹击中墙壁，敌人被击败）。`MarkPendingKill` 允许游戏代码启动这些对象的销毁过程，确保它们在适当的时候被 GC 正确清理，而不是等待它们自然失去所有引用。这弥合了游戏逻辑与底层内存管理之间的鸿沟。

### ConditionalBeginDestroy, BeginDestroy, FinishDestroy：详细的对象销毁流程 \[#conditionalbegindestroy-begindestroy-finishdestroy详细的对象销毁流程]

一旦 `UObject` 被标记为待删除，其销毁过程将分为多个阶段：

* **`BeginDestroy()`**：此函数首先被调用，允许对象开始异步清理过程 7。开发者通常**不应**直接调用此函数。

* **`FinishDestroy()`**：当对象准备好完全销毁时调用，即在 `BeginDestroy` 完成其工作之后。

* **`ConditionalBeginDestroy()`**：在某些情况下被提及为用于立即销毁的函数。它通常在内部或特定编辑器场景中使用。

需要强调的是，GC 在游戏线程上运行，因此如果在游戏线程中访问对象，它不会在函数执行中途被清理。

`BeginDestroy` 和 `FinishDestroy` 的异步特性允许引擎将潜在的繁重清理操作分散到多个帧中，从而防止 GC 引起的卡顿。`ConditionalBeginDestroy` 则意味着一种更即时但仍受管理的销毁路径，可能用于特定引擎内部或仅限编辑器的场景，其中即时清理优先于增量分散。如果对象销毁（例如，释放大型纹理或复杂数据结构）同步且即时发生，可能会导致显著的帧率下降。通过将其拆分为 `BeginDestroy`（可以启动异步任务）和 `FinishDestroy`（在这些任务完成后完成），Unreal 确保了更流畅的性能。`ConditionalBeginDestroy` 可能处理对象的当前状态允许立即、非增量清理的情况，或者它是一个更大、显式销毁序列的一部分。

### 销毁 Actor 和组件：特殊考量 \[#销毁-actor-和组件特殊考量]

`AActor` 通过调用其 `Destroy()` 成员函数来销毁，该函数通常会调用 `World->DestroyActor()`。

`UActorComponent` 则通过调用 `DestroyComponent()` 或在其所属的 `AActor` 被销毁时被销毁。

关卡引用其 `AActor`，`AActor` 引用其 `UActorComponent`，通常通过重写 `UObject::AddReferencedObjects` 来确保这些对象在被显式销毁或关卡卸载之前保持活跃。这意味着它们在手动销毁之前不会被垃圾回收。Actor 和组件与 GC 之间存在一种特权关系，它们通常被 `UWorld` 或其所属 Actor 隐式地作为根对象。这简化了常见的游戏场景，但也意味着开发者必须显式调用 `Destroy()`（或类似函数），而不是简单地将这些核心类型的引用置空。这凸显了确保场景稳定性的刻意设计选择。如果 Actor 和组件仅仅依赖于任意对象的 `UPROPERTY` 引用，它们的生命周期将变得不可预测。通过让 `UWorld` 和所属 `AActor` 明确管理它们的引用（通常通过 `AddReferencedObjects`），Unreal 确保了这些基本场景元素会一直存在，直到游戏逻辑明确地将其移除，从而提供一个更健壮和可预测的场景图。

### AddReferencedObjects 与 AddToRoot：影响对象生命周期的手动方法 \[#addreferencedobjects-与-addtoroot影响对象生命周期的手动方法]

* **`UObject::AddReferencedObjects`**：这是一个虚函数，`UObject` 的子类可以重写它，以明确告知垃圾回收器关于**未被 `UPROPERTY` 标记**的 `UObject` 引用（例如，那些存储在原生 C++ 容器或自定义数据结构中的引用）。这确保了这些对象不会被过早回收。

* **`UObject::AddToRoot()` / `RemoveFromRoot()`**：`AddToRoot()` 明确地将一个对象添加到根集合中，保证它不会被垃圾回收，直到调用 `RemoveFromRoot()`。应强调的是，对于大多数 `UObject` 而言，这通常是“不必要”的，并且应极其谨慎地使用，以避免内存泄漏。

这些函数代表了开发者直接影响 GC 系统的“逃生舱口”或高级机制。`AddReferencedObjects` 是复杂数据结构必要的桥梁，而 `AddToRoot` 则是一个强大但危险的工具，它绕过了正常的 GC 规则，需要严格的手动管理。它们的存在承认了纯粹基于反射的自动化 GC 在处理所有边缘情况时的局限性。虽然 `UPROPERTY` 涵盖了大多数情况，但有时 `UObject` 指针会以反射系统无法自动发现的方式被持有（例如，在非 `UObject` 类中的 `std::vector<UObject*>` 中，或复杂的自定义图中）。`AddReferencedObjects` 为这些场景提供了回调。`AddToRoot` 适用于真正全局的、持久的对象（如单例），这些对象**绝不能**被回收，但它移除了 GC 的安全网，使得开发者完全负责其最终的 `RemoveFromRoot` 调用，否则将导致确定性的内存泄漏。

### 表2：关键对象销毁函数概览 \[#表2关键对象销毁函数概览]

| 函数                                    | 目的             | 调用者           | 对 GC 的影响  | 备注                          |
| ------------------------------------- | -------------- | ------------- | --------- | --------------------------- |
| `MarkPendingKill()`                   | 标记对象以待 GC，置空引用 | 开发者 (显式)      | 符合下一次清除条件 | 通常应避免直接调用 `UObject`，除非有明确需要 |
| `MarkAsGarbage()`                     | 标记对象以待 GC      | 开发者 (显式)      | 符合下一次清除条件 | 通常应避免直接调用 `UObject`，除非有明确需要 |
| `AActor::Destroy()`                   | 销毁 Actor 及其组件  | 开发者 (显式)      | 符合下一次清除条件 | 内部通常调用 `MarkPendingKill()`  |
| `UActorComponent::DestroyComponent()` | 销毁组件           | 开发者 (显式)      | 符合下一次清除条件 | 在所属 Actor 销毁时也会被调用          |
| `UObject::BeginDestroy()`             | 启动异步清理         | GC 系统         | GC 过程的一部分 | **不应**直接调用                  |
| `UObject::FinishDestroy()`            | 完成销毁           | GC 系统         | GC 过程的一部分 | **不应**直接调用                  |
| `UObject::ConditionalBeginDestroy()`  | 条件式/立即销毁       | 引擎/开发者 (特定情况) | 可触发 GC    | 通常用于编辑器或特定引擎内部场景            |
| `UObject::AddToRoot()`                | 通过添加到根集合来阻止 GC | 开发者 (显式)      | 阻止 GC     | 谨慎使用，如不移除可能导致泄漏             |
| `UObject::RemoveFromRoot()`           | 从根集合移除以允许 GC   | 开发者 (显式)      | 允许 GC     | 必须与 `AddToRoot()` 配对使用      |

## VI. 垃圾回收的演进与现代改进 \[#vi-垃圾回收的演进与现代改进]

### 增量式垃圾回收：解决性能卡顿和“停顿世界”暂停 \[#增量式垃圾回收解决性能卡顿和停顿世界暂停]

传统的标记-清除垃圾回收器在执行可达性分析时，由于需要遍历所有对象，可能导致“游戏卡顿”或“停顿世界”式的暂停。这种暂停会暂时停止所有`UObject` 的处理，包括游戏逻辑，从而影响帧率。

Unreal Engine 通过引入**增量式可达性分析Incremental Reachability Analysis**改进了这一问题，允许将 GC 的可达性分析阶段分散到多个帧中，并设置可配置的每帧软时间限制。这显著缩短了 GC 引起的帧率下降持续时间。增量式 GC 的引入反映了 Unreal Engine 内存管理的成熟，从一个功能性但可能具有破坏性的系统，发展为一个为软实时性能而设计的系统。这种演进对于在现代游戏中维持高帧率至关重要，尤其是在对象图复杂的情况下。随着游戏规模和复杂性的急剧增加，

`UObject` 的数量也随之膨胀。即使不频繁的完整 GC 也会导致明显的卡顿。增量式 GC 通过将工作分散到多个帧来直接解决这个问题，使得暂停不那么明显，这对玩家体验来说是一个关键的改进。

### TObjectPtr 与写屏障：增量分析的技术基础 \[#tobjectptr-与写屏障增量分析的技术基础]

`TObjectPtr` 是一种类似智能指针的类型，它取代了 `UPROPERTY` 暴露的 `UObject` 的原生 C++ 指针。其核心机制是**垃圾回收器写屏障（garbage collector write barrier）**：任何对 `TObjectPtr` 暴露的 `UPROPERTY` 的赋值操作，都会在垃圾回收进行中时立即将该对象标记为可达。这对于增量式 GC 至关重要，因为它确保了在 GC 周期进行中新引用的对象不会被错误地回收。

因此，将所有 `UPROPERTY` 实例转换为使用 `TObjectPtr` 而非原生 C++ 指针，对于项目充分利用增量可达性分析并防止过早 GC 至关重要。

`TObjectPtr` 和写屏障的引入是一个复杂的工程解决方案，旨在解决一个复杂的问题：如何在不丢失对新创建或重新引用对象追踪的情况下，增量地执行 GC。这一变化从根本上改变了开发者在 `UPROPERTY` 中声明 `UObject` 指针的方式，为了安全性和性能，放弃了原生指针。在增量式 GC 中，标记阶段会暂停并恢复。如果一个 `UObject` 在标记阶段已经通过其位置之后但**在清除阶段之前**被引用，传统的 GC 可能会错误地回收它。写屏障确保在活跃的 GC 周期中，任何新的引用赋值都会立即更新对象的可达状态，从而防止这种竞态条件，并在增量清除过程中保持正确性。这使得 `TObjectPtr` 成为强制性的最佳实践。

### GC 控制台变量：开发者的配置选项 \[#gc-控制台变量开发者的配置选项]

Unreal Engine 提供了一系列控制台变量，用于启用和配置增量式 GC：

* `gc.AllowIncrementalReachability=1`：启用增量可达性分析。

* `gc.AllowIncrementalGather=1`：启用增量收集不可达对象。

* `gc.IncrementalReachabilityTimeLimit=0.002`：设置每帧软时间限制（例如 2 毫秒）。

此外，还有用于压力测试和调试的变量，例如 `gc.DelayReachabilityIteration` 和 `gc.VerifyNoUnreachableObjects` 。提供 GC 控制台变量使开发者能够根据其项目的特定性能需求微调内存管理，从而平衡 GC 开销与所需的帧率。并非所有游戏都具有相同的性能特征或目标平台。移动游戏可能需要比高端 PC 游戏更激进的增量 GC 设置。这些控制台变量允许开发者根据其特定需求调整 GC 行为，从而实现量身定制的优化。

### 历史背景与 UE4 和 UE5 版本中的显著改进 \[#历史背景与-ue4-和-ue5-版本中的显著改进]

Unreal Engine 内存管理的核心 `UObject` 和反射系统自早期版本以来一直是其基础元素。随着引擎的发展，从旧的脚本语言（如 UnrealScript）转向 C++ 作为主要开发语言，促使了对健壮 C++ 内存管理解决方案的需求。

增量式 GC 的引入是后期 UE4 版本（例如，UE4.21 引入了与 GC 假设相关的更改、`TWeakObjectPtr` 修复以及“忽略 GC”状态行为）的一项重大改进，并在 UE5 中持续完善。UE5.5 进一步提升了性能，包括 GC 可达性分析。Unreal Engine GC 的持续演进，特别是向增量收集和`TObjectPtr` 的转变，反映了高性能应用中实时内存管理日益复杂化的行业趋势。这表明 Epic 致力于解决随着游戏复杂性增长而出现的基本性能瓶颈。早期游戏引擎通常依赖于更简单的内存方案或手动管理。随着游戏变得更加动态和视觉丰富，对象的数量呈爆炸式增长，使得简单的“停顿世界”式 GC 变得不可持续。Unreal 采用增量式 GC 和 `TObjectPtr` 表明了对这些日益增长的需求的回应，与现代 GC 进步保持一致。UE4.21 中“忽略 GC”状态的改变也表明了对边缘情况的完善以及对内存安全规则的收紧。

### 表3：增量式 GC 控制台变量 \[#表3增量式-gc-控制台变量]

|控制台变量|描述|类型|默认值|使用情境|
|---|---|---|---|---|
|`gc.AllowIncrementalReachability`|启用增量可达性分析|布尔 (0/1)|0|生产 (优化)|
|`gc.AllowIncrementalGather`|启用增量收集不可达对象|布尔 (0/1)|0|生产 (优化)|
|`gc.IncrementalReachabilityTimeLimit`|设置可达性阶段的软时间限制|浮点 (ms)|0.002|生产 (优化)|
|`gc.DelayReachabilityIteration`|将可达性分析延迟指定帧数|整数 (帧)|10|调试/压力测试|
|`gc.VerifyNoUnreachableObjects`|验证没有可达对象引用不可达对象|布尔 (0/1)|0|调试/验证|
|`gc.ContinuousIncrementalGC`|在前一次增量 GC 完成后持续重启|布尔 (0/1)|0|调试/压力测试|

## VII. GC 性能优化与最佳实践 \[#vii-gc-性能优化与最佳实践]

### 最小化 UObject 创建/销毁：对象池的重要性 \[#最小化-uobject-创建销毁对象池的重要性]

频繁创建和销毁 `UObject` 是触发 GC 周期并导致性能开销的主要原因。因此，**对象池（Object Pooling）** 成为一项关键的优化技术：与其销毁对象，不如将其返回到池中以供重复使用。这显著降低了 GC 压力，特别是对于频繁生成的实体，如投射物、粒子或敌人。

尽管 GC 自动化了内存清理，但它并非“免费”。追踪和清除的开销，即使是增量式的，也可能相当可观。对象池是一种主动策略，通过减少 GC 需要处理的对象**数量**来最小化 GC 工作，将成本从运行时解除分配转移到初始设置。GC 是被动的，它在对象不再需要时进行清理。对象池是主动的，它完全避免了对一类频繁回收的对象进行 GC 的需要。这是一种根本性的思维转变：开发者应该积极管理高频对象的生命周期，而不是让 GC 处理一切，以防止 GC 成为性能瓶颈。

### 避免和打破循环引用的策略 \[#避免和打破循环引用的策略]

`UObject` 之间的循环引用会阻止它们被垃圾回收，从而导致内存泄漏 1。建议在适当情况下使用`TWeakObjectPtr` 来打破这些依赖关系。循环依赖的一方应持有弱引用。

即使是能够处理循环引用的标记-清除 GC，也需要开发者的警惕性来识别并打破**非预期**的循环引用，因为这些循环引用代表了逻辑上的内存泄漏，即对象尽管在逻辑上“不再使用”却仍然存在。尽管 GC 算法本身可以处理循环，但它无法判断一个循环是**有意**保持对象活跃，还是一个意外的依赖。如果一个对象循环不再从根集合可达，GC 将会回收它们。然而，如果该循环**仍然**可达（例如，通过根集合中某个对象的一个 `UPROPERTY`），那么整个循环将持续存在。`TWeakObjectPtr` 允许开发者明确声明某个引用**不应**促使对象保持活跃，从而打破此类非预期的持久循环。

### 策略性使用 CollectGarbage()：何时手动调用与何时避免 \[#策略性使用-collectgarbage何时手动调用与何时避免]

建议避免在游戏过程中频繁手动调用 `CollectGarbage()`，因为它可能导致性能卡顿和帧率下降。但在特定、受控的情况下，手动调用可能很有用，例如在加载屏幕、关卡切换或游戏中的自然停顿点，这些情况下短暂的暂停是可以接受的。

手动调用 `CollectGarbage()` 是显式内存回收的最后手段，它承认了自动 GC 虽然通常高效，但在特定场景下（例如，卸载大型资产后）可能无法像期望的那样快速回收内存。其审慎使用表明了对 GC 行为的细致理解。引擎的自动 GC 会定期增量运行，以最小化影响。通过 `CollectGarbage()` 强制进行完整 GC 可能会是一个“停顿世界”的操作，导致明显的卡顿。因此，它只应在必须立即释放大量内存（例如，在加载新关卡之前，以确保足够的连续内存）且用户体验可以容忍短暂暂停的情况下使用。

### 减少 GC 开销的通用代码和资产优化技巧 \[#减少-gc-开销的通用代码和资产优化技巧]

GC 优化并非仅限于 GC 系统本身；它是一种涵盖代码架构、资产管线和关卡设计的整体方法。减少 `UObject` 的总数及其复杂性是降低 GC 开销最有效的方法，这表明主动的设计选择优于被动的调整。

* **减少 UObject 数量**：在可行的情况下，对于性能关键的代码或简单数据，优先使用原生 C++ 对象或 `UStruct` 而非 `UObject`，因为 `UObject` 会产生 GC 开销。蓝图宏比蓝图函数创建更多的 `UObject`；对于性能关键路径，将蓝图转换为 C++。

* **Tick 函数**：对于不需要每帧更新的 Actor/组件，禁用其 Tick 功能，因为不必要的 Tick 函数会增加开销。应使用事件驱动的更新方式。

* **资产优化**：尽管不直接与 GC 相关，但未优化的资产（高多边形模型、大尺寸纹理）会消耗大量内存，间接增加整体内存占用，并可能导致更频繁或更长的 GC 周期。应使用 LOD（细节级别）、纹理压缩、Mipmap 和高效的材质图。

* **软引用**：避免对远程或当前不需要的对象进行硬引用。使用 `TSoftObjectPtr` 或 `FSoftObjectPath` 仅在需要时加载资产，从而减少内存占用和 GC 压力。

* **忽略 GC（Disregard for GC）**：对于真正永久的对象（例如，早期初始化的单例），如果适用，可以考虑将其标记为“忽略 GC”，因为它们不受 GC 检查的影响。然而，需要了解其含义。

GC 必须遍历**所有** `UObject`。因此，`UObject` 越少，其引用图越简单，GC 运行就越快。这意味着在设计层面（例如，使用 `UStruct` 处理数据，对实例使用对象池）和实现层面（例如，将性能关键的蓝图转换为 C++，禁用不必要的 Tick）进行优化，对 GC 性能有着直接而显著的影响。资产优化虽然不直接与 GC 相关，但可以减少整体内存压力，进而减少 GC 运行的**频率**。

## VIII. 结论 \[#viii-结论]

### Unreal Engine 垃圾回收核心原理总结 \[#unreal-engine-垃圾回收核心原理总结]

Unreal Engine 的垃圾回收系统是专门为 `UObject` 设计的标记-清除机制，它高度依赖于通过 `UPROPERTY` 注解实现的反射系统。根集合和可达性分析是其运作的基石，确保了被引用对象不会被过早回收。对于非 `UObject` 内存，Unreal Engine 提供了智能指针（`TSharedPtr` 和 `TUniquePtr`）和原生 C++ 内存管理机制。`TWeakObjectPtr` 则作为一种关键工具，用于管理 `UObject` 的弱引用并打破潜在的循环依赖。对象的销毁是一个多阶段过程，通过 `MarkPendingKill` 等函数可以显式标记对象以待后续 GC。此外，增量式垃圾回收和 `TObjectPtr` 的引入，显著提升了 GC 的性能，减少了游戏中的卡顿现象。

### 理解 GC 对稳定和高性能游戏开发的重要性 \[#理解-gc-对稳定和高性能游戏开发的重要性]

尽管垃圾回收简化了内存管理，但深入理解其原理对于预防细微的错误（如悬空指针、由循环引起的内存泄漏）、优化性能以及编写健壮、可维护的代码至关重要。正确遵循 GC 实践直接有助于提供流畅和稳定的玩家体验。开发者需要认识到，即使是自动化系统，也需要对其工作原理有透彻的理解，才能在复杂的游戏开发环境中发挥其最大效能并避免潜在的陷阱。

### 未来展望与持续学习 \[#未来展望与持续学习]

内存管理和垃圾回收系统在游戏引擎中是持续演进的领域。随着游戏复杂度的不断提升和硬件技术的发展，Unreal Engine 的 GC 系统也将不断改进。因此，鼓励开发者持续关注 Unreal Engine 的官方文档和最佳实践，以适应最新的技术发展，从而在不断变化的开发环境中保持竞争力。
