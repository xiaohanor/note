---
title: return by value 和 return by reference
---
在C++中，函数可以通过值（return by value）或引用（return by reference）返回结果。这两种方法在用法和语义上有明显的区别：

### Return by Value（通过值返回） \[#return-by-value通过值返回]

* **用法**：函数返回一个值的副本。通常用于返回基本数据类型、结构体或小的类对象。

* **示例**：

```cpp
int returnValue() {
    int x = 10;
    return x;  // 返回 x 的副本
}
```

* **优点**：
  * 简单，因为函数返回的是值的副本。
  * 返回值的拷贝可以在函数返回后安全地使用，不会受到函数内部修改的影响。

* **缺点**：
  * 对于大型对象，返回值的拷贝可能会影响性能。
  * 对于某些类型，如动态分配的内存，需要额外的内存分配和拷贝操作，可能会导致内存泄漏或性能问题。

### Return by Reference（通过引用返回） \[#return-by-reference通过引用返回]

* **用法**：函数返回对象的引用，允许直接修改函数中定义的变量或对象。通常用于返回大型对象，以避免不必要的拷贝开销。

* **示例**：

```cpp
int& returnReference() {
    static int x = 10;  // 静态局部变量
    return x;           // 返回 x 的引用
}
```

* **优点**：
  * 避免了大型对象的拷贝开销，提高了性能。
  * 允许在函数外部直接修改函数内部的变量或对象。

* **缺点**：
  * 返回引用后，需要确保引用指向的对象在函数返回后仍然有效，避免出现悬空引用（dangling reference）。
  * 返回非局部对象的引用可能导致内存泄漏或未定义行为。

### 使用建议 \[#使用建议]

* 如果返回的是小型对象或基本数据类型，并且不需要修改返回值，通常使用返回值的方式更为简单和安全。
* 如果返回的是大型对象，并且需要在函数外部修改返回值，通常使用返回引用的方式更为高效。
* 在使用返回引用时，要确保引用指向的对象在函数返回后仍然有效，可以通过返回局部静态对象、动态分配内存等方式来保证引用的有效性。
